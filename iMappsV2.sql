-- we don't know how to generate database ImappsV2 (class Database) :(
create table vw_fg_receiving_hdr
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	check_point varchar(255),
	code varchar(255),
	description varchar(255),
	rack_id varchar(255),
	total_cartons int,
	trans_no varchar(255),
	type varchar(255),
	warehouse_id varchar(255)
)
go

create table m_line_lc
(
	id bigint identity
		constraint m_line_lc_id_pk
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	learn_curve float,
	mfg_loc varchar(255),
	period_01 float,
	period_02 float,
	period_03 float,
	period_04 float,
	period_05 float,
	period_06 float,
	period_07 float,
	period_08 float,
	period_09 float,
	period_10 float,
	period_11 float,
	period_12 float,
	period_13 float,
	period_14 float,
	period_15 float,
	period_16 float,
	period_17 float,
	period_18 float,
	period_19 float,
	period_20 float,
	period_21 float,
	period_22 float,
	period_23 float,
	period_24 float,
	period_25 float,
	period_26 float,
	period_27 float,
	period_28 float,
	period_29 float,
	period_30 float,
	line_code varchar(255),
	constraint m_line_lc_code_line_code_pk
		unique (code, line_code)
)
go

create table stg_SourceERP
(
	SrcERP varchar(20) not null
		constraint PK_stg_SourceERP
			primary key,
	Description nvarchar(50),
	FileLoc varchar(400),
	UserName varchar(50),
	Password varchar(50),
	AutoSplit bit
)
go

create table qconn_inline_qc_sub_det
(
	id bigint identity
		primary key,
	parent_id bigint not null,
	defect_category varchar(50) not null,
	defect_code varchar(50) not null,
	defect_qty int,
	time_created datetime2,
	created_by nvarchar(50),
	time_updated datetime2,
	updated_by nvarchar(50)
)
go

create table workers_output_detail
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	btno varchar(255),
	bundle_no varchar(255),
	code varchar(255),
	deleted varchar(255),
	description varchar(255),
	mono varchar(255),
	operation varchar(255),
	output_dt varchar(255),
	qty int,
	remarks varchar(255),
	sam float,
	scan_mode varchar(255),
	scan_type varchar(255),
	seq varchar(255),
	split int,
	svap varchar(255),
	vap varchar(255),
	work_section varchar(255),
	worker_id varchar(255)
)
go

create table m_line_mp
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	eff_date date,
	manpower int,
	mfg_loc varchar(255),
	line_code varchar(255)
)
go

create table m_order_types
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_oq3gw383wgdfiycv1p0rueyiv
			unique,
	default_percentage float,
	description varchar(255),
	erp bit not null,
	main_mat_lead float,
	mat_prep_lead float,
	no_range_cd varchar(10),
	prod_days float,
	sub_mat_lead float,
	transit_days float
)
go

create table vw_fg_report
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	ex_fty_date date,
	invoice_no varchar(255),
	iono varchar(255),
	order_qty bigint,
	pono varchar(255),
	report_date date,
	report_name varchar(255),
	ship_date date,
	ship_mode varchar(255),
	ship_to varchar(255),
	ship_to_remarks varchar(255),
	style_code varchar(255),
	total_barcode int,
	total_qty int,
	vendor varchar(255),
	warehouse_id varchar(255)
)
go

create table m_line_mp_exception
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	date_from date,
	date_to date,
	description varchar(255),
	mfg_loc varchar(20),
	line_code varchar(255),
	with_work bit,
	manpower int
)
go

create table qconn_aql_hdr
(
	id bigint identity
		constraint PK__qconn_aq__3213E83F77FB7516
			primary key,
	customer varchar(50) not null,
	country varchar(150) not null,
	product_type varchar(20) not null,
	audit_type varchar(20) not null,
	pono varchar(20) not null,
	mono varchar(20) not null,
	style varchar(50) not null,
	color varchar(50) not null,
	size int,
	status varchar(15),
	buyer varchar(15),
	created_by nvarchar(50),
	time_created datetime2,
	updated_by nvarchar(50),
	time_updated datetime2,
	carton_no varchar(50),
	reject_qty int constraint qconn_aql_hdr_reject_qty_default default 0,
	buyer_reject_qty int constraint qconn_aql_hdr_buyer_reject_qty_default default 0,
	buyer_inspection_date datetime2,
	customer_style varchar(20),
	destination varchar(20),
	po_qty int,
	product_name nvarchar(256)
)
go

create table workshifts
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	workshift varchar(255)
		constraint UK_7hydsktsph0iltmnxrgqx2qmm
			unique
)
go

create table login_history
(
	id int identity
		primary key,
	ip varchar(15) not null,
	agent varchar(max) not null,
	username nvarchar(50) not null,
	login_time datetime2
)
go

create table m_line_mp_exemption_det
(
	id bigint identity
		constraint m_line_mp_exemption_det_id_pk
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	mfg_loc varchar(20),
	line_code varchar(255),
	time_from datetime2,
	time_to datetime2,
	line_manpower_exemption_id bigint
)
go

create table m_plants
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_fn9pg4ntlbmr6nxho66m64lp3
			unique,
	description varchar(255)
)
go

create table ob_group_hdr
(
	id bigint identity
		primary key,
	active bit constraint ob_group_hdr_active_default default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	deleted bit,
	description varchar(255),
	group_name varchar(20),
	mono varchar(20),
	remarks varchar(100),
	svap varchar(10),
	vap varchar(10)
)
go

create index [NonClusteredIndex-20230922-114200]
	on ob_group_hdr (mono)
go

create table stg_MfgLocs
(
	MfgLoc varchar(20) not null
		constraint PK_stg_MfgLocs
			primary key,
	Desc1 nvarchar(100) not null,
	Desc2 nvarchar(100),
	Deleted bit constraint DF_stg_MfgLocs_Deleted default 0,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime constraint DF_stg_MfgLocs_CreatedDt default getdate() not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	DefaultLoc bit,
	CompareVal varchar(50),
	MfgLocShortCd varchar(3) not null,
	wTicket bit constraint DF_stg_MfgLocs_wTicket default 0,
	ParentMfgLoc varchar(20),
	LevelNo int,
	SeqStart int,
	GVAP varchar(20),
	Location varchar(50),
	Local bit,
	WBT bit,
	StdBndlQty int,
	DefaultWS varchar(50)
)
go

create table wip_warehouse
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	building varchar(255),
	code varchar(255),
	description varchar(255),
	factory varchar(255),
	racks varchar(255),
	warehouse_name varchar(255)
)
go

create table m_line_ws
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	line_code varchar(255),
	work_section varchar(255)
)
go

create table fg_references
(
	id bigint identity
		constraint fg_references_id_pk
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	ref_type varchar(255),
	seq int,
	type varchar(255)
)
go

create unique index fg_references_code_sbu_id_uindex
	on fg_references (code, sbu_id)
go

create table duplicateTest
(
	ID int,
	FirstName varchar(25),
	LastName varchar(25)
)
go

create table m_prod_type
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alt_description varchar(200),
	board_color varchar(200),
	code varchar(10)
		constraint UK_6f7qrfckvjhfqu7iat9un4hxc
			unique,
	description varchar(200)
)
go

create table ob_group_operations
(
	id bigint identity
		primary key,
	active bit constraint ob_group_operations_active_default default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	approved_by varchar(20),
	approved_date date,
	code varchar(255),
	deleted bit,
	description varchar(255),
	feature varchar(20),
	first_opn bit,
	for_print bit,
	group_name varchar(20),
	last_opn bit,
	mono varchar(20),
	operation varchar(20),
	seq int,
	split int,
	style varchar(20),
	factory_smv bit
)
go

create index FGWarehouse_SQLOPS_ob_group_operations_127_126
	on ob_group_operations (group_name, mono, id, active, deleted, feature, first_opn, last_opn, operation, seq, style)
go

create index FGWarehouse_SQLOPS_ob_group_operations_124_123
	on ob_group_operations (mono, id, active, created_by, sbu_id, time_created, time_updated, updated_by, approved_by, approved_date, code, deleted, description, feature, first_opn, for_print, last_opn, operation, seq, split, style, factory_smv, group_name)
go

create index FGWarehouse_SQLOPS_ob_group_operations_109_108
	on ob_group_operations (mono, id, feature, operation, seq, split)
go

create table tmp_delete_scanning_hdr
(
	purchase_order_id bigint not null,
	scanning_hdr_id bigint,
	created_by varchar(30),
	time_created datetime2
)
go

create table cust_grp_split_hdr
(
	Mfg_Loc varchar(50) not null,
	Cust_Grp varchar(50) not null,
	constraint PK_CustGrpSplitHdr
		primary key (Mfg_Loc, Cust_Grp)
)
go

create table qconn_aql_buyer
(
	id bigint identity
		primary key,
	parent_id bigint not null,
	defect nvarchar(150) not null,
	qty int,
	elapsed int,
	time_created datetime2,
	created_by nvarchar(50),
	time_updated datetime2,
	updated_by nvarchar(50),
	code nvarchar(10)
)
go

create table m_sales_grp
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_1klss8ic1w40aku29dt9nldne
			unique,
	description varchar(255)
)
go

create table ob_group_worksections
(
	id bigint identity
		primary key,
	active bit constraint ob_group_worksections_active_default default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	deleted bit,
	description varchar(255),
	group_name varchar(20),
	mono varchar(20),
	work_section varchar(20)
)
go

create table tmp_delete_loading_plan
(
	loading_plan_id bigint not null,
	purchase_order_dtl_id bigint not null,
	purchase_order_id int not null,
	created_by varchar(30),
	time_created datetime2
)
go

create table cust_grp_split_config
(
	Mfg_Loc varchar(50) not null,
	Cust_Grp varchar(50) not null,
	Split_Type varchar(50) not null,
	Effective_Dt datetime not null,
	Created_By nvarchar(50),
	Time_Created datetime constraint DF_CustGrpSplitConfig_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	to_dt datetime,
	constraint PK_CustGrpSplitConfig
		primary key (Mfg_Loc, Cust_Grp, Split_Type, Effective_Dt)
)
go

create table uccbarcodetable
(
	id numeric(19) identity
		primary key,
	asnnumber varchar(255),
	cartonno int,
	color varchar(255),
	containerloaddate datetime,
	createddate datetime,
	ordernumber varchar(255),
	orderqty int,
	packedqty int,
	sbu varchar(255),
	style varchar(255),
	uccbarcode varchar(255),
	upc varchar(255),
	verifyDate datetime,
	active bit,
	created_by varchar(50),
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	verify_date datetime2,
	sbu_id int
)
go

create table stgd_InterfaceMfgLocRT
(
	MfgLoc varchar(20) not null
		constraint FK_stg_InterfaceMfgLocRT_MfgLocs
			references stg_MfgLocs
				on update cascade,
	ServerName varchar(20) not null
		constraint FK_stg_InterfaceMfgLocRT_SourceERP
			references stg_SourceERP,
	LastRunTime datetime,
	PrevRuntime datetime,
	Deleted bit constraint DF_stg_InterfaceMfgLocRT_Deleted default 0,
	constraint PK_InterfaceMfgLocRT
		primary key (MfgLoc, ServerName)
)
go

create table qconn_aql_inhouse
(
	id bigint identity
		primary key,
	parent_id bigint not null,
	defect nvarchar(150) not null,
	qty int,
	elapsed int,
	time_created datetime2,
	created_by nvarchar(50),
	time_updated datetime2,
	updated_by nvarchar(50),
	code nvarchar(10)
)
go

create table m_season
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_ithkil7etuh756yhrdnsypl4i
			unique,
	description varchar(255)
)
go

create table ob_smv_det
(
	id bigint identity
		primary key,
	active bit constraint ob_smv_det_active_default default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	approved_by varchar(50),
	approved_dt date,
	code varchar(50),
	description varchar(255),
	eff_dt date,
	feature varchar(255),
	mono varchar(20),
	operation varchar(255),
	seq int,
	smv numeric(12,4),
	style varchar(25),
	revised bit default 0,
	revised_by varchar(50),
	revised_dt datetime
)
go

create index [NonClusteredIndex-20230922-113641]
	on ob_smv_det (mono, operation)
go

create table tmp_po_split_io
(
	PONumber varchar(22) not null,
	SplitNo numeric(6) not null,
	IO nvarchar(59)
)
go

create table qconn_token
(
	id bigint identity
		constraint qconn_token_pk
			primary key nonclustered,
	token varchar(255) not null
)
go

create table qconn_aql_chart
(
	id bigint identity
		primary key,
	range_from int,
	range_to int,
	size int,
	minor int,
	major int,
	time_created datetime2,
	created_by nvarchar(50),
	time_updated datetime2,
	updated_by nvarchar(50)
)
go

create table seq
(
	next_val bigint default NULL
)
go

create table m_ship_mode
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_ej0qvgk9owng95vj0ugyo6mds
			unique,
	description varchar(255)
)
go

create table qconn_card
(
	id bigint identity
		primary key,
	color varchar(10) not null,
	min int,
	max int,
	label varchar(100),
	created_by varchar(50),
	time_created datetime2,
	updated_by varchar(50),
	time_updated datetime2
)
go

create table ob_upload
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(20),
	description varchar(255),
	feature_code varchar(10),
	feature_description varchar(255),
	feature_no varchar(10),
	machine_code varchar(15),
	mono varchar(20),
	operation_code varchar(10),
	operation_desc varchar(255),
	operation_no int,
	operation_seq int,
	pay_grade varchar(10),
	price numeric(12,4),
	qty int,
	quota int,
	smv numeric(12,3),
	style_code varchar(25),
	style_description varchar(30),
	style_no varchar(15),
	svap varchar(10),
	vap varchar(10),
	split int,
	target_output varchar(20),
	cost varchar(20),
	difficulty varchar(50),
	remarks varchar(100),
	eff_dt datetime
)
go

create index [NonClusteredIndex-20230922-103650]
	on ob_upload (mono, operation_seq, operation_code, operation_desc, style_code, created_by, style_description, feature_code, feature_description)
go

create index [NonClusteredIndex-20230922-111844]
	on ob_upload (mono, created_by, feature_code, machine_code, operation_code, operation_desc, smv, style_code, svap, vap, cost, difficulty, operation_seq, split)
go

create table BO_Process
(
	SBU_Id int not null,
	MONo varchar(20) not null,
	BONo varchar(20) not null,
	Process varchar(20) not null,
	Load_On datetime,
	Plan_Start datetime not null,
	Plan_Finish datetime not null,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_BO_Process_Time_Created default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	constraint PK_BO_Process_1
		primary key (SBU_Id, MONo, BONo, Process)
)
go

create table m_shopfloor
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_ijlm373f7135sb8eebjlfffvd
			unique,
	description varchar(255)
)
go

create table stg_CustGrpSplitHdr
(
	MfgLoc varchar(50) not null,
	CustGrp varchar(50) not null,
	constraint PK_stg_CustGrpSplitHdr
		primary key (MfgLoc, CustGrp)
)
go

create table translation
(
	id bigint identity
		primary key,
	en varchar(max) not null,
	cn nvarchar(max),
	ind nvarchar(max),
	kh nvarchar(max),
	my nvarchar(max),
	th nvarchar(max),
	vn nvarchar(max),
	created_by varchar(50),
	time_created datetime2,
	updated_by varchar(50),
	time_updated datetime2
)
go

create table qconn_endLineQCHdr
(
	PTNo varchar(13) not null,
	Seq int not null,
	ProdLine varchar(10) not null,
	Reject bit,
	GarmentCount bit,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	Authorized bit,
	OldPTNo varchar(13),
	OldSeq int,
	LastTransferDt datetime,
	TransferBy nvarchar(50),
	constraint PK_Qconn_EndLineQCHdr
		primary key (PTNo, Seq)
)
go

create table m_src_erp
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_7jna6jdn8j6mrusnaxo9f7lb5
			unique,
	description varchar(255)
)
go

create table Style_Analysis_Det
(
	Style varchar(20) not null,
	Feature varchar(20) not null,
	Desc1 nvarchar(256) not null,
	Desc2 nvarchar(256),
	Deleted bit constraint DF_Style_Analysis_Det_Deleted default 0 not null,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_Style_Analysis_Det_Time_Created default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	constraint PK_Style_Analysis_Det
		primary key (Style, Feature)
)
go

create table wip_references
(
	id int identity
		primary key,
	ref_code varchar(40),
	key_ varchar(100),
	value_ varchar(100),
	created_by varchar(20),
	created_date datetime,
	updated_by varchar(20),
	updated_date datetime,
	isActive bit,
	remarks varchar(100)
)
go

create table BO_Time_Stamp
(
	Mfg_Loc varchar(50),
	Process varchar(100),
	User_Id varchar(50),
	Time_Stamp datetime
)
go

create table qconn_endlineQCHdr_transfer_logs
(
	PTNo varchar(13) not null,
	Seq int not null,
	ProdLine varchar(10) not null,
	Reject bit,
	GarmentCount bit,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	Authorized bit,
	OldPTNo varchar(13),
	OldSeq int,
	LastTransferDt datetime,
	TransferBy nvarchar(50),
	Action varchar(20)
)
go

create table BO_Version
(
	Mfg_Loc varchar(50),
	Trans_Id varchar(50),
	Description nvarchar(200),
	Trans_By nvarchar(50),
	Trans_Dt datetime constraint DF_BOVersion_TransDt default getdate(),
	Deleted bit constraint DF_BOVersion_Deleted default 0
)
go

create table qconn_endLineQCDet
(
	PTNo varchar(13) not null,
	Seq int not null,
	DefectType varchar(10) not null,
	DefectQty int,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	Frequency int not null,
	OldPTNo varchar(13),
	OldSeq int,
	constraint PK_qconn_EndLineQCDet
		primary key (PTNo, Seq, DefectType, Frequency)
)
go

create table DefectsCat
(
	DefectCat varchar(10) not null,
	Desc1 nvarchar(100) not null,
	Desc2 nvarchar(100),
	Deleted bit not null,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime
)
go

create table bo_hdr_deleted
(
	MONo varchar(20) not null,
	BONo varchar(20) not null,
	Mfg_Loc varchar(20) not null,
	Line varchar(20) not null,
	Plan_Qty int not null,
	SMV decimal(18,5),
	Eff decimal(5,2),
	EATM int,
	Plan_Start datetime not null,
	Plan_Finish datetime not null,
	Actual_Start datetime,
	Actual_Finish datetime,
	Plant_Color varchar(50),
	Prd_Typ varchar(50),
	Prd_Typ2 varchar(50),
	Dif varchar(50),
	Plant varchar(20),
	MO_Qty int not null,
	MO_Cus_Del_Dt datetime not null,
	Completed bit,
	Created_By nvarchar(50) not null,
	Time_Created datetime not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Completed_Remarks nvarchar(4000),
	Trans_Id varchar(50),
	Trans_Dt datetime,
	Process varchar(50),
	Prod_Month datetime,
	CP_No varchar(20),
	id int not null,
	active bit,
	sbu_id int,
	code varchar(12),
	description varchar(100),
	total_planned_qty int,
	total_output_qty int,
	rec_id uniqueidentifier
)
go

create table DefectTypes
(
	DefectType varchar(10) not null,
	DefectCat varchar(10) not null,
	Desc1 nvarchar(100) not null,
	Desc2 nvarchar(100),
	Level varchar(50) not null,
	Deleted bit not null,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	QC_SEVERITY varchar(10),
	constraint PK_DefectTypes
		primary key (DefectType, DefectCat)
)
go

create table BO_Hdr
(
	MONo varchar(20) not null,
	BONo int not null,
	Mfg_Loc varchar(20) not null,
	Line varchar(20) not null,
	Plan_Qty int not null,
	SMV decimal(18,5),
	Eff decimal(5,2),
	EATM int,
	Plan_Start datetime not null,
	Plan_Finish datetime not null,
	Actual_Start datetime,
	Actual_Finish datetime,
	Plant_Color varchar(50),
	Prd_Typ varchar(50),
	Prd_Typ2 varchar(50),
	Dif varchar(50),
	Plant varchar(20),
	MO_Qty int not null,
	MO_Cus_Del_Dt datetime not null,
	Completed bit constraint DF_BOHdr_Completed default 0,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_BOHdr_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Completed_Remarks nvarchar(4000),
	Trans_Id varchar(50),
	Trans_Dt datetime constraint DF_BOHdr_Trans_Dt default getdate(),
	Process varchar(50),
	Prod_Month datetime,
	CP_No varchar(20),
	id int identity
		constraint BO_Hdr_id_pk
			primary key,
	active bit,
	sbu_id int,
	code varchar(12),
	description varchar(100),
	total_planned_qty int,
	total_output_qty int constraint BO_Hdr_total_output_qty_default default 0,
	re_order_seq int,
	insert_id varchar(50),
	is_plan_month_late bit default 0 not null,
	is_delayed_shipment bit default 0 not null,
	is_material_delayed bit default 0 not null,
	step_no int
)
go

create unique index BO_Hdr_MONo_BONo_uindex
	on BO_Hdr (MONo, BONo, Plan_Start, Plan_Finish)
go

create table m_vap
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alt_description varchar(255),
	check_point bit not null,
	code varchar(32)
		constraint UK_1prwpc63ecqtv0fp8ighi8c8o
			unique,
	description varchar(255),
	initial_check_point bit not null,
	lean bit not null,
	plan_operation bit,
	print_operation bit,
	wbt bit not null,
	wpt bit not null
)
go

create table qconn_endlineQCDet_transfer_logs
(
	PTNo varchar(13) not null,
	Seq int not null,
	DefectType varchar(10) not null,
	DefectQty int,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	Frequency int not null,
	OldPTNo varchar(13),
	OldSeq int,
	TransferDt datetime
)
go

create table Calendar
(
	SBU_Id int not null,
	Calendar varchar(20) not null,
	Long_Text nvarchar(256) not null,
	DefaultWeekName varchar(20),
	Deleted bit not null,
	Time_Created datetime not null,
	Created_By nvarchar(50) not null,
	Time_Updated datetime,
	Updated_By nvarchar(50),
	constraint PK_Calendar
		primary key (SBU_Id, Calendar)
)
go

create table Operations
(
	Style varchar(20) not null,
	Feature varchar(20) not null,
	Operation varchar(50) not null,
	Desc1 nvarchar(256) not null,
	Desc2 nvarchar(256),
	VAP varchar(20) not null,
	SVAP varchar(20) not null,
	SAM numeric(10,4) constraint DF_Operations_SAM default 0 not null,
	Target_Output int constraint DF_Operations_Target_Output default 0 not null,
	Cost numeric(8,2) constraint DF_Table_2_OperationCost default 0 not null,
	Difficulty varchar(10),
	Escalation bit constraint DF_Operations_Escalation default 0,
	Deleted bit constraint DF_Operations_Deleted default 0 not null,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_Operations_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Sps_Machines_Cd varchar(50),
	Seq int,
	constraint PK_Operations
		primary key (Style, Feature, Operation)
)
go

create table qconn_endLineQCRFID
(
	PTNo varchar(13) not null,
	Seq int not null,
	ProdLine varchar(10) not null,
	NewRFID varchar(20) not null,
	NewSeq int not null,
	Status varchar(10) not null,
	Color varchar(50),
	RejectType varchar(50) not null,
	UserID nvarchar(50) not null,
	TransDt datetime constraint DF_qconn_EndLineQCRFID_TransDt default getdate() not null,
	FixedUserID nvarchar(50),
	FixedDt datetime,
	ConvertToRepairUserID nvarchar(50),
	ConvertToRepairDt datetime,
	ConvertToShipUserID nvarchar(50),
	ConvertToShipDt datetime,
	Remarks nvarchar(50),
	OldPTNo varchar(13),
	OldSeq int,
	Qty int,
	Parts nvarchar(50),
	CPStatus int constraint DF_qconn_EndLineQCRFID_CPStatus default 0,
	CPApprovedUserID varchar(50),
	CPApprovedDt datetime,
	CPConfirmedUserID varchar(150),
	CPConfirmedDt datetime,
	CPConfirmedQty int,
	constraint PK_qconn_EndLineQCRFID
		primary key (PTNo, Seq, NewRFID, NewSeq)
)
go

create table Calendar_Week
(
	SBU_Id int not null,
	Calendar varchar(20) not null,
	Week_Name varchar(20) not null,
	Date_From datetime,
	Date_To datetime,
	Time_Created datetime constraint DF_CalendarWeek_Time_Created default getdate() not null,
	Created_By nvarchar(50) not null,
	Time_Updated datetime,
	Updated_By nvarchar(50),
	constraint PK_Calendar_Week
		primary key (SBU_Id, Calendar, Week_Name)
)
go

create table m_work_breaktimes
(
	id bigint identity
		constraint m_work_breaktimes_PK
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	deletable bit,
	description varchar(255),
	editable bit,
	newable bit
)
go

create table BO_Daily_Output
(
	SBU_Id int not null,
	MONo varchar(20) not null,
	BONo varchar(20) not null,
	Line varchar(20) not null,
	Date datetime not null,
	Qty int not null,
	Target_Qty int,
	Created_By nvarchar(50),
	Time_Created datetime constraint DF_BO_Daily_Output_Time_Created default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Rec_ID varchar(50) constraint DF_BO_Daily_Output_Rec_ID default newid(),
	id int identity,
	active bit constraint DF_BO_Daily_Output_active default 1,
	code varchar(12),
	description varchar(100),
	constraint PK_BO_Daily_Output
		primary key (SBU_Id, MONo, BONo, Line, Date)
)
go

create table m_workshift
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	day_shift bit,
	description varchar(255),
	shift_type varchar(255),
	time_from datetime2,
	time_to datetime2
)
go

create table app_roles
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255)
)
go

create table qconn_endlineQCRFID_transfer_logs
(
	PTNo varchar(13) not null,
	Seq int not null,
	ProdLine varchar(10) not null,
	NewRFID varchar(20) not null,
	NewSeq int not null,
	Status varchar(10) not null,
	Color varchar(50),
	RejectType varchar(50) not null,
	UserID nvarchar(50) not null,
	TransDt datetime,
	FixedUserID nvarchar(50),
	FixedDt datetime,
	ConvertToRepairUserID nvarchar(50),
	ConvertToRepairDt datetime,
	ConvertToShipUserID nvarchar(50),
	ConvertToShipDt datetime,
	Remarks nvarchar(50),
	OldPTNo varchar(13),
	OldSeq int,
	Qty int,
	Parts nvarchar(50),
	CPStatus int,
	CPApprovedUserID varchar(50),
	CPApprovedDt datetime,
	CPConfirmedUserID varchar(50),
	CPConfirmedDt datetime,
	CPConfirmedQty int,
	TransferDt datetime
)
go

create table qconn_output_detail_info_v3
(
	id bigint identity
		primary key,
	MOno varchar(20) not null,
	IONo varchar(20),
	customer varchar(20),
	product varchar(100),
	StyleNo varchar(100),
	color varchar(20),
	size varchar(20),
	pono varchar(50),
	order_qty numeric(18,5),
	multi bit default 0,
	mo_inspected int,
	mo_output int,
	mo_set int,
	mo_plan_qty int,
	bundle_count int,
	destination varchar(max),
	date_updated datetime,
	updatedDt datetime,
	tag_mo_started bit default 0,
	custstyle varchar(100)
)
go

create table BO_Hdr_OK
(
	MONo varchar(20) not null,
	BONo varchar(20) not null,
	Mfg_Loc varchar(20) not null,
	Line varchar(20) not null,
	Plan_Qty int not null,
	SMV decimal(18,5),
	Eff decimal(5,2),
	EATM int,
	Plan_Start datetime not null,
	Plan_Finish datetime not null,
	Actual_Start datetime,
	Actual_Finish datetime,
	Plant_Color varchar(50),
	Prd_Typ varchar(50),
	Prd_Typ2 varchar(50),
	Dif varchar(50),
	Plant varchar(20),
	MO_Qty int not null,
	MO_Cus_Del_Dt datetime not null,
	Completed bit,
	Created_By nvarchar(50) not null,
	Time_Created datetime not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Completed_Remarks nvarchar(4000),
	Trans_Id varchar(50),
	Trans_Dt datetime,
	Process varchar(50),
	Prod_Month datetime,
	CP_No varchar(20),
	id int identity,
	active bit,
	sbu_id int,
	code varchar(12),
	description varchar(100),
	total_planned_qty int,
	total_output_qty int
)
go

create table mo_hdr
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime,
	time_updated datetime2,
	updated_by varchar(50),
	sub_mat_lead float,
	base_plan varchar(50),
	board_color varchar(50),
	cancel_mo_dt datetime2,
	code varchar(255),
	cono varchar(50),
	cus_del_dt date,
	date_rerouted datetime2,
	description varchar(255),
	eff float,
	fty_loc varchar(100),
	garm_part varchar(20),
	iono varchar(20),
	learn_curve varchar(20),
	lpd_dt date,
	main_mat_lead float,
	mat_prep_lead float,
	merchsmv float,
	mfg_loc varchar(20),
	mo_status varchar(20),
	mono varchar(20)
		constraint UK_5t439t1etob5csetfgc5bwgub
			unique,
	parent_mono varchar(20),
	plan_completed bit not null,
	plansmv float,
	plant varchar(20),
	post_sew float,
	pre_sew float,
	prod_days float,
	prod_min float,
	prod_month date,
	prod_type varchar(20),
	psd_dt date,
	re_routed bit not null,
	ref_auto_create_mo datetime2,
	remarks varchar(4000),
	req_ex_fty_dt date,
	req_main_mateta date,
	req_mateta date,
	req_prod_start date,
	req_sub_mateta date,
	rerouted_by varchar(20),
	rev_cus_del_dt date,
	rev_ex_fty_dt date,
	source_mono varchar(20),
	source_pono varchar(20),
	split_no float,
	style_no varchar(100),
	tcsmv float,
	transit_days float,
	season varchar(20)
)
go

create table ob
(
	id bigint identity
		primary key,
	active bit constraint ob_active_default default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	added_opn bit,
	code varchar(255),
	deleted bit,
	description varchar(255),
	downloaded_by varchar(255),
	downloaded_date datetime2,
	escalation bit,
	feature varchar(255),
	machine varchar(255),
	mono varchar(255),
	operation varchar(255),
	difficulty varchar(255),
	price_per_pc numeric(12,3),
	remarks varchar(255),
	revised_smv numeric(12,3),
	smv numeric(12,3),
	style_no varchar(255),
	svap varchar(255),
	target_output int,
	vap varchar(255),
	split int,
	seq int,
	smv2 numeric(12,3),
	wbt bit constraint DF_ob_wbt default 0,
	feature_desc nvarchar(max),
	operation_desc nvarchar(max),
	sync_fr varchar(20),
	sync_by nvarchar(50),
	time_sync datetime,
	mo_id bigint
		constraint FKfkja9im3sh6ui2bn82bblt319
			references mo_hdr,
	next_check_point varchar(12),
	next_ob_id bigint,
	first_opn bit,
	last_opn bit,
	last_opn_seq numeric(12,2)
)
go

create index FGWarehouse_SQLOPS_ob_48_47
	on ob (mono, id, operation, split, vap, seq)
go

create index ob_mono_svap_feature_index
	on ob (mono, svap, feature)
go

create index [NonClusteredIndex-20230922-113809]
	on ob (mono, feature, smv, svap, vap, seq)
go

create index [NonClusteredIndex-20230922-114002]
	on ob (mono, vap, split, seq, operation)
go

create index [NonClusteredIndex-20230922-114736]
	on ob (mo_id, id, svap, vap, seq)
go

create table mo_det
(
	id bigint identity
		primary key,
	active bit constraint DF_mo_det_active default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	act_qty float,
	bill_to_cust varchar(20),
	cm_price float,
	co_remarks varchar(100),
	co_status varchar(50),
	code varchar(255),
	color varchar(20),
	colortcsmv float,
	cono varchar(50),
	cpo_dt datetime2,
	cpo_item int,
	cpo_no varchar(50),
	cust_color varchar(20),
	cust_desc varchar(256),
	cust_dest varchar(50),
	cust_size varchar(20),
	cust_style varchar(20),
	description varchar(255),
	dest varchar(50),
	dlv_dt date,
	ex_fty_dt date,
	fab_pattern varchar(20),
	garm_qty int,
	item_no varchar(50),
	lpd_dt date,
	plan_dt date,
	pod_dt date,
	priority int,
	psd_dt date,
	qty int,
	remarks varchar(1000),
	rs_dt date,
	sales_ord_type varchar(50),
	ship_mode varchar(20),
	ship_to_cust varchar(20),
	size varchar(20),
	sold_to_cust varchar(20),
	style_no varchar(100),
	vsl_dt date,
	webbing varchar(50),
	mo_id bigint not null
		constraint FKhqafi55a25hlkbxineh7e7s9m
			references mo_hdr,
	mono varchar(20)
)
go

create index FGWarehouse_SQLOPS_mo_det_93_92
	on mo_det (mo_id, cono)
go

create index FGWarehouse_SQLOPS_mo_det_852_851
	on mo_det (active, mo_id)
go

create index FGWarehouse_SQLOPS_mo_det_850_849
	on mo_det (active, mo_id, id, created_by, sbu_id, time_created, time_updated, updated_by, act_qty, bill_to_cust, cm_price, co_remarks, co_status, code, color, colortcsmv, cono, cpo_dt, cpo_item, cpo_no, cust_color, cust_desc, cust_dest, cust_size, cust_style, description, dest, dlv_dt, ex_fty_dt, fab_pattern, garm_qty, item_no, lpd_dt, plan_dt, pod_dt, priority, psd_dt, qty, remarks, rs_dt, sales_ord_type, ship_mode, ship_to_cust, size, sold_to_cust, style_no, vsl_dt, webbing)
go

create index FGWarehouse_SQLOPS_mo_det_52_51
	on mo_det (mono)
go

create index FGWarehouse_SQLOPS_mo_det_120_119
	on mo_det (qty, mono)
go

create index FGWarehouse_SQLOPS_mo_det_113_112
	on mo_det (dlv_dt, qty, sbu_id, cono, mo_id, mono)
go

create index FGWarehouse_SQLOPS_mo_det_106_105
	on mo_det (mono, qty, ex_fty_dt)
go

create index FGWarehouse_SQLOPS_mo_det_104_103
	on mo_det (item_no)
go

create index PK_MO_Det
	on mo_det (mono, item_no)
go

create table mo_det_priority
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	cono varchar(20),
	description varchar(255),
	dlv_dt date,
	priority int,
	mo_id bigint not null
		constraint FK6a6w9u92nrx0dkr9t7dxl5rni
			references mo_hdr,
	mono varchar(20)
)
go

create index FGWarehouse_SQLOPS_mo_det_priority_845_844
	on mo_det_priority (active, mo_id)
go

create index FGWarehouse_SQLOPS_mo_det_priority_843_842
	on mo_det_priority (active, mo_id, id, created_by, sbu_id, time_created, time_updated, updated_by, code, cono, description, dlv_dt, priority)
go

create index FGWarehouse_SQLOPS_mo_det_priority_111_110
	on mo_det_priority (cono, mono)
go

create index FGWarehouse_SQLOPS_mo_det_priority_108_107
	on mo_det_priority (mono, id)
go

create table BO_Daily_Target
(
	MONo varchar(20) not null
		constraint FK7rlpyxheksp97q21pucppjmyb
			references mo_hdr (mono),
	BONo varchar(20) not null,
	Line varchar(20) not null,
	Date datetime not null,
	Qty int not null,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_BO_Daily_Target_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Trans_Id varchar(50),
	Trans_Dt datetime constraint DF_BO_Daily_Target_TransDt default getdate(),
	Mfg_Loc varchar(20) not null,
	id int identity
		constraint BO_Daily_Target_id_pk
			primary key,
	active bit constraint DF_BO_Daily_Target_active default 1,
	sbu_id int constraint DF_BO_Daily_Target_sbu_id default 1,
	code varchar(12),
	description varchar(100),
	Mfg_Loc_id int,
	mo_id bigint
		constraint FK1213roo4upm4c83k82g0gpsug
			references mo_hdr,
	plan_start datetime,
	plan_finish datetime,
	seq int,
	smv numeric(12,4),
	original_daily_target int,
	actual_output_qty int,
	learning_curve numeric(12,2),
	insert_id varchar(50),
	constraint PK_BO_Daily_Target_1
		unique (MONo, BONo, Line, Date, Mfg_Loc)
)
go

create index FGWarehouse_SQLOPS_mo_hdr_99_98
	on mo_hdr (iono)
go

create index FGWarehouse_SQLOPS_mo_hdr_859_858
	on mo_hdr (mono)
go

create index FGWarehouse_SQLOPS_mo_hdr_83_82
	on mo_hdr (iono, id)
go

create index FGWarehouse_SQLOPS_mo_hdr_50_49
	on mo_hdr (mo_status, time_updated, iono, mfg_loc, mono)
go

create index FGWarehouse_SQLOPS_mo_hdr_102_101
	on mo_hdr (cono, iono)
go

create index FGWarehouse_SQLOPS_mo_hdr_1014_1013
	on mo_hdr (active, plan_completed, mo_status, mono)
go

create index FGWarehouse_SQLOPS_mo_hdr_1008_1007
	on mo_hdr (active, plan_completed, mo_status, mono, plansmv)
go

create index FGWarehouse_SQLOPS_mo_hdr_1006_1005
	on mo_hdr (active, mono, plan_completed, mo_status, plansmv)
go

create table qconn_output_detail_daily_v3
(
	id bigint identity
		primary key,
	trans_date datetime,
	mono varchar(20) not null,
	ptno varchar(15) not null,
	style varchar(50),
	color varchar(50),
	layNo varchar(50),
	line varchar(50),
	good_qty numeric(8),
	reject_qty numeric(8),
	reworked_qty numeric(8),
	repaired_qty numeric(8),
	unreapairable_qty numeric(8),
	replaceable_qty numeric(8),
	prev_reworked numeric(8),
	date_updated datetime,
	UpdatedDt datetime,
	secondquality_qty numeric(8),
	condpass_qty numeric(8),
	disposed_qty numeric(18)
)
go

create table mo_mat_list
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	dc_qty float,
	description varchar(255),
	eta_dt date,
	ex_mill_dt date,
	in_avail_qty float,
	in_post_dt date,
	in_tran_qty float,
	iono varchar(255),
	leta_fty_dt date,
	mat_desc varchar(500),
	mat_no varchar(50),
	mat_specs_cn varchar(500),
	mat_specs_en varchar(500),
	mat_type varchar(50),
	mat_type_desc varchar(500),
	plant_avail_dt date,
	process varchar(30),
	wh_qty float
)
go

create table MO_SVAP_Part
(
	MONo varchar(20) not null,
	Seq smallint not null,
	Part_Cd varchar(20) not null,
	VAP varchar(20) not null,
	SVAP varchar(20) not null,
	Deleted bit constraint DF_MOSVAPPart_Deleted default 0 not null,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_MOSVAPPart_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime constraint DF_MOSVAPPart_UpdatedDt default getdate(),
	constraint PK_MO_SVAP_Part
		primary key (MONo, Seq, Part_Cd)
)
go

create table m_uploaded_files
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	m_deleted char(1),
	description varchar(255),
	feature varchar(255),
	file_name varchar(255),
	file_path varchar(255),
	operation varchar(255),
	parent_id int,
	request_no varchar(255),
	style_no varchar(255),
	transaction_name varchar(255)
)
go

create table m_customer_group_ext
(
	cus_grp_ext varchar(20) not null,
	source varchar(50) not null,
	cus_grp varchar(20),
	desc1 nvarchar(100) not null,
	deleted bit constraint DF_Table_1_Deleted default 0 not null,
	created_by nvarchar(50) not null,
	time_created datetime constraint DF_Table_1_CreatedDt default getdate() not null,
	updated_by nvarchar(50),
	time_updated datetime,
	constraint PK_m_customer_group_ext
		primary key (cus_grp_ext, source)
)
go

create table BO_Learn_Curve
(
	MONo varchar(20) not null,
	BONo int not null,
	Line varchar(20) not null,
	Learn_Curve varchar(20),
	Interval int,
	Period_01 numeric(18,4),
	Period_02 numeric(18,4),
	Period_03 numeric(18,4),
	Period_04 numeric(18,4),
	Period_05 numeric(18,4),
	Period_06 numeric(18,4),
	Period_07 numeric(18,4),
	Period_08 numeric(18,4),
	Period_09 numeric(18,4),
	Period_10 numeric(18,4),
	Period_11 numeric(18,4),
	Period_12 numeric(18,4),
	Period_13 numeric(18,4),
	Period_14 numeric(18,4),
	Period_15 numeric(18,4),
	Period_16 numeric(18,4),
	Period_17 numeric(18,4),
	Period_18 numeric(18,4),
	Period_19 numeric(18,4),
	Period_20 numeric(18,4),
	Period_21 numeric(18,4),
	Period_22 numeric(18,4),
	Period_23 numeric(18,4),
	Period_24 numeric(18,4),
	Period_25 numeric(18,4),
	Period_26 numeric(18,4),
	Period_27 numeric(18,4),
	Period_28 numeric(18,4),
	Period_29 numeric(18,4),
	Period_30 numeric(18,4),
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_BOLearnCurve_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Trans_Id varchar(50),
	Trans_Dt datetime constraint DF_BOLearnCurve_TransDt default getdate(),
	Mfg_Loc varchar(20) not null,
	id int identity
		constraint BO_Learn_Curve_id_pk
			primary key,
	active bit constraint DF_BO_Learn_Curve_active default 1,
	sbu_id int constraint DF_BO_Learn_Curve_sbu_id default 1,
	code varchar(12),
	description varchar(100),
	insert_id varchar(50)
)
go

create table res_country
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alternate_name varchar(100),
	area_code varchar(5),
	code varchar(5)
		constraint UK_pw1hmebshxfb1qsapmei6xh9e
			unique,
	continent_code varchar(100),
	description varchar(100),
	time_zone varchar(100)
)
go

create table res_city
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alternate_name varchar(100),
	area_code varchar(5),
	code varchar(5)
		constraint UK_fc5qd2y4qk1vheduu2rgrbgio
			unique,
	description varchar(100),
	time_zone varchar(100),
	country_id bigint
		constraint FK70eicjk73u16ye7gj54setxsg
			references res_country
)
go

create table OB_Spare_BT
(
	MONo varchar(20) not null,
	Feature varchar(20) not null,
	Spare_BT numeric(18) not null,
	Shell_No varchar(50),
	Deleted bit constraint DF_OBSpareBT_Deleted default 0,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_OBSpareBT_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	active bit constraint DF_OB_Spare_BT_active default 1,
	constraint PK_OB_Spare_BT
		primary key (MONo, Feature)
)
go

create table m_customers_ext
(
	customer varchar(20) not null,
	customer_ext varchar(20) not null,
	desc1 nvarchar(100) not null,
	source varchar(50) not null,
	deleted bit constraint DF_Table_1_Deleted_1 default 0,
	created_by nvarchar(50) not null,
	time_created datetime constraint DF_Table_1_CreatedDt_1 default getdate() not null,
	updated_by nvarchar(50),
	time_pdated datetime,
	constraint PK_m_customers_ext
		primary key (customer, customer_ext, source)
)
go

create table res_state
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alternate_name varchar(100),
	area_code varchar(5),
	code varchar(5)
		constraint UK_hbps1627gachihr3v8n3msud1
			unique,
	description varchar(100),
	time_zone varchar(100),
	country_id bigint
		constraint FKgo6rfoba9pxxos2qpbnsgbfu1
			references res_country
)
go

create table IO_Mat_List
(
	id bigint identity,
	sbu_id int constraint DF_IO_Mat_List_sbu_id default 1 not null,
	RecId varchar(50) constraint DF_IOMatLst_ItemNo default newid() not null
		constraint PK_IO_Mat_List_1
			primary key,
	IONo varchar(50) not null,
	Style_No varchar(50),
	Season varchar(50),
	UV varchar(50) not null,
	Mat_No varchar(50) not null,
	Mat_Desc nvarchar(500),
	Mat_Typ_Grp varchar(50),
	Mat_Typ_Grp_Desc nvarchar(500),
	Mat_Grp varchar(50),
	Mat_Grp_Desc nvarchar(500),
	Mat_Typ varchar(50),
	Mat_Typ_Desc nvarchar(500),
	Processes varchar(100),
	FG_Req_Qty numeric(18,5),
	Req_Qty numeric(18,5),
	Base_UOM varchar(50),
	In_Avail_Qty numeric(18,5),
	In_Rej_Qty numeric(18,5),
	In_Post_Dt datetime,
	In_Perc numeric(18,5),
	In_FG_Qty numeric(18,5),
	In_Tran_Qty numeric(18,5),
	In_Tran_ETA_Dt datetime,
	In_Tran_Perc numeric(18,5),
	In_Tran_FG_Qty numeric(18,5),
	Bal_Perc numeric(18,5),
	Prod_Co_Cd varchar(20),
	Prod_BA varchar(20) constraint DF_IOMatLst_Deleted default 0,
	Plant_Cd varchar(20),
	Mat_Status varchar(50),
	Time_Created datetime,
	Created_By varchar(50),
	CONo varchar(50),
	Prod_Type varchar(50),
	Ex_Mill_Dt datetime,
	Process varchar(20),
	Plant_Avail_Dt datetime,
	Perc_Complete numeric(5,2),
	DC_Qty numeric(18,5),
	WH_Qty numeric(18,5),
	Sew_Plant_Avail_Dt datetime,
	Comp_ETA datetime,
	ETA_Fty datetime,
	ETA_HK datetime,
	ID_Qty numeric(18,5),
	ID_Act_Rcv_Dt datetime,
	MR_Dt datetime,
	PR_Dt datetime,
	PO_Dt datetime,
	TP_Dt datetime,
	TO_Dt datetime,
	ETA_Dt datetime,
	GIMR_Iss_Max_Dt datetime,
	GIMR_Iss_Dt datetime,
	MR_Qty numeric(18,5),
	PR_Qty numeric(18,5),
	PO_Qty numeric(18,5),
	PA_Qty numeric(18,5),
	Iss_Prod_Qty numeric(18,5),
	Reqd_Qty numeric(18,5),
	Old_Mat_No nvarchar(100),
	Color nvarchar(100),
	Tot_Qty numeric(18,5),
	Tot_Test_Qty numeric(18,5),
	ReOrder_Qty numeric(18,5),
	Mat_Specs_EN nvarchar(4000),
	Mat_Specs_CN nvarchar(4000),
	LETA_Fty datetime,
	Country_Cd varchar(10),
	Dlv_Qty numeric(18,5),
	Order_UOM varchar(10),
	ETA_Fty_DLL varchar(30),
	PONo varchar(10),
	Mat_Type_EN nvarchar(256),
	Mat_Type_CN nvarchar(256),
	Depart_Ind bit,
	Mat_Color_EN varchar(500)
)
go

create table transaction_logs
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	api varchar(150) not null,
	code varchar(255),
	description varchar(255),
	module varchar(100) not null,
	remarks varchar(255) not null
)
go

create table style_hdr
(
	style_no varchar(100) not null
		constraint PK_Style_Hdr
			primary key,
	desc1 nvarchar(256),
	desc2 nvarchar(256),
	prod_typ varchar(20),
	prod_typ_desc nvarchar(256),
	board_color varchar(50)
)
go

create table Calendar_Ex
(
	SBU_Id int not null,
	Calendar varchar(20) not null,
	Ex_Name varchar(50) not null,
	Long_Text nvarchar(256),
	Has_Work bit constraint DF_CalendarEx_HasWork default 0 not null,
	Date_From datetime not null,
	Date_To datetime not null,
	Time_Created datetime constraint DF_CalendarEx_CreatedDt default getdate() not null,
	Created_By nvarchar(50) not null,
	Time_Updated datetime,
	Updated_By nvarchar(50),
	Date_Year int not null,
	constraint PK_Calendar_Ex
		primary key (SBU_Id, Calendar, Ex_Name, Date_Year)
)
go

create table Control_File
(
	ReportServer varchar(200),
	HRIS varchar(20),
	ReportLogIn varchar(50),
	ReportPassword varchar(50),
	DOWithApprval bit,
	BreaktimeScheme smallint constraint DF_ControlFile_BreaktimeScheme default 1 not null,
	OBAutoSyncc bit constraint DF_ControlFile_OBAutoSyncc default 0 not null,
	DBServer varchar(200),
	OBSyncPer varchar(15),
	ActualTime bit constraint DF_ControlFile_ActualTime_1 default 0,
	Escalation bit constraint DF_ControlFile_Escalation_1 default 0,
	LinearOprn bit constraint DF_ControlFile_LinearOprn_1 default 1,
	AutoSMVAprvl bit,
	AutoFtySMV bit,
	CheckWSSetupLine bit,
	AutoWSSetup bit constraint DF_ControlFile_AutoWSSetup_1 default 0,
	CtrlCutQty bit constraint DF_ControlFile_CtrlCutQty default 0 not null
)
go

create table user_auth_prodline
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	desc1 varchar(255),
	description varchar(255),
	prodline varchar(255),
	userid varchar(255)
)
go

create table BO_Hdr_BACKUP
(
	MONo varchar(20) not null,
	BONo varchar(20) not null,
	Mfg_Loc varchar(20) not null,
	Line varchar(20) not null,
	Plan_Qty int not null,
	SMV decimal(18,5),
	Eff decimal(5,2),
	EATM int,
	Plan_Start datetime not null,
	Plan_Finish datetime not null,
	Actual_Start datetime,
	Actual_Finish datetime,
	Plant_Color varchar(50),
	Prd_Typ varchar(50),
	Prd_Typ2 varchar(50),
	Dif varchar(50),
	Plant varchar(20),
	MO_Qty int not null,
	MO_Cus_Del_Dt datetime not null,
	Completed bit,
	Created_By nvarchar(50) not null,
	Time_Created datetime not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Completed_Remarks nvarchar(4000),
	Trans_Id varchar(50),
	Trans_Dt datetime,
	Process varchar(50),
	Prod_Month datetime,
	CP_No varchar(20),
	id int identity,
	active bit,
	sbu_id int,
	code varchar(12),
	description varchar(100),
	total_planned_qty int,
	total_output_qty int,
	re_order_seq int
)
go

create table style_image
(
	style_no varchar(100) not null
		constraint PK_Style_Image
			primary key,
	img01 image,
	img02 image,
	Filename varchar(100)
)
go

create table user_auth_vap_svap
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	svap varchar(255),
	userid varchar(255),
	vap varchar(255)
)
go

create table m_calendar
(
	id bigint identity
		constraint m_calendar_id_pk
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	calendar_name varchar(20),
	code varchar(255),
	default_week_name varchar(20),
	description varchar(255)
)
go

create table view_mo_color_description
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255)
)
go

create table m_Interface_Mat_RT
(
	id int identity,
	sbu_id int constraint DF_m_Interface_Mat_RT_sbu_id default 1,
	Server_Name varchar(20) not null
		constraint PK_m_Interface_Mat_RT
			primary key,
	Last_RunTime datetime,
	Prev_Runtime datetime,
	Active bit constraint DF_m_Interface_Mat_RT_Active default 1
)
go

create table m_calendar_exception
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	date_from datetime,
	date_to datetime,
	date_year int,
	description varchar(255),
	ex_name varchar(50),
	has_work int,
	calendar_id bigint not null
		constraint FKn171sayodbkb5nns3tbu2t2j2
			references m_calendar
)
go

create table m_calendar_week
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	date_from datetime2,
	date_to datetime2,
	description varchar(255),
	week_name varchar(255),
	calendar_id bigint not null
		constraint FKo256g7ee5tirhv76c29rdlwm8
			references m_calendar
)
go

create table view_wip_bundle_tracking
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	btno varchar(255),
	code varchar(255),
	color varchar(255),
	description varchar(255),
	feature varchar(255),
	issued_by varchar(255),
	issued_date datetime2,
	mo_no varchar(255),
	origin varchar(255),
	qty varchar(255),
	received_by varchar(255),
	received_date datetime2,
	svap varchar(255)
)
go

create table m_calendar_week_day
(
	id bigint identity
		constraint m_calendar_week_day_id_pk
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	has_work int,
	seq int,
	week_name varchar(20),
	calendar_id bigint not null
		constraint FKb9d40b9yo80i15fv8fkiw5c9o
			references m_calendar
)
go

create table Calendar_Week_Day
(
	SBU_Id int not null,
	Calendar varchar(20) not null,
	Week_Name varchar(20) not null,
	Week_Day varchar(20) not null,
	Has_Work bit constraint DF_CalendarWeekDay_HasWork default 0 not null,
	Seq int not null,
	Time_Created datetime constraint DF_CalendarWeekDay_CreatedDt default getdate() not null,
	Created_By nvarchar(50) not null,
	Time_Updated datetime,
	Updated_By nvarchar(50),
	constraint PK_CalendarWeekDay
		primary key (SBU_Id, Calendar, Week_Name, Week_Day)
)
go

create table m_calendar_week_day_det
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	date_from datetime2,
	date_to datetime2,
	description varchar(255),
	guid varchar(255),
	calendar_id bigint not null
		constraint FKgyh02sqbjcraiien151gibepq
			references m_calendar,
	calendar_week_day_id bigint not null
		constraint FKfojytfymidp07eog4uiojw3rd
			references m_calendar_week_day
)
go

create table view_wip_email_alerts
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	body varchar(255),
	code varchar(255),
	description varchar(255),
	is_sent bit,
	recipient varchar(255),
	redirect_url varchar(255),
	schedule_date datetime2,
	subject varchar(255)
)
go

create table m_Interface_Mfg_Loc_RT
(
	Mfg_Loc varchar(20) not null,
	Server_Name varchar(20) not null,
	Last_RunTime datetime,
	Prev_Runtime datetime,
	Active bit constraint DF_m_Interface_Mfg_Loc_RT_Active default 1,
	constraint PK_m_Interface_Mfg_Loc_RT
		primary key (Mfg_Loc, Server_Name)
)
go

create table Event_SVAP
(
	Event_Seq int not null,
	VAP varchar(20) not null,
	SVAP varchar(20) not null,
	Deleted bit constraint DF_EventSVAP_Deleted default 0 not null,
	Created_By nvarchar(50) not null,
	Created_Dt datetime constraint DF_EventSVAP_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Updated_Dt datetime,
	constraint PK_EventSVAP
		primary key (Event_Seq, VAP, SVAP)
)
go

create table m_department
(
	id bigint identity
		constraint m_department_id_pk
			primary key nonclustered,
	created_by varchar(50),
	time_created datetime default getdate(),
	updated_by varchar(50),
	time_updated datetime,
	active bit default 1,
	sbu_id bigint not null,
	code varchar(30),
	description nvarchar(128),
	alt_description nvarchar(128)
)
go

create index m_department_active_index
	on m_department (active)
go

create index m_department_sbu_id_index
	on m_department (sbu_id)
go

create unique index m_department_sbu_id_code_uindex
	on m_department (sbu_id, code)
go

create table view_wip_part
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	material varchar(255),
	mono varchar(255),
	part varchar(255),
	svap varchar(255)
)
go

create table wip_settings
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	settings varchar(255)
)
go

create table view_wip_workers_output
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	color varchar(255),
	date varchar(255),
	description varchar(255),
	feature varchar(255),
	hour varchar(255),
	mono varchar(255),
	qty int,
	svap varchar(255)
)
go

create table m_line_manpower_exemption_det
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	mfg_loc varchar(20),
	line_code varchar(255),
	time_from datetime2,
	time_to datetime2,
	line_manpower_exemption_id bigint
)
go

create table BO_Events
(
	MONo varchar(50) not null,
	BONo varchar(50) not null,
	Rec_Id varchar(50) constraint DF_BOEvents_Rec_Id default newid() not null,
	Event_Seq int,
	Key_Event varchar(50),
	Req_Start datetime,
	Req_End datetime,
	Plan_Start datetime,
	Plan_End datetime,
	PO_Start datetime,
	PO_End datetime,
	Actual_Start datetime,
	Actual_End datetime,
	Req_Duration int,
	Plan_Duration int,
	Actual_Duration int,
	Responsible varchar(50),
	VAP varchar(50),
	Remarks nvarchar(100),
	Predecessor varchar(50),
	Successor varchar(50),
	Deleted bit,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_BOEvents_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Lead_Lag int,
	Mfg_Loc varchar(50) not null,
	constraint PK_BO_Events
		primary key (MONo, BONo, Rec_Id, Mfg_Loc)
)
go

create table m_line_lc_v2
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	learn_curve float,
	mfg_loc varchar(255),
	period int,
	efficiency float,
	line_code varchar(255)
)
go

create table Events
(
	EventSeq int not null
		constraint PK_Events
			primary key,
	KeyEvent varchar(50) not null,
	ReqStart datetime,
	ReqEnd datetime,
	PlanStart datetime,
	PlanEnd datetime,
	ActualStart datetime,
	ActualEnd datetime,
	ReqDuration int,
	PlanDuration int,
	ActualDuration int,
	Responsible varchar(50),
	VAP varchar(50),
	Remarks nvarchar(100),
	Predecessor int,
	Successor int,
	Deleted bit,
	CreatedDt datetime constraint DF_Events_CreatedDt default getdate() not null,
	CreatedBy varchar(50),
	UpdatedDt datetime,
	UpdatedBy varchar(50),
	LeadLag int,
	PassType varchar(20),
	CodeDur varchar(50),
	Head int,
	Tail int,
	LevelNo int,
	TopSort int,
	OutputSrc varchar(100),
	SeqNo int,
	Active bit
)
go

create table Calendar_Week_Day_Det
(
	SBU_Id int not null,
	Calendar varchar(20) not null,
	Week_Name varchar(20) not null,
	Week_Day varchar(20) not null,
	GUID uniqueidentifier constraint DF_CalendarWeekDayDet_GUID default newid() not null,
	Time_From datetime not null,
	Time_To datetime not null,
	Time_Created datetime constraint DF_CalendarWeekDayDet_CreatedDt default getdate() not null,
	Created_By nvarchar(50) not null,
	Time_Updated datetime,
	Updated_By nvarchar(50),
	constraint PK_CalendarWeekDayDet
		primary key (SBU_Id, Calendar, Week_Name, Week_Day, GUID)
)
go

create table view_wip_workers_output_pivot
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	assembly varchar(255),
	code varchar(255),
	cut_cons varchar(255),
	cutting varchar(255),
	description varchar(255),
	feature varchar(255),
	final_cut varchar(255),
	gluing varchar(255),
	inking2 varchar(255),
	mono varchar(255),
	skiving varchar(255)
)
go

create table m_loading_bay
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_34uscmgulpb3fas69d7nledwd
			unique,
	description varchar(255)
)
go

create table fg_loading_plan_container
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code nvarchar(255),
	container_no nvarchar(255),
	description nvarchar(255),
	seal_no nvarchar(255),
	container_type_id bigint,
	loading_plan_id bigint not null,
	plate_no nvarchar(50),
	loading_bay_id bigint
		constraint FK9dmlqewb50tyg21c9nxpbuir8
			references m_loading_bay,
	ship_mode_id bigint
		constraint FK9u3y2h54s8y9ww7oh7k7vnmqv
			references m_ship_mode,
	status nvarchar(20)
)
go

create table view_wip_workers_output_summary
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	btno varchar(255),
	bundle_no int,
	chinese_name varchar(255),
	code varchar(255),
	color varchar(255),
	description varchar(255),
	feature varchar(255),
	feature_desc varchar(255),
	for_issuance_qty varchar(255),
	material varchar(255),
	mold_number varchar(255),
	mono varchar(255),
	next_svap varchar(255),
	next_svap_issued_qty varchar(255),
	next_svap_ist varchar(255),
	next_vap varchar(255),
	next_vap_ist varchar(255),
	operation varchar(255),
	output_qty int,
	received_qty int,
	seq int not null,
	smv float not null,
	status varchar(255),
	style varchar(255),
	svap varchar(255),
	vap varchar(255),
	work_section varchar(255)
)
go

create table wip_ads
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	building varchar(255),
	code varchar(255),
	description varchar(255),
	duration int,
	effective_date datetime2,
	expiration_date datetime2,
	file_name varchar(255),
	file_type varchar(255),
	interval int,
	is_active bit,
	last_updated_by varchar(255),
	last_updated_date datetime2,
	seq int
)
go

create table image_files
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	path varchar(255),
	table_id bigint
		constraint FK4bflasfyqsscwdrk46pao8lqh
			references fg_loading_plan_container,
	table_name varchar(255)
)
go

create table MO_Mat_ETA
(
	id bigint identity,
	sbu_id bigint not null,
	MONo varchar(50) not null,
	Latest_ETA datetime,
	Mat_Typ varchar(50) not null,
	Mat_No varchar(100),
	Mat_Desc nvarchar(1000),
	orig datetime,
	constraint PK_MO_Mat_ETA
		primary key (MONo, Mat_Typ)
)
go

create table wip_building_target
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	budget_headcount int,
	building varchar(255),
	code varchar(255),
	description varchar(255),
	month varchar(255),
	target_pcs int,
	target_sah float,
	working_days int,
	working_hours float,
	year varchar(255)
)
go

create table bo_hdr_hist
(
	MONo varchar(20) not null,
	BONo varchar(20) not null,
	Mfg_Loc varchar(20) not null,
	Line varchar(20) not null,
	Plan_Qty int not null,
	SMV decimal(18,5),
	Eff decimal(5,2),
	EATM int,
	Plan_Start datetime not null,
	Plan_Finish datetime not null,
	Actual_Start datetime,
	Actual_Finish datetime,
	Plant_Color varchar(50),
	Prd_Typ varchar(50),
	Prd_Typ2 varchar(50),
	Dif varchar(50),
	Plant varchar(20),
	MO_Qty int not null,
	MO_Cus_Del_Dt datetime not null,
	Completed bit,
	Created_By nvarchar(50) not null,
	Time_Created datetime not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Completed_Remarks nvarchar(4000),
	Trans_Id varchar(50),
	Trans_Dt datetime,
	Process varchar(50),
	Prod_Month datetime,
	CP_No varchar(20),
	id int identity
		constraint bo_hdr_hist_id_pk
			primary key,
	active bit,
	sbu_id int,
	code varchar(12),
	description varchar(100),
	total_planned_qty int,
	total_output_qty int
)
go

create table qconn_device
(
	id int identity
		primary key,
	uuid varchar(50) not null,
	ip varchar(15),
	mac varchar(20),
	platform varchar(50) not null,
	status varchar(20) not null,
	created_by nvarchar(50) not null,
	time_created datetimeoffset,
	updated_by nvarchar(50),
	time_updated datetimeoffset,
	locked bit,
	alias varchar(50),
	version varchar(30)
)
go

create table wip_capacity_maintenance
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	average_smv float,
	code varchar(255),
	date_from date,
	date_to date,
	description varchar(255),
	efficiency float,
	lines int,
	mf_work_days int,
	mf_work_hours float,
	month varchar(255),
	sat_work_days int,
	sat_work_hours float,
	sewer_count int,
	sewing_capacity_pcs int,
	sewing_capacity_sah int,
	sun_work_days int,
	sun_work_hours float,
	week int,
	year int
)
go

create table bo_daily_target_hist
(
	MONo varchar(20) not null,
	BONo varchar(20) not null,
	Line varchar(20) not null,
	Date datetime not null,
	Qty int not null,
	Created_By nvarchar(50) not null,
	Time_Created datetime not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Trans_Id varchar(50),
	Trans_Dt datetime,
	Mfg_Loc varchar(20) not null,
	id int identity,
	active bit,
	sbu_id int,
	code varchar(12),
	description varchar(100),
	Mfg_Loc_id int,
	mo_id bigint,
	plan_start datetime,
	plan_finish datetime,
	seq int,
	smv numeric(12,4),
	original_daily_target int,
	actual_output_qty int
)
go

create table change_password_logs
(
	id int identity
		constraint change_password_logs_pk
			primary key nonclustered,
	username varchar(30),
	session varchar(200),
	ip_address varchar(50),
	email_address varchar(100),
	is_used bit default 0,
	hash varchar(200),
	active bit default 0,
	created_by varchar(50),
	time_created datetime,
	updated_by varchar(50),
	time_updated datetime,
	sbu_id int,
	code varchar(20),
	description varchar(50)
)
go

create table qconn_device_history
(
	id int identity
		primary key,
	ip varchar(15),
	line_id varchar(10),
	device_id bigint not null,
	login_time datetimeoffset,
	created_by nvarchar(50) not null,
	time_created datetimeoffset,
	updated_by nvarchar(50),
	time_updated datetimeoffset
)
go

create table qconn_planning_mono_list
(
	id bigint identity
		constraint qconn_planning_mono_list_id_pk
			primary key nonclustered,
	mono varchar(30),
	date_created datetime default getdate(),
	date_processed datetime,
	date_done datetime,
	rem varchar(50),
	time_updated datetime,
	status varchar(10) default 'NEW',
	username varchar(50)
)
go

create table wip_email_alerts
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	body varchar(255),
	code varchar(255),
	description varchar(255),
	is_sent bit,
	recipient varchar(255),
	redirect_url varchar(255),
	schedule_date datetime2,
	subject varchar(255)
)
go

create table m_work_sections
(
	id bigint identity
		constraint m_work_sections_id_pk
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	vap varchar(20),
	building_id int,
	code varchar(255),
	company varchar(20),
	description varchar(255),
	svap varchar(20),
	target_eff float,
	work_breaktimes_id bigint
		constraint FKc1mq11gon72hfeiflt9e8h1nu
			references m_work_breaktimes,
	desc1 varchar(255)
)
go

create table qconn_global_setting
(
	id bigint identity
		primary key,
	code varchar(50) not null,
	value varchar(100),
	created_by varchar(50),
	time_created datetimeoffset,
	updated_by varchar(50),
	time_updated datetimeoffset,
	description nvarchar(100)
)
go

create table m_Prod_Lines
(
	Prod_Line varchar(10) not null
		constraint PK_m_Prod_Lines
			primary key,
	Desc1 nvarchar(100) not null,
	Desc2 nvarchar(100),
	Active bit constraint DF_m_Prod_Lines_Active default 1,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_ProdLines_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Mfg_Loc varchar(20),
	Calendar varchar(20),
	Process varchar(20),
	Learn_Curve varchar(20),
	Day_Gap int,
	Efficiency numeric(4,2),
	Prod_Grp varchar(20),
	Lean bit constraint DF_m_Prod_Lines_Lean_1 default 0 not null,
	Fty_Loc varchar(20)
)
go

create table wip_scan
(
	id bigint identity,
	active bit constraint DF_wip_scan_active default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	authorized_by varchar(50),
	code varchar(25),
	description varchar(255),
	frm_prod_line varchar(10),
	frm_shift varchar(15),
	layno varchar(20),
	load_type varchar(1),
	mono varchar(20),
	ptno varchar(13),
	qc_seq int,
	qty int,
	scan_dt datetime2,
	seq int,
	shift varchar(1),
	svap varchar(20),
	vap varchar(20),
	work_section varchar(255),
	imapps_id bigint,
	mo_id bigint,
	bundle_no int,
	pt_id bigint,
	work_section_id int,
	output_id bigint,
	issued_id bigint,
	received_id bigint,
	next_check_point varchar(10),
	origin varchar(10)
)
go

create table wip_fg_template
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	carton_from int,
	carton_to int,
	code varchar(255),
	color varchar(255),
	cono varchar(255),
	cust_style varchar(255),
	description varchar(255),
	mono varchar(255),
	pono varchar(255),
	style varchar(255)
)
go

create table workers_output_det
(
	id bigint identity
		constraint workers_output_det_id_pk
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	bundle_no int,
	code varchar(255),
	deleted bit,
	description varchar(255),
	mono varchar(20),
	operation varchar(20),
	output_dt datetime2,
	qty int,
	remarks varchar(100),
	scan_mode varchar(1),
	scan_type varchar(2),
	seq int,
	smv bit,
	split bit,
	svap varchar(20),
	vap varchar(20),
	work_section varchar(255),
	worker_id varchar(10)
)
go

create table qconn_inline_defect_category
(
	code varchar(10) not null
		constraint PK_qconn_inline_defect_category
			primary key,
	desc1 nvarchar(100) not null,
	desc2 nvarchar(100),
	deleted bit not null,
	CreatedBy nvarchar(50),
	CreatedDt datetime,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime
)
go

create table bo_hdr_tmp
(
	MONo varchar(20) not null,
	BONo int not null,
	Mfg_Loc varchar(20) not null,
	Line varchar(20) not null,
	Plan_Qty int not null,
	SMV decimal(18,5),
	Eff decimal(5,2),
	EATM int,
	Plan_Start datetime not null,
	Plan_Finish datetime not null,
	Actual_Start datetime,
	Actual_Finish datetime,
	Plant_Color varchar(50),
	Prd_Typ varchar(50),
	Prd_Typ2 varchar(50),
	Dif varchar(50),
	Plant varchar(20),
	MO_Qty int not null,
	MO_Cus_Del_Dt datetime not null,
	Completed bit,
	Created_By nvarchar(50) not null,
	Time_Created datetime not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Completed_Remarks nvarchar(4000),
	Trans_Id varchar(50),
	Trans_Dt datetime,
	Process varchar(50),
	Prod_Month datetime,
	CP_No varchar(20),
	id int identity,
	active bit,
	sbu_id int,
	code varchar(12),
	description varchar(100),
	total_planned_qty int
)
go

create table wip_files
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	data varbinary(max),
	date_uploaded datetime2,
	description varchar(255),
	file_name varchar(255),
	file_type varchar(255),
	uuid varchar(255)
)
go

create table EPF_Worker_Op
(
	Eff_Dt datetime not null,
	Work_Section varchar(10) not null,
	MONo varchar(20) not null,
	Worker_Id varchar(10) not null,
	Operation varchar(50) not null,
	Last_Op bit not null,
	smv numeric(10,4),
	Qty numeric(8),
	Efficiency numeric(8,2) not null,
	Escalation bit,
	Prod_Min numeric(18,5),
	Duration numeric(18,5),
	Basic_Rate numeric(18,5),
	QR_Rate numeric(15,10),
	QR_Eff numeric(8,2),
	Factor numeric(8,5),
	QR_Earn numeric(10,2),
	Processed_By nvarchar(50) not null,
	Processed_Dt datetime not null,
	Posted_By nvarchar(50),
	Posted_Dt datetime,
	constraint PK_EPF_Worker_Op
		primary key (Eff_Dt, Work_Section, MONo, Worker_Id, Operation)
)
go

create table qconn_inline_defect_type
(
	category varchar(10),
	code varchar(10) not null
		constraint qconn_inline_defect_type_pk
			primary key nonclustered,
	desc1 nvarchar(100) not null,
	desc2 nvarchar(100),
	level varchar(50),
	qc_severity varchar(10),
	deleted bit not null,
	CreatedBy nvarchar(50),
	CreatedDt datetime,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime
)
go

create table mo_vap_svap
(
	mo_id bigint
		constraint FKiirunmnjg604312gx4k1igbww
			references mo_hdr,
	svap varchar(255),
	next_check_point varchar(12),
	vap varchar(268),
	seq numeric(12,2),
	id bigint identity,
	seq2 numeric(12,2),
	mono varchar(20),
	gvap varchar(20),
	load_off bit,
	load_on bit,
	active bit constraint DF_mo_vap_svap_active default 1,
	created_by varchar(50),
	time_created datetime,
	updated_by varchar(50),
	time_updated datetime,
	sbu_id int constraint DF_mo_vap_svap_sbu_id default 1,
	code varchar(20),
	description varchar(20),
	reqd bit
)
go

create table m_workshop
(
	id bigint identity
		constraint m_workshop_id_pk
			primary key nonclustered,
	created_by varchar(50),
	time_created datetime default getdate(),
	updated_by varchar(50),
	time_updated datetime,
	active bit default 1,
	sbu_id bigint not null,
	code varchar(30),
	description nvarchar(128),
	alt_description nvarchar(128),
	building_id bigint,
	floor_no int,
	status varchar(30)
)
go

create index m_workshop_active_index
	on m_workshop (active)
go

create index m_workshop_sbu_id_index
	on m_workshop (sbu_id)
go

create unique index m_workshop_sbu_id_code_uindex
	on m_workshop (sbu_id, code)
go

create index m_workshop_building_id_index
	on m_workshop (building_id)
go

create table wip_headcount_hdr
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	absentx int,
	assy_supervisor varchar(255),
	avg_smv float,
	budget_minutes int,
	building varchar(255),
	code varchar(255),
	datex datetime2,
	description varchar(255),
	hc_hours_breakdown varchar(255),
	process_group_code varchar(255),
	last_updated_by varchar(255),
	last_updated_date varchar(255),
	line varchar(255),
	line_target int,
	mo_no varchar(255),
	ot_hours float,
	plant varchar(255),
	present int,
	present_percentage float,
	qc_leader varchar(255),
	remarks varchar(255),
	smv float,
	style varchar(255),
	target_pcs int,
	target_set int,
	total int,
	total_reg_working_hours float,
	total_working_hours float,
	transferred int,
	workers_with_ot int,
	working_hr float
)
go

create table wip_headcount_skill
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	wip_headcount_skill_code varchar(255),
	wip_headcount_skill_total int,
	wip_headcount_hdr_id bigint
		constraint FKa26el3pqvm381byobd7ffaqmk
			references wip_headcount_hdr
)
go

create table m_tmp_process_sort
(
	process varchar(20),
	sort_no int
)
go

create table EndLineCards
(
	ProdLine varchar(10) not null,
	Shift varchar(1) not null,
	RFID varchar(20) not null
		constraint PK_EndLineCards
			primary key,
	CardSeq int not null,
	Color varchar(50) not null,
	DefectType varchar(50) not null,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime
)
go

create table wip_headcount_workers
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	datex varchar(255),
	deleted_by varchar(255),
	deleted_date varchar(255),
	description varchar(255),
	display_name varchar(255),
	emp_no varchar(255),
	line varchar(255),
	skills varchar(255),
	time_in varchar(255),
	time_out varchar(255),
	validated_by varchar(255),
	validated_date varchar(255)
)
go

create table Config_Row_No
(
	RowNo int not null
		constraint PK_Config_Row_No
			primary key
)
go

create table app_application
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alt_description varchar(255),
	code varchar(32)
		constraint UK_4qu28xcfjkcueduh0yo34a1ou
			unique,
	description varchar(128)
)
go

create table app_role_module_access
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	can_create bit,
	can_search bit,
	can_update bit,
	can_delete bit,
	code varchar(255),
	description varchar(255),
	application_id bigint
		constraint FKgrjajkplt398mqg0r2kgh50wj
			references app_application,
	module_id bigint
		constraint FKp9pwrhlsmyebqa5naxilyswnj
			references fg_references,
	user_role_id bigint
)
go

create table qconn_mo_type
(
	mono varchar(20) not null
		constraint qconn_mo_type_pk
			primary key nonclustered,
	multi bit default 0
)
go

create table EndLineCardsHistory
(
	id bigint identity
		primary key,
	ProdLine varchar(10) not null,
	Shift varchar(1) not null,
	RFID varchar(20) not null,
	CardSeq int not null,
	Color varchar(50) not null,
	DefectType varchar(50) not null,
	CreatedBy nvarchar(50),
	CreatedDt datetime not null
)
go

create table wip_holidays
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	date_from date,
	date_to date,
	description varchar(255),
	holiday_name varchar(255),
	sbu varchar(255),
	total_days int
)
go

create table m_Key_Warn_Indicator
(
	sbu_id int default 1,
	GUID uniqueidentifier constraint DF_m_Key_Warn_Indicator_GUID default newid() not null
		constraint PK_Key_Warn_Indicator
			primary key,
	Key_Cd varchar(20) not null,
	Seq numeric(18),
	Description nvarchar(100),
	Board_Color varchar(50) not null,
	Day_Gap int,
	Created_By nvarchar(100),
	Time_Created datetime,
	Updated_By nvarchar(100),
	Time_Updated datetime
)
go

create table app_config
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	app_name datetime2,
	code varchar(255)
		constraint UK_tcwnw6wi99kea0rjurofw605t
			unique,
	description varchar(255),
	last_run_dt date,
	mfg_loc varchar(255),
	prev_run_dt date,
	release_date date,
	server_name varchar(255)
)
go

create table m_gvap
(
	id bigint identity
		constraint PK__m_gvap__3213E83FF5610959
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alt_description varchar(255),
	code varchar(32)
		constraint UK_ptse6v6t1bh0f612vljoop8l0
			unique,
	description varchar(255),
	duration float,
	load_on bit,
	load_off bit,
	plan bit constraint DF_m_gvap_plan_1 default 0
)
go

create table m_svap
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alt_description varchar(255),
	code varchar(32),
	comp_bundle bit not null,
	description varchar(255),
	for_do bit not null,
	load_off bit not null,
	load_on bit not null,
	ws_req bit not null,
	gvap_id bigint
		constraint FKaxx32omkyfxqptk0mvhlms0xu
			references m_gvap,
	vap_id bigint
		constraint FKt7hh3sk1k99q4u5awpciw4wu5
			references m_vap,
	gvap varchar(20),
	vap varchar(20),
	svap_code varchar(10)
)
go

create table mo_gvap
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	duration float,
	load_off bit not null,
	load_on bit not null,
	seq int,
	gvap_id bigint not null
		constraint FKs4t0va3p9n9paud3t6b2y17ph
			references m_gvap,
	mo_id bigint not null
		constraint FKl52yht09m626k1mhb60r9ie30
			references mo_hdr,
	svap_id bigint not null
		constraint FKityopd3tcbmedvlx1nbn9fpf3
			references m_svap,
	svap_id1 bigint not null
		constraint FKsm34yac00l1ojfmw2on86m7r0
			references m_svap,
	vap_id bigint not null
		constraint FKsqei63t4etrrqcktf2tj5arjy
			references m_vap,
	vap_id1 bigint not null
		constraint FKry9jxp1x0e4n7b6rhuk7yv0p6
			references m_vap,
	mono varchar(20)
)
go

create table wip_language
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	bd varchar(255),
	cn varchar(255),
	code varchar(255),
	description varchar(255),
	en varchar(255),
	fp varchar(255),
	kh varchar(255),
	last_updated_by varchar(255),
	last_updated_date varchar(255),
	my varchar(255),
	th varchar(255),
	vn varchar(255)
)
go

create table app_mailer
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	body varchar(255),
	code varchar(255),
	description varchar(255),
	email varchar(255),
	reciptien varchar(255),
	status varchar(255),
	subject varchar(255),
	time_status datetime2
)
go

create table qconn_tag
(
	id int identity
		primary key,
	code varchar(20) not null,
	type varchar(20) not null,
	color varchar(10) not null,
	vap varchar(20),
	line varchar(10),
	status varchar(20) not null,
	created_by nvarchar(50) not null,
	time_created datetimeoffset,
	updated_by nvarchar(50),
	time_updated datetimeoffset,
	printed bit default 0,
	unrepairable bit default 0
)
go

create table wip_loading_plan
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	buyer_code varchar(255),
	code varchar(255),
	color varchar(255),
	description varchar(255),
	fty_style_no varchar(255),
	mo_no varchar(255),
	order_number varchar(255),
	plan_no varchar(255),
	po_unit_price float,
	po_value_usd float,
	port_of_loading varchar(255),
	status varchar(255),
	style varchar(255),
	vendor varchar(255)
)
go

create table app_sbu
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alt_description varchar(255),
	code varchar(5)
		constraint UK_ohvorclbxp7il05irf0lve3ip
			unique,
	description varchar(100)
)
go

create table Prod_Lines_CU
(
	sbu_id int default 1,
	Mfg_Loc varchar(20) not null,
	Prod_Line varchar(20) not null,
	Trans_Dt datetime,
	Processed_By nvarchar(50),
	Processed_Dt datetime
)
go

create table wip_material_receiving
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	checked_by varchar(255),
	code varchar(255),
	color varchar(255),
	receiving_dept varchar(255),
	description varchar(255),
	issued_by varchar(255),
	material_no varchar(255),
	mono varchar(255),
	qty int not null,
	received_by varchar(255),
	remarks varchar(255),
	style_no varchar(255),
	tran_date datetime2,
	tranno varchar(255),
	uom varchar(255)
)
go

create table app_sec_group
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(32)
		constraint UK_fhhvyp4urc70yr4k6s44eis45
			unique,
	description varchar(128)
)
go

create table qconn_user
(
	id bigint identity
		constraint PK_qconn_users
			primary key,
	username varchar(50) not null,
	password nvarchar(100),
	first_name varchar(50) not null,
	last_name varchar(50) not null,
	email varchar(100) not null,
	role varchar(20) constraint qconn_user_role_default default 'ROLE_USER' not null,
	status varchar(20),
	account_enabled bit constraint qconn_user_account_enabled_default default 1,
	last_password_reset_date datetime default getdate(),
	created_by varchar(50),
	time_created datetimeoffset,
	updated_by varchar(50),
	time_updated datetimeoffset,
	department varchar(100),
	position varchar(100),
	avatar varchar(200),
	module varchar(100),
	reports varchar(200),
	learning_progress varchar(2000)
)
go

create table Prod_Lines_LC
(
	sbu_id int default 1 not null,
	Mfg_Loc varchar(20) not null,
	Prod_Line varchar(20) not null,
	Learn_Curve numeric(18,5) not null,
	Description nvarchar(256) not null,
	Interval int,
	Period_01 numeric(18,4),
	Period_02 numeric(18,4),
	Period_03 numeric(18,4),
	Period_04 numeric(18,4),
	Period_05 numeric(18,4),
	Period_06 numeric(18,4),
	Period_07 numeric(18,4),
	Period_08 numeric(18,4),
	Period_09 numeric(18,4),
	Period_10 numeric(18,4),
	Period_11 numeric(18,4),
	Period_12 numeric(18,4),
	Period_13 numeric(18,4),
	Period_14 numeric(18,4),
	Period_15 numeric(18,4),
	Period_16 numeric(18,4),
	Period_17 numeric(18,4),
	Period_18 numeric(18,4),
	Period_19 numeric(18,4),
	Period_20 numeric(18,4),
	Period_21 numeric(18,4),
	Period_22 numeric(18,4),
	Period_23 numeric(18,4),
	Period_24 numeric(18,4),
	Period_25 numeric(18,4),
	Period_26 numeric(18,4),
	Period_27 numeric(18,4),
	Period_28 numeric(18,4),
	Period_29 numeric(18,4),
	Period_30 numeric(18,4),
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_ProdLinesLC_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	RecID varchar(50) constraint DF_Prod_Lines_LC_RecID default newid(),
	constraint PK_Prod_Lines_LC
		primary key (sbu_id, Mfg_Loc, Prod_Line, Learn_Curve, Description)
)
go

create table wip_mo_checkpoint_status
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	completed_by varchar(255),
	completed_date datetime2,
	description varchar(255),
	mono varchar(255),
	process varchar(255),
	started_by varchar(255),
	started_date datetime2,
	status varchar(255)
)
go

create table app_sec_module_keys
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	action varchar(255),
	alt_description varchar(255),
	api_uri varchar(255),
	base_path varchar(255),
	code varchar(255),
	description varchar(255),
	groups varchar(255),
	head int not null,
	head_groups varchar(255),
	method varchar(255),
	path varchar(255)
)
go

create table fg_container_type
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_bwrfwqes4lhxo1uj5ntxek3vy
			unique,
	description varchar(255),
	dimension_uom varchar(255),
	height varchar(255),
	length varchar(255),
	volume varchar(255),
	volume_uom varchar(255),
	width varchar(255)
)
go

create table fg_container
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	container_no varchar(255),
	description varchar(255),
	seal_no varchar(255),
	container_type_id bigint not null
		constraint FKjfc1k0034lpir2eju4xqng79r
			references fg_container_type
)
go

create table WIP_Sub_Con
(
	Output_Dt date not null,
	MONo varchar(20) not null,
	GVAP varchar(20) not null,
	Color varchar(20) not null,
	Size varchar(20) not null,
	Qty numeric(8) constraint DF_WIP_Sub_Con_Qty default 0 not null,
	Time_Created datetime constraint DF_WIP_Sub_Con_Time_Created default getdate() not null,
	Created_By nvarchar(50) not null,
	Time_Updated datetime,
	Updated_By nvarchar(50),
	Prod_Line varchar(50),
	constraint PK_WIP_Sub_Con_1
		primary key (Output_Dt, MONo, GVAP, Color, Size, Time_Created)
)
go

create table wip_mo_status
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	cono varchar(255),
	container_no varchar(255),
	description varchar(255),
	ex_factory_dt date,
	mono varchar(255),
	pono varchar(255),
	qty int,
	ship_mode varchar(255),
	ship_to_name varchar(255),
	ship_to varchar(255),
	shipment_status varchar(255),
	shipped bit,
	shipped_qty int,
	vessel_dt date
)
go

create table app_sync_log
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	time_finish datetime2,
	time_start datetime2
)
go

create table sec_group
(
	id bigint identity
		constraint sec_group_id_pk
			primary key nonclustered,
	created_by varchar(50),
	time_created datetime default getdate(),
	updated_by varchar(50),
	time_updated datetime,
	active bit default 1,
	sbu_id bigint not null,
	code varchar(30),
	description nvarchar(128),
	alt_description nvarchar(128)
)
go

create index sec_group_active_index
	on sec_group (active)
go

create index sec_group_sbu_id_index
	on sec_group (sbu_id)
go

create unique index sec_group_code_uindex
	on sec_group (code)
go

create table fg_grade
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_3vq0k2hmqp65x7osik19obdf6
			unique,
	description varchar(255)
)
go

create table qconn_user_line
(
	user_id bigint not null,
	line_id varchar(10) not null,
	created_by varchar(50),
	updated_by varchar(50),
	time_created datetimeoffset,
	time_updated datetimeoffset,
	id bigint identity
		constraint qconn_user_line_id_pk
			primary key,
	vap_id varchar(10)
)
go

create table wip_notification
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	actual datetime2,
	alert_id numeric(19,2),
	alert_status varchar(255),
	alert_type varchar(255),
	bldg_code varchar(255),
	bundle_no int,
	code varchar(255),
	content varchar(255),
	description varchar(255),
	effective_date datetime2,
	interval_minutes int,
	line_work_section varchar(255),
	message_status varchar(255),
	mono varchar(255),
	remarks varchar(255),
	required datetime2,
	severity varchar(255),
	shop_floor varchar(255),
	style_no varchar(255),
	title varchar(255),
	url varchar(255)
)
go

create table app_user
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	email varchar(255),
	first_name varchar(50),
	last_name varchar(50),
	last_password_reset_date datetime2,
	password varchar(255),
	role varchar(255),
	status varchar(255),
	department nvarchar(100),
	position nvarchar(100),
	warehouse_id int
)
go

create table app_user_roles
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	application_id bigint,
	role_id bigint
		constraint app_user_roles_fg_references_id_fk
			references fg_references,
	user_id bigint
		constraint FK3lwiahkol5aetc57pto5olacf
			references app_user
)
go

create table app_user_vap_svap
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	svap varchar(20),
	vap varchar(20),
	user_id bigint not null
		constraint FK7pnvrygruf7p4d4suqfl5gk8p
			references app_user
)
go

create unique index app_user_code_uindex
	on app_user (code)
go

create table fg_loading_plan
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	cartons_for_loading int,
	code varchar(255),
	description varchar(255),
	loaded_cartons int,
	loading_plan_date date,
	loading_plan_no varchar(255),
	loading_status varchar(255),
	loading_status_date datetime2,
	picked_cartons int,
	remarks varchar(255),
	target_loading_date date
)
go

create table Prod_Lines_MP
(
	sbu_id int default 1 not null,
	Mfg_Loc varchar(20) not null,
	Prod_Line varchar(20) not null,
	Effect_Dt datetime not null,
	ManPower decimal(18) not null,
	Active bit constraint DF_ProdLinesMP_Deleted default 1,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_ProdLinesMP_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	GUID uniqueidentifier constraint DF_Prod_Lines_MP_GUID default newid() not null,
	constraint PK_Prod_Lines_MP
		primary key (sbu_id, Mfg_Loc, Prod_Line, GUID)
)
go

create table WIP_Output
(
	Output_Dt date not null,
	CONo varchar(20) not null,
	Prod_Line varchar(50) not null,
	Qty numeric(8) constraint DF_WIP_Output_Qty default 0 not null,
	Time_Created datetime constraint DF_WIP_Output_Time_Created default getdate() not null,
	Created_By nvarchar(50) not null,
	Time_Updated datetime,
	Updated_By nvarchar(50),
	Remarks nvarchar(100),
	constraint PK_WIP_Output
		primary key (Output_Dt, CONo, Prod_Line)
)
go

create table Daily_Target_Matrix
(
	Rec_Id varchar(50) constraint DF_DailyTargetMatrix_RecId default newid() not null
		constraint PK_DailyTargetMatrix
			primary key,
	Min_Ord_Qty int not null,
	Manpower int not null,
	Wrk_Min numeric(18,5) not null,
	Eff numeric(5,2) not null,
	Time_Created datetime constraint DF_DailyTargetMatrix_CreatedDt default getdate() not null,
	Created_By varchar(50) not null,
	Time_Updated datetime,
	Updated_By datetime,
	Mfg_Loc varchar(50),
	Min_SMV numeric(18,5) constraint DF_DailyTargetMatrix_MinSMV default 0
)
go

create table qconn_worker
(
	id bigint identity
		primary key,
	empno varchar(20)
		constraint UK_1e2xl8tj3e319yekfm24kejy1
			unique,
	last_name nvarchar(100),
	first_name nvarchar(100),
	display_name nvarchar(max),
	position nvarchar(max),
	rfid varchar(10),
	inactive bit,
	middle_name varchar(100),
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255)
)
go

create table wip_npt_library
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	color varchar(255),
	deleted bit,
	desc1 nvarchar(255),
	desc2 nvarchar(255),
	desc_local nvarchar(255),
	description varchar(255),
	is_majornpt bit,
	npt_category varchar(255),
	npt_type varchar(255)
)
go

create table app_user_application
(
	user_id bigint not null
		constraint FKaksl9d91nowpoqecp4qcpqk4f
			references app_user,
	app_id bigint not null
		constraint FKtesjm4v0p1836c5qqopfpkwpx
			references app_application,
	primary key (user_id, app_id)
)
go

create table sec_module_key
(
	id bigint identity
		constraint sec_module_key_id_pk
			primary key nonclustered,
	created_by varchar(50),
	time_created datetime default getdate(),
	updated_by varchar(50),
	time_updated datetime,
	active bit default 1,
	sbu_id bigint not null,
	code varchar(30),
	description nvarchar(128),
	alt_description nvarchar(128),
	action varchar(30),
	method varchar(30),
	base_path varchar(512),
	path varchar(512),
	api_uri varchar(512),
	groups varchar(max)
)
go

create index sec_module_key_active_index
	on sec_module_key (active)
go

create index sec_module_key_sbu_id_index
	on sec_module_key (sbu_id)
go

create unique index sec_module_key_code_uindex
	on sec_module_key (code)
go

create table wip_npt_records
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	created_date datetime2,
	date_from datetime2,
	date_to datetime2,
	description varchar(255),
	duration_minute int,
	employee_count int,
	employee_types varchar(255),
	is_pending bit,
	mono varchar(255),
	npt_type varchar(255),
	post_encoding bit,
	remarks varchar(255),
	work_section varchar(255)
)
go

create table app_user_sbu
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	description varchar(255),
	role varchar(255),
	sbu_access_id bigint not null
		constraint FKoh3moxul0stew7vfrs7w8utlr
			references app_sbu,
	user_id bigint not null
		constraint FKdeijdy2rrncc1d3t4jc3rrrlv
			references app_user
)
go

create table Prod_Line_Output
(
	Output_Dt date not null,
	MONo varchar(20) not null,
	Prod_Line varchar(50) not null,
	Qty numeric(8) constraint DF_Prod_Line_Output_Qty default 0 not null,
	Time_Created datetime constraint DF_Prod_Line_Output_Time_Created default getdate() not null,
	Created_By nvarchar(50) not null,
	Time_Updated datetime,
	Updated_By nvarchar(50),
	Remarks nvarchar(100),
	constraint PK_Prod_Line_Output
		primary key (Output_Dt, MONo, Prod_Line)
)
go

create table wip_npt_section_breaks
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	break_end varchar(255),
	break_start varchar(255),
	code varchar(255),
	description varchar(255),
	effective_date varchar(255),
	section_code varchar(255)
)
go

create table app_user_setting
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(32)
		constraint UK_e5usl03pbloxacsuhm8onhnto
			unique,
	name varchar(255),
	user_id bigint
		constraint FK9mpng4momghey9l8rcijt8h3x
			references app_user
)
go

create table fg_purchase_order
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	asn_no varchar(255),
	booking_no varchar(255),
	buyer varchar(100),
	code varchar(255),
	color_desc_cn varchar(100),
	color_desc_en varchar(100),
	colors varchar(255),
	customer_order_no varchar(255),
	delivery_seq varchar(3),
	description varchar(255),
	downloaded_date datetime2,
	ex_fty_date date,
	factory varchar(255),
	downloaded bit,
	has_draft bit,
	invoice_no varchar(255),
	iono varchar(255),
	order_qty int,
	pono varchar(255),
	rev_ex_fty_date date,
	revised_style_code varchar(50),
	ship_date date,
	ship_mode varchar(20),
	ship_to varchar(255),
	ship_to_remarks varchar(20),
	sizes varchar(255),
	store_code varchar(255),
	style_code varchar(50),
	vendor varchar(255)
)
go

create table m_No_Range
(
	NoRange varchar(50) not null
		constraint PK_NoRange
			primary key,
	Desc1 nvarchar(100) not null,
	NoRangeGrp varchar(10) not null,
	NoRangeFrom varchar(18) not null,
	NoRangeTo varchar(18) not null,
	CurrentNo varchar(18) not null,
	HasKey bit constraint DF_NoRange_HasKey default 0 not null,
	KeyNoRange varchar(10),
	IsExternal bit constraint DF_NoRange_IsExternal default 0 not null,
	Active bit constraint DF_NoRange_Active default 0 not null,
	Time_Created datetime constraint DF_NoRange_Time_Created default getdate() not null,
	Created_By nvarchar(50) not null,
	Time_Updated datetime,
	Updated_By nvarchar(50)
)
go

create table wip_npt_workers
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	emp_no varchar(255),
	wip_npt_records_id bigint
		constraint FKr15j14hrsykj3mpy590rqe44x
			references wip_npt_records
)
go

create table Prod_Lines_WM
(
	sbu_id int default 1 not null,
	Mfg_Loc varchar(20) not null,
	Prod_Line varchar(20) not null,
	Ex_Name varchar(50) not null,
	Long_Text nvarchar(256),
	Has_Work bit constraint DF_ProdLinesWM_HasWork default 1 not null,
	Date_From datetime not null,
	Date_To datetime not null,
	Time_Created datetime constraint DF_Prod_Lines_WM_CreatedDt default getdate() not null,
	Created_By nvarchar(50) not null,
	Time_Updated datetime,
	Updated_By nvarchar(50),
	Date_Year int not null,
	Excl_Holiday bit default 0,
	Excl_Sunday bit default 0,
	active bit default 1,
	code varchar(255),
	description varchar(255),
	id int identity
		constraint PK_prod_lines_wm
			primary key
)
go

create table fg_purchase_order_dtl
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	asn_date date,
	asn_no varchar(20),
	booking_no varchar(20),
	carrier_code varchar(20),
	code varchar(255),
	description varchar(255),
	eta date,
	etd date,
	factory_loc_code varchar(20),
	invoice_date date,
	invoice_no varchar(20),
	is_draft bit,
	ship_date date,
	shipment_code varchar(20),
	shipper_code varchar(20),
	split_no int,
	purchase_order_id bigint not null
		constraint FKimiiij4kfh0tgptrhee1ab897
			references fg_purchase_order
)
go

create table fg_loading_plan_pl
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	loading_plan_qty int,
	status varchar(255),
	loading_plan_id bigint not null
		constraint FKd0powxino1wruj5v2f69eqtuc
			references fg_loading_plan,
	purchase_order_dtl_id bigint not null
		constraint FKii736i4kdtjjg8bc4at4n6bwe
			references fg_purchase_order_dtl
)
go

create table wip_packing
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	authorized_by varchar(255),
	bin varchar(255),
	carton_no int,
	carton_qty int,
	code varchar(255),
	color varchar(255),
	cono varchar(255),
	deleted bit,
	delivery_no varchar(255),
	description varchar(255),
	issued_by varchar(255),
	issued_date_time datetime2,
	issued_from_line varchar(255),
	last_updated_by varchar(255),
	last_updated_date datetime2,
	mono varchar(255),
	overship_qty int,
	pono varchar(255),
	posted_qty int,
	qty_per_carton int,
	racks varchar(255),
	received_by varchar(255),
	received_date_time datetime2,
	received_date_time_2 datetime2,
	remarks varchar(255),
	style varchar(255),
	total_carton int,
	total_received_qty int,
	total_received_qty_2 int,
	transferred_by varchar(255),
	transferred_date datetime2,
	transferred_from_id int,
	ucc_barcode varchar(255),
	uerp_remarks varchar(255),
	warehouse varchar(255)
)
go

create table fg_qr_sticker
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_mwtgr19c2idno95gtdvayuart
			unique,
	content varchar(4000),
	description varchar(255),
	dimension varchar(10),
	height varchar(10),
	width varchar(10)
)
go

create table employee
(
	id int identity,
	emp_no varchar(255),
	emp_name varchar(255),
	position varchar(255)
)
go

create table wip_packing_list
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	asn_no varchar(255),
	carton_no int,
	code varchar(255),
	color varchar(255),
	container_load_date varchar(255),
	container_number varchar(255),
	buyer_code varchar(255),
	description varchar(255),
	document_number varchar(255),
	last_updated_by varchar(255),
	last_updated_date datetime2,
	order_qty int,
	packed_qty int,
	pono varchar(255),
	style varchar(255),
	ucc_barcode varchar(255),
	upc_no varchar(255)
)
go

create table Style_Analysis_Hdr
(
	Style varchar(20) not null
		constraint PK_StyleAnalysisHdr
			primary key,
	Desc1 nvarchar(256) not null,
	Desc2 nvarchar(256),
	Deleted bit constraint DF_StyleAnalysisHdr_Deleted default 0,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_StyleAnalysisHdr_CreatedDt default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	SMV numeric(18,5),
	Applied_By nvarchar(50),
	Time_Applied nvarchar(50),
	Remarks nvarchar(250)
)
go

create table position
(
	id int identity,
	code varchar(255),
	description varchar(255)
)
go

create table io_sync
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	aplq_type varchar(50),
	as400_io_no varchar(20),
	bill_to_cust varchar(100),
	code varchar(255),
	color varchar(100),
	color_desc varchar(100),
	color_tc_smv float,
	cono varchar(100),
	cust_color varchar(100),
	cust_del_dt date,
	cust_grp varchar(100),
	cust_po_dt date,
	cust_po_item int,
	cust_pono varchar(50),
	cust_style varchar(100),
	cust_style_desc varchar(100),
	cust_size varchar(100),
	delivery_dt date,
	description varchar(255),
	dest varchar(50),
	dye_type varchar(50),
	embro_qty int,
	embro_type varchar(50),
	ex_fty_dt date,
	fab_pattern varchar(10),
	fab_pattern_desc varchar(50),
	fty_del_dt date,
	ht_type varchar(50),
	io_desc varchar(100),
	io_ln varchar(50),
	iono varchar(50),
	lpd_dt date,
	merch_smv float,
	mfg_loc varchar(20),
	no_of_pcs int,
	order_status varchar(50),
	order_type varchar(50),
	plan_dt date,
	plant varchar(100),
	print_qty int,
	prnt_type varchar(50),
	prod_type varchar(20),
	prod_type_desc varchar(20),
	req_qty float,
	rs_dt date,
	sales_grp varchar(100),
	sales_ord_type varchar(50),
	season varchar(100),
	ship_mode varchar(100),
	ship_to_cust varchar(100),
	shipped_qty float,
	size varchar(100),
	so_remarks varchar(50),
	sold_to_cust varchar(100),
	src_erp varchar(10),
	style_no varchar(100),
	tc_smv float,
	uom varchar(100),
	vsl_dt date,
	wash_type varchar(50),
	webbing varchar(50),
	cust_style_id bigint,
	mfg_loc_id int,
	order_status_id bigint,
	order_type_id bigint,
	plant_id int,
	prod_type_id bigint,
	sales_grp_id bigint,
	season_id bigint,
	dest_id bigint,
	ship_to_cust_id bigint,
	ship_mode_id bigint
)
go

create index FGWarehouse_SQLOPS_io_sync_79_78
	on io_sync (order_type, id)
go

create index FGWarehouse_SQLOPS_io_sync_383_382
	on io_sync (style_no)
go

create index FGWarehouse_SQLOPS_io_sync_381_380
	on io_sync (dest_id, id, dest)
go

create index FGWarehouse_SQLOPS_io_sync_379_378
	on io_sync (season_id, id, sbu_id, season)
go

create index FGWarehouse_SQLOPS_io_sync_377_376
	on io_sync (sbu_id, season, season_id, id)
go

create index FGWarehouse_SQLOPS_io_sync_375_374
	on io_sync (sbu_id, sales_grp, sales_grp_id, id)
go

create index FGWarehouse_SQLOPS_io_sync_373_372
	on io_sync (sbu_id, prod_type, prod_type_id, id)
go

create index FGWarehouse_SQLOPS_io_sync_371_370
	on io_sync (sbu_id, order_status, order_status_id, id)
go

create index FGWarehouse_SQLOPS_io_sync_369_368
	on io_sync (cust_style_id, id, sbu_id, cust_style)
go

create index FGWarehouse_SQLOPS_io_sync_16_15
	on io_sync (ship_mode, ship_mode_id, id)
go

create index FGWarehouse_SQLOPS_io_sync_14_13
	on io_sync (mfg_loc, mfg_loc_id, id)
go

create table EndLineQCHdr
(
	PTNo varchar(13) not null,
	Seq int not null,
	ProdLine varchar(10) not null,
	Reject bit,
	GarmentCount bit,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	Authorized bit,
	OldPTNo varchar(13),
	OldSeq int,
	LastTransferDt datetime,
	TransferBy nvarchar(50),
	constraint PK_EndLineQCHdr
		primary key (PTNo, Seq)
)
go

create table m_No_Range_Key
(
	NoRange varchar(10) not null,
	RangeKey varchar(40) not null,
	CurrentNo varchar(10) not null,
	Active bit constraint DF_NoRangeKey_Active default 0 not null,
	time_Created datetime constraint DF_NoRangeKey_time_Created default getdate() not null,
	Created_By nvarchar(50) not null,
	time_Updated datetime,
	Updated_By nvarchar(50),
	constraint PK_NoRangeKey
		primary key (NoRange, RangeKey)
)
go

create table stg_SyncLog
(
	Recid varchar(100) not null
		constraint PK_stg_SyncLog
			primary key,
	RunTime datetime not null,
	CreatedBy nvarchar(50) not null,
	Remarks nvarchar(2000) not null,
	TimeFinish datetime
)
go

create table wip_po_closing
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	actual_ex_fty_dt varchar(255),
	code varchar(255),
	co_no varchar(255),
	created_date varchar(255),
	description varchar(255),
	dest varchar(255),
	mono varchar(255),
	order_status varchar(255),
	originalcoqty int,
	cpono varchar(255),
	force_close_reason varchar(255),
	rev_ex_fty_dt varchar(255),
	revised_qty int,
	ship_mode varchar(255),
	shipment_status varchar(255),
	shipped_qty int,
	updated_date varchar(255)
)
go

create table ir_blocked_token
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255)
)
go

create table fg_scan_logs_history
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	carton_id numeric(19,2),
	code varchar(255),
	description varchar(255),
	module_id int,
	purchase_order_id numeric(19,2),
	is_scanned bit,
	split_no numeric(19,2)
)
go

create table EndLineQCRFID
(
	PTNo varchar(13) not null,
	Seq int not null,
	ProdLine varchar(10) not null,
	NewRFID varchar(20) not null,
	NewSeq int not null,
	Status varchar(10) not null,
	Color varchar(50),
	RejectType varchar(50) not null,
	UserID nvarchar(50) not null,
	TransDt datetime constraint DF_EndLineQCRFID_TransDt default getdate() not null,
	FixedUserID nvarchar(50),
	FixedDt datetime,
	ConvertToRepairUserID nvarchar(50),
	ConvertToRepairDt datetime,
	ConvertToShipUserID nvarchar(50),
	ConvertToShipDt datetime,
	Remarks nvarchar(50),
	OldPTNo varchar(13),
	OldSeq int,
	Qty int,
	Parts nvarchar(50),
	CPStatus int constraint DF_EndLineQCRFID_CPStatus_1 default 0,
	CPApprovedUserID varchar(50),
	CPApprovedDt datetime,
	CPConfirmedUserID varchar(150),
	CPConfirmedDt datetime,
	CPConfirmedQty int,
	DisposedUserID varchar(50),
	DisposedDt datetime,
	constraint PK_EndLineQCRFID
		primary key (PTNo, Seq, NewRFID, NewSeq)
)
go

create index endlineqcrfid_status
	on EndLineQCRFID (Status, CPStatus, Qty, CPConfirmedQty, CPApprovedDt, PTNo, Seq, UserID, TransDt, Remarks, Parts, CPApprovedUserID, CPConfirmedUserID, CPConfirmedDt, ProdLine, Color)
go

create table BO_Hdr_Compare
(
	Mfg_Loc varchar(20) not null,
	Line varchar(20) not null,
	MONo varchar(20) not null,
	BONo varchar(20) not null,
	Plan_Qty int not null,
	Time_Created datetime constraint DF_BO_Hdr_Compare_Time_Created default getdate() not null,
	constraint PK_BO_Hdr_Compare
		primary key (Mfg_Loc, MONo, BONo)
)
go

create table stg_SyncCMPrice
(
	IONo varchar(50),
	CostCat varchar(50),
	UnitPrice numeric(18,5),
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	CreatedDt datetime constraint DF_stg_SyncCMPrice_CreatedDt default getdate(),
	SrcERP varchar(10)
)
go

create table wip_qr_code_transaction
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	output_date datetime2,
	qr_code varchar(25),
	work_section varchar(255),
	worker_id varchar(255)
)
go

create table ir_login_history
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	agent varchar(255),
	code varchar(255),
	description varchar(255),
	ip varchar(255)
)
go

create table fg_translation
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	mm nvarchar(255),
	cn nvarchar(255),
	code nvarchar(255),
	description nvarchar(255),
	en nvarchar(255),
	kh nvarchar(255)
)
go

create table stg_SyncCustGrp
(
	CustGrp varchar(50),
	Description nvarchar(256),
	CreatedDt datetime constraint DF_stg_SyncCustGrp_CreatedDt default getdate(),
	SrcERP varchar(10)
)
go

create table wip_references_v2
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	eff_date date,
	is_active bit,
	key_ varchar(255),
	ref_code varchar(255),
	value_ varchar(255)
)
go

create unique index wip_references_v2_ref_code_eff_date_key__value__uindex
	on wip_references_v2 (ref_code, eff_date, key_, value_)
go

create table ir_module_keys_update
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	action varchar(255),
	api_uri varchar(255),
	base_path varchar(255),
	code varchar(255),
	description varchar(255),
	groups varchar(255),
	head int not null,
	head_groups varchar(255),
	info varchar(255),
	method varchar(255),
	path varchar(255),
	uuid binary(255)
)
go

create table m_recent_activities
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	ip_address varchar(255),
	lat_long varchar(255),
	user_agent varchar(255)
)
go

create table fg_warehouse
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_frtslnxitibr35xr99c4y0yvb
			unique,
	description varchar(255)
)
go

create table fg_rack
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_16ka3gmcgfchy4r3y5fxnk7rc
			unique,
	description varchar(255),
	total_capacity int,
	warehouse_id bigint
		constraint FKe15f78kov5307ion4llth1aot
			references fg_warehouse
)
go

create table fg_carton
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	bin varchar(255),
	carton_no int,
	carton_qty int,
	check_point varchar(15),
	code varchar(255),
	description varchar(255),
	gross_weight float,
	height float,
	length float,
	loading_plan_id bigint
		constraint FK8q22uit6fumrc8fiid2fwkwvh
			references fg_loading_plan,
	nnw float,
	net_weight float,
	packing_iss_date datetime2,
	packing_issued bit,
	pallet varchar(255),
	physical_inventory bit,
	physical_inventory_date datetime2,
	physical_inventory_rack bigint,
	picked_for_loading bit,
	picked_for_loading_date datetime2,
	scan_load bit,
	scan_load_date datetime2,
	scanner bit,
	trans_id varchar(255),
	type varchar(3),
	ucc_barcode varchar(255),
	width float,
	warehouse_iss_date datetime2,
	warehouse_iss bit,
	warehouse_prod_iss bit,
	warehouse_prod_rcv bit,
	warehouse_rcv_date datetime2,
	warehouse_rcv bit,
	grade_id bigint
		constraint FKjip5rt4tgu3mdqytr5eqt1hy1
			references fg_grade,
	purchase_order_dtl_id bigint not null
		constraint FKoypg6egi6y6msebxucte2r0eh
			references fg_purchase_order_dtl,
	rack_id bigint
		constraint FK3nyuca8kcetvhf4uwc4a9r4qs
			references fg_rack,
	return_reason_id bigint
		constraint FKiu6ucs8xveie8pqhta6pw0gxd
			references fg_references,
	warehouse_id bigint
		constraint FKj46r0w7n9ebkwccb4tx08s87q
			references fg_warehouse
)
go

create table fg_carton_allocation
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	color varchar(255),
	qty int,
	size varchar(10),
	sku varchar(255),
	style varchar(255),
	upc_barcode varchar(255),
	code varchar(255),
	description varchar(255),
	iss_qty int,
	rcv_qty int,
	carton_id bigint
		constraint FKo7bi9lgqperp2cafd4dtscshf
			references fg_carton
)
go

create table fg_carton_scanning_hdr
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	check_point varchar(15),
	code varchar(255),
	description varchar(255),
	is_complete bit,
	total_cartons int,
	total_pallet int,
	trans_no varchar(255)
		constraint UK_h1kxubia2192c3lmq6742ts9e
			unique,
	type varchar(3),
	rack_id bigint
		constraint FK5dxf86w6q7q3ve63shxkwqrf6
			references fg_rack,
	warehouse_id bigint
		constraint FKlbnqobfiood7hfsxs5fyonc66
			references fg_warehouse
)
go

create table fg_carton_scanning
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	bin varchar(255),
	check_point varchar(15)
		constraint UK_h7aomv3tq92rnl3meq5hlddqn
			unique,
	code varchar(255),
	description varchar(255),
	is_complete bit,
	origin_id bigint
		constraint UK_g6ogshd0gh2hw295yva9mbxn1
			unique,
	pallet varchar(255),
	qty int,
	carton_allocation_qty int,
	type varchar(3)
		constraint UK_p6gpnph4vui4j0ggkd8reppmo
			unique,
	ucc_barcode varchar(255),
	carton_allocation_id bigint
		constraint FKey4six256cq11c4uivj3nj11p
			references fg_carton_allocation,
	carton_id bigint
		constraint FKgy9tnkxn3bbawjx0323ceng9h
			references fg_carton,
	grade_id bigint
		constraint FKdl34u21br2hwywr9bcv5w6q5p
			references fg_grade,
	purchase_order_id bigint not null
		constraint FKbct6xhu4wvdvom2207menjki9
			references fg_purchase_order,
	rack_id bigint
		constraint FK6n725lg79yyp9k9sn0m1g8t5
			references fg_rack,
	return_reason_id bigint
		constraint FK700p72yjdoqgqpgri3ec378ke
			references fg_references,
	scanning_hdr_id bigint
		constraint FK5yx30qqxbt9f43dm2bnpknlm0
			references fg_carton_scanning_hdr,
	warehouse_id bigint
		constraint FK4v3395k7wkof4t5h979icpmp9
			references fg_warehouse
)
go

create table fg_pallet
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	carton_count int,
	is_closed bit,
	code varchar(255)
		constraint UK_qy9mlu8nqivr6gy83hue8y3kd
			unique,
	description varchar(255),
	rack_id bigint
		constraint FKbquapask8ge05h4p6ibfgxkma
			references fg_rack,
	warehouse_id bigint
		constraint FK3pcdr28n2v2ytydk9i5dj3eh4
			references fg_warehouse
)
go

create table EndLineQCDet
(
	PTNo varchar(13) not null,
	Seq int not null,
	DefectType varchar(10) not null,
	DefectQty int,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	Frequency int not null,
	OldPTNo varchar(13),
	OldSeq int,
	constraint PK_EndLineQCDet
		primary key (PTNo, Seq, DefectType, Frequency)
)
go

create table Prod_Lines_WM_Det
(
	Mfg_Loc varchar(20) not null,
	Prod_Line varchar(20) not null,
	Ex_Name varchar(50) not null,
	GUID uniqueidentifier constraint DF_Prod_Lines_WM_Det_GUID default newid() not null,
	Time_From datetime not null,
	Time_To datetime not null,
	Time_Created datetime constraint DF_ProdLinesWMDet_Time_Created default getdate() not null,
	Created_By nvarchar(50) not null,
	Time_Updated datetime,
	Updated_By nvarchar(50),
	sbu_id int default 1 not null,
	id int identity
		constraint PK_Prod_Lines_WM_Det
			primary key,
	code int,
	description int,
	active bit default 1 not null,
	hdr_id bigint
)
go

create table stg_SyncCustomer
(
	CustomerCd varchar(50),
	CustAcctGrp varchar(50),
	CustGrp varchar(50),
	Name nvarchar(256),
	CreatedDt datetime constraint DF_stg_SyncCustomer_CreatedDt default getdate(),
	SrcERP varchar(10)
)
go

create table ir_value
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	module varchar(255),
	value varchar(255)
)
go

create table molist4split_merge_resource
(
	id varchar(255) not null
		primary key,
	mono varchar(255)
)
go

create table EndlineQCDet_transfer_logs
(
	PTNo varchar(13) not null,
	Seq int not null,
	DefectType varchar(10) not null,
	DefectQty int,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	Frequency int not null,
	OldPTNo varchar(13),
	OldSeq int,
	TransferDt datetime
)
go

create table stg_SyncIOSMV
(
	IONo varchar(50) not null,
	ItemNo varchar(100) not null,
	SeqNo int constraint DF_stg_SyncIOSMV_SeqNo default 0 not null,
	SMVDesc varchar(100) not null,
	SMV numeric(18,5) constraint DF_stg_SyncIOSMV_SMV default 0 not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	constraint PK_stg_SyncIOSMV
		primary key (IONo, ItemNo)
)
go

create table wip_report_staging_hdr
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	created_date datetime2,
	description varchar(255),
	is_locked bit,
	report_date date,
	report_month varchar(255),
	report_name varchar(255),
	report_year varchar(255),
	validated_by varchar(255),
	validated_date datetime2
)
go

create table wip_report_staging_dtl
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	is_deleted bit,
	description varchar(255),
	key_ varchar(255),
	is_locked bit,
	updated_date datetime2,
	value_ varchar(255),
	hdr_id bigint not null
		constraint FK2pfn09lya79us1p4n1p1xfeet
			references wip_report_staging_hdr
)
go

create table EndlineQCHdr_transfer_logs
(
	PTNo varchar(13) not null,
	Seq int not null,
	ProdLine varchar(10) not null,
	Reject bit,
	GarmentCount bit,
	CreatedBy nvarchar(50) not null,
	CreatedDt datetime not null,
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	Authorized bit,
	OldPTNo varchar(13),
	OldSeq int,
	LastTransferDt datetime,
	TransferBy nvarchar(50),
	Action varchar(20)
)
go

create table VAPSVAP_Template_Hdr
(
	Template_ID varchar(50) not null
		constraint PK_VAPSVAP_Template_Hdr
			primary key,
	Template_Source varchar(20) not null,
	Template_Desc varchar(100) not null,
	Deleted bit constraint DF_VAPSVAPTemplateHdr_Deleted default 0 not null,
	Created_By nvarchar(50),
	Time_Created datetime,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Default_CP bit
)
go

create table Prod_Lines_Ex
(
	Mfg_Loc varchar(20) not null,
	Prod_Line varchar(20) not null,
	GUID uniqueidentifier constraint DF_Prod_Lines_Ex_GUID default newid() not null,
	Except_Dt datetime,
	Date_From datetime,
	Date_To datetime,
	Has_Work bit,
	ManPower decimal(18) not null,
	Active bit default 1,
	Created_By nvarchar(50) not null,
	Time_Created datetime constraint DF_Prod_Lines_Ex_Time_Created default getdate() not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Long_Text nvarchar(256),
	constraint PK_Prod_Lines_Ex
		primary key (Mfg_Loc, Prod_Line, GUID)
)
go

create table m_building
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alt_description varchar(255),
	code varchar(255)
		constraint UK_g7c08us13o5d71jkbrdvho04b
			unique,
	description varchar(255),
	no_of_floor int
)
go

create table EndlineQCRFID_transfer_logs
(
	PTNo varchar(13) not null,
	Seq int not null,
	ProdLine varchar(10) not null,
	NewRFID varchar(20) not null,
	NewSeq int not null,
	Status varchar(10) not null,
	Color varchar(50),
	RejectType varchar(50) not null,
	UserID nvarchar(50) not null,
	TransDt datetime constraint DF_EndlineQCRFID_transfer_logs_TransDt default getdate() not null,
	FixedUserID nvarchar(50),
	FixedDt datetime,
	ConvertToRepairUserID nvarchar(50),
	ConvertToRepairDt datetime,
	ConvertToShipUserID nvarchar(50),
	ConvertToShipDt datetime,
	Remarks nvarchar(50),
	OldPTNo varchar(13),
	OldSeq int,
	Qty int,
	Parts nvarchar(50),
	CPStatus int constraint DF_EndlineQCRFID_transfer_logs_CPStatus_1 default 0,
	CPApprovedUserID varchar(50),
	CPApprovedDt datetime,
	CPConfirmedUserID varchar(50),
	CPConfirmedDt datetime,
	CPConfirmedQty int,
	DisposedUserID varchar(50),
	DisposedDt datetime,
	TransferDt datetime
)
go

create table wip_revise_delivery
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	cono varchar(255),
	cpo_item int,
	delivery_dt varchar(255),
	description varchar(255),
	last_updated_by varchar(255),
	last_updated_date varchar(255),
	mono varchar(255),
	pono varchar(255),
	rev_delivery_dt varchar(255)
)
go

create table m_cust_style
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_q88owfksnbcghq2unlq4yrgfl
			unique,
	description varchar(255)
)
go

create table vw_fg_blank_garments
(
	id bigint identity
		primary key,
	active bit,
	available_qty int,
	buyer varchar(255),
	carton_id numeric(19,2),
	carton_no int,
	color varchar(255),
	grade varchar(255),
	inbound_qty int,
	iono varchar(255),
	order_qty int,
	outbound_qty int,
	pono varchar(255),
	prod_received_by varchar(255),
	prod_received_date varchar(255),
	prod_received_qty int,
	sbu_id bigint,
	seq int,
	size varchar(255),
	style varchar(255),
	ucc_barcode varchar(255),
	warehouse_rcv_date date
)
go

create table VAPSVAP_Template_Det
(
	Template_ID varchar(50) not null,
	Seq smallint not null,
	VAP varchar(20) not null,
	SVAP varchar(20) not null,
	GVAP varchar(20),
	WBT bit constraint DF_VAPSVAPTemplateDet_WBT default 0,
	Lean bit constraint DF_VAPSVAPTemplateDet_Lean default 0,
	WPT bit constraint DF_VAPSVAPTemplateDet_WPT default 0,
	LoadOn bit constraint DF_VAPSVAPTemplateDet_LoadOn default 0,
	LoadOff bit constraint DF_VAPSVAPTemplateDet_LoadOff default 0,
	Reqd bit constraint DF_VAPSVAPTemplateDet_Reqd default 0,
	Subcon bit constraint DF_VAPSVAPTemplateDet_Subcon default 0,
	Seq2 int,
	Active bit constraint DF_VAPSVAPTemplateDet_Active default 0,
	Created_By nvarchar(50),
	Time_Created datetime,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Simultaneous bit default 0,
	Output_VAP varchar(20),
	Output_SVAP varchar(20),
	vap_id int,
	svap_id int,
	gvap_id int,
	constraint PK_VAPSVAPTemplateDet_1
		primary key (Template_ID, Seq)
)
go

create table stg_SyncIO
(
	IONo varchar(50),
	CustPONo varchar(50),
	CustPODt datetime,
	CustPOItem int,
	OrderType varchar(50),
	OrderStatus varchar(50),
	CustStyle varchar(100),
	CustStyleDesc varchar(100),
	CustColor varchar(100),
	CustSize varchar(100),
	ShipToCust varchar(100),
	StyleNo varchar(100),
	Color varchar(100),
	ColorDesc nvarchar(100),
	Size varchar(100),
	Dest varchar(50),
	ReqQty numeric(18,5),
	UOM varchar(100),
	DeliveryDt datetime,
	Plant varchar(100),
	Season varchar(100),
	SalesGrp varchar(100),
	CustGrp varchar(100),
	SoldToCust varchar(100),
	BillToCust varchar(100),
	ShipMode varchar(100),
	NoOfPcs int,
	CONo varchar(100),
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	CreatedDt datetime constraint DF_stg_SycnIO_CreatedDt default getdate(),
	SrcERP varchar(10),
	MfgLoc varchar(20),
	ProdType varchar(20),
	ProdTypeDesc nvarchar(50) constraint DF_stg_SyncIO_ProdTypeDesc default 100,
	MerchSMV numeric(18,5),
	TcSMV numeric(18,5),
	CustDelDt datetime,
	LPDDt datetime,
	AS400IONo varchar(20),
	Webbing varchar(50),
	AplqTyp varchar(50),
	EmbroTyp varchar(50),
	PrntTyp varchar(50),
	WashTyp varchar(50),
	HTTyp varchar(50),
	DyeTyp varchar(50),
	EmbroQty int,
	PrntQty int,
	PlanDt datetime,
	FtyDelDt datetime,
	IODesc nvarchar(100),
	FabPattern varchar(10),
	ColorTCSMV numeric(18,5),
	FabPatternDesc nvarchar(50),
	ShippedQty numeric(18,5),
	SORemarks nvarchar(50),
	RSDt datetime,
	VSLDt datetime,
	ExFtyDt datetime,
	SalesOrdType varchar(50),
	IOLn varchar(50)
)
go

create table wip_revised_delivery_det
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	actual_ex_factory_dt datetime2,
	code varchar(255),
	description varchar(255),
	ex_factory_dt datetime2,
	force_close_reason varchar(255),
	is_original_ex_fty bit,
	last_updated_by varchar(255),
	last_updated_date datetime2,
	order_qty int,
	order_status varchar(255),
	plan_ship_qty int,
	priorityx float,
	ship_mode varchar(255),
	ship_qty int,
	hdr_id bigint
		constraint FK2ayq30bpwnyelt93wif6yc71h
			references wip_revise_delivery
)
go

create table laying_hdr
(
	id bigint identity
		constraint PK__laying_h__3213E83F4545E59E
			primary key,
	active bit constraint DF_laying_hdr_active default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	bundle_no_from int,
	bundle_no_to int,
	code varchar(255),
	cut_work_section varchar(10),
	description varchar(255),
	excess bit,
	layno varchar(50),
	mono varchar(20)
		constraint FKtgolnx4brajnga8myk9sdgxcr
			references mo_hdr (mono),
	replacement bit,
	status varchar(1),
	non_lay bit
)
go

create table laying_sizes
(
	id bigint identity
		constraint PK__laying_s__3213E83F0D27B5C7
			primary key,
	active bit constraint DF_laying_sizes_active default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	layno varchar(20),
	mono varchar(20),
	seq int,
	size varchar(20),
	laying_hdr_id bigint
		constraint FKor72t8bpedvywek5bq934op85
			references laying_hdr,
	qty int
)
go

create table laying_ply_batch
(
	id bigint identity
		constraint PK__laying_p__3213E83F00E87F53
			primary key,
	active bit constraint DF_laying_ply_batch_active default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	color varchar(20),
	description varchar(255),
	layno varchar(20),
	mono varchar(20),
	qty numeric(18),
	size varchar(20),
	laying_hdr_id bigint
		constraint FKdm98ix7cbqwe0ibgwh34jq1rl
			references laying_hdr,
	seq int
)
go

create table laying_pt
(
	id bigint identity
		constraint PK__laying_p__3213E83F45BFBB81
			primary key,
	active bit constraint DF_laying_pt_active default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	bundle_no int,
	code varchar(255),
	color varchar(20),
	description varchar(255),
	layno varchar(20),
	mono varchar(20),
	qty int,
	seq int,
	size varchar(20),
	laying_hdr_id bigint
		constraint FKpcmxbargwjy688f4nm9gjl406
			references laying_hdr,
	ptno varchar(13),
	seq_ply_batch int,
	mo_id bigint
)
go

create table wip_workers_output
(
	id bigint identity
		constraint wip_workers_output_id_pk
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	bt_no varchar(20),
	bundle_no int,
	code varchar(255),
	color varchar(30),
	description varchar(255),
	feature varchar(100),
	feature_desc varchar(150),
	operation varchar(50),
	output_date datetime2,
	output_qty int,
	remarks varchar(1000),
	sam float,
	scan_mode varchar(1),
	scan_type varchar(2),
	seq int,
	smv float,
	split bit,
	style varchar(30),
	svap varchar(20),
	vap varchar(20),
	worker_id varchar(10),
	mo_id bigint
		constraint FKm96jsbqhsrkejofwys256bodb
			references mo_hdr,
	work_sections_id bigint
		constraint FK93bxio5dhcfg2fx9566ok6dw1
			references m_work_sections,
	ob_id bigint
		constraint FKiklt0bmtixg869c2scii1piy8
			references ob,
	pt_id bigint
		constraint FKfw6bgsgh9glrhyh6y8c0gbxn5
			references laying_pt,
	next_check_point varchar(10),
	wip_scan_part_id bigint,
	next_checkpoint_issued_qty int constraint wip_workers_output_next_checkpoint_issued_qty_default default 0,
	full_issued bit default 0 not null,
	next_ob_id bigint
)
go

create table wip_consolidation
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	bt_no varchar(20),
	bundle_no int,
	code varchar(255),
	color varchar(20),
	cpo_no varchar(50),
	description varchar(255),
	feature varchar(100),
	feature_desc varchar(150),
	issued_by varchar(50),
	mo_qty int,
	operation varchar(20),
	origin varchar(20),
	qty int,
	rack varchar(20),
	received_by varchar(50),
	received_date datetime2,
	scan_date datetime2,
	seq int,
	smv float,
	status varchar(10),
	style_no varchar(100),
	svap varchar(20),
	to_work_section varchar(255),
	vap varchar(20),
	wip_workers_output_id bigint
		constraint FKdxqip8e3fwx4p8afmlc3qikwo
			references wip_workers_output,
	work_sections_id bigint not null
		constraint FK1gyj4g0x7w0howm6by0tx923j
			references m_work_sections
)
go

create table wip_scan_part
(
	load_type char(1) constraint DF_WIPScanPart_Load_Type default 1 not null,
	seq int,
	svap varchar(20) not null,
	check_point varchar(20) not null,
	feature varchar(20),
	issued_qty numeric(8) constraint DF_WIPScanPart_Qty default 0 not null,
	created_by nvarchar(50) not null,
	time_created datetime constraint DF_WIPScanPart_Time_Created default getdate() not null,
	time_updated datetime,
	scan_dt datetime not null,
	authorized_by nvarchar(50),
	day_night_shft varchar(15),
	frm_prod_line varchar(10),
	frm_day_night_shft varchar(15),
	bundle_no int,
	pt_id bigint
		constraint FK54sk2k3gccvqluuynthutb8h
			references laying_pt,
	mo_id bigint
		constraint FKkhtdjbsia0kj0o467yttd7g35
			references mo_hdr,
	work_section_id int,
	received_qty int default 0 not null,
	ob_id bigint
		constraint FKat5njbhyj905y2eeaef3rko0k
			references ob,
	id bigint identity
		constraint wip_scan_part_id_pk
			primary key,
	next_check_point varchar(10),
	output_id bigint
		constraint FKdh0v9pmuwb58u1vf0uljgyi0e
			references wip_workers_output,
	sbu_id int,
	active bit,
	code varchar(10),
	description varchar(10),
	updated_by varchar(20),
	received_date datetime,
	origin varchar(10),
	output_qty int default 0 not null,
	vap varchar(15),
	next_ob_id bigint,
	mono varchar(20),
	layNo int
)
go

create index wip_workers_output_pt_id_feature_svap_wip_scan_part_id_index
	on wip_workers_output (pt_id, feature, svap, wip_scan_part_id)
go

create table m_customers
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_17xohm9o4f1ew4igsaa6g80l3
			unique,
	description varchar(255),
	souce varchar(255)
)
go

create table vw_fg_grade_reports
(
	id bigint identity
		primary key,
	active bit,
	available_qty int,
	buyer varchar(255),
	carton_id numeric(19,2),
	carton_no int,
	carton_size_qty int,
	color varchar(255),
	factory varchar(255),
	grade varchar(255),
	inbound_qty int,
	iono varchar(255),
	outbound_qty int,
	pono varchar(255),
	prod_received_by varchar(255),
	prod_received_date varchar(255),
	prod_received_qty int,
	sbu_id bigint,
	season varchar(255),
	seq int,
	size varchar(255),
	style varchar(255),
	ucc_barcode varchar(255),
	warehouse_rcv_date date
)
go

create table dom_test
(
	id bigint identity
		constraint dom_test_id_pk
			primary key nonclustered,
	created_by varchar(50),
	time_created datetime default getdate(),
	updated_by varchar(50),
	time_updated datetime,
	active bit default 1,
	sbu_id bigint not null,
	code varchar(30),
	name nvarchar(128),
	description_ nvarchar(512)
)
go

create unique index dom_test_code_uindex
	on dom_test (code)
go

create index dom_test_active_index
	on dom_test (active)
go

create index dom_test_sbu_id_index
	on dom_test (sbu_id)
go

create table wip_scan_barcode
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	average_smv float,
	code varchar(255),
	created_date datetime2,
	date_from date,
	date_to date,
	description varchar(255),
	efficiency float,
	lines int,
	mf_work_days int,
	mf_work_hours float,
	modified_by varchar(255),
	modified_date datetime2,
	month varchar(255),
	sat_work_days int,
	sat_work_hours float,
	sewer_count int,
	sewing_capacity_pcs int,
	sewing_capacity_sah int,
	sun_work_days int,
	sun_work_hours float,
	week int,
	year int
)
go

create table qconn_output_detail_scan_v3
(
	id bigint identity,
	MOno varchar(20) not null,
	PTno varchar(15) not null,
	layNo varchar(50),
	bundle_no smallint,
	prodline varchar(10),
	good_qty numeric(8) constraint DF__qconn_out__good___2180FB33 default 0,
	reject_qty numeric(8) constraint DF__qconn_out__rejec__22751F6C default 0,
	reworked_qty numeric(8) constraint DF__qconn_out__rewor__236943A5 default 0,
	repaired_qty numeric(8) constraint DF__qconn_out__repai__245D67DE default 0,
	unrepairable_qty numeric(8) constraint DF__qconn_out__unrep__25518C17 default 0,
	replaceable_qty numeric(8) constraint DF__qconn_out__repla__2645B050 default 0,
	assy_status varchar(20),
	min_sets numeric(8),
	assy_ppack numeric(8),
	line_plan_qty int,
	pt_line_inspected int,
	pt_line_output int,
	pt_line_sets int,
	pt_inspected int,
	pt_output int,
	pt_sets int,
	inBO bit,
	date_updated datetime,
	last_scanDt datetime,
	pt_line_status varchar(20) constraint DF__qconn_out__pt_li__2739D489 default 'PENDING',
	lay_date date,
	color varchar(20),
	Size varchar(20),
	lay_qty numeric(8) constraint DF__qconn_out__lay_q__282DF8C2 default 0 not null,
	tag_pt_started bit constraint DF__qconn_out__tag_p__29221CFB default 0,
	tag_pt_line_planned bit constraint DF__qconn_out__tag_p__2A164134 default 0,
	tag_mo_started bit constraint DF__qconn_out__tag_m__2B0A656D default 0,
	tag_multi bit constraint DF__qconn_out__tag_m__2BFE89A6 default 0,
	secondquality_qty numeric(8),
	condpass_qty numeric(8),
	force_complete bit constraint DF_qconn_output_detail_scan_v3_force_complete default 0,
	constraint qconn_output_detail_scan_v3_MOno_PTno_prodline_pk
		unique (MOno, PTno, prodline)
)
go

create table m_work_sections_sched
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	date_from datetime2,
	date_to datetime2,
	description varchar(255),
	man_power int,
	ot_manpower float,
	ot_mins float,
	target_eff float,
	work_shift varchar(255),
	work_sections_id bigint not null
		constraint FKowwkn22xkbentv319iwm80rob
			references m_work_sections,
	workshift bigint
		constraint FK6sttjy95e5v55j9dqge0xmuam
			references workshifts
)
go

create table m_destination
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_h0j4oixcvgfupx6ietmhpgbd7
			unique,
	description varchar(255)
)
go

create table stg_SyncPlant
(
	PlantCd varchar(50),
	Description nvarchar(256),
	CreatedDt datetime constraint DF_stg_SyncPlant_CreatedDt default getdate(),
	SrcERP varchar(10)
)
go

create table vw_fg_inbound_outbound_records
(
	id bigint identity
		primary key,
	active bit,
	available_carton int,
	available_qty int,
	buyer varchar(255),
	carton_qty int,
	factory varchar(255),
	grade varchar(255),
	grade_id int,
	inbound_carton int,
	inbound_date date,
	inbound_qty int,
	iono varchar(255),
	outbound_carton int,
	outbound_qty int,
	pono varchar(255),
	sbu_id bigint,
	season varchar(255),
	ship_to varchar(255),
	total_carton int
)
go

create table m_work_sections_workers
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	absent float,
	code varchar(255),
	date_from datetime2,
	date_to datetime2,
	description varchar(255),
	hrs_work float,
	no_ot_brk float,
	ot float,
	ut_late float,
	work_sections_id bigint not null
		constraint FKfs41eph3cgwimq34j128sx8cn
			references m_work_sections
)
go

create table wip_shipping_plan_summary
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	allocated_bldg varchar(255),
	carton_qty float,
	carton_qty_2 int,
	clp_no varchar(255),
	cntr varchar(255),
	code varchar(255),
	color varchar(255),
	co_no varchar(255),
	cont_arr_date date,
	cont_arr_time varchar(255),
	cont_lacking_qty varchar(255),
	cont_loaded_carton float,
	cont_loading_percent float,
	created_date datetime2,
	customer varchar(255),
	description varchar(255),
	destination varchar(255),
	dim float,
	dim_2 float,
	dim_3 float,
	etd date,
	fg_lacking_carton float,
	fg_lacking_qty float,
	fg_percent float,
	fg_received_carton float,
	fg_received_qty float,
	gw float,
	inspection_status varchar(255),
	item_no varchar(255),
	mo_qty varchar(255),
	mo_no varchar(255),
	nw float,
	pack_lacking_carton float,
	pack_lacking_qty float,
	pack_output_carton float,
	pack_output_pcs float,
	pack_packing_percent float,
	pcs_per_carton float,
	plan_month date,
	po_no varchar(255),
	prod_type varchar(255),
	ship_mode varchar(255),
	shipped_qty float,
	style_no varchar(255),
	total_cbm float,
	total_cbm_2 float,
	total_gw float,
	total_gw_2 float,
	total_nw float,
	total_nw_2 float,
	total_qty float,
	updated_date datetime2,
	week_no int,
	year int
)
go

create table m_event
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alt_description varchar(255),
	code varchar(255)
		constraint UK_hub2gxcaxxnr74q0w3tb41w4y
			unique,
	description varchar(255),
	level_no int,
	output_source varchar(255),
	pass_type varchar(255),
	plan_duration int,
	predecessor int,
	remarks varchar(255),
	req_duration int,
	responsible varchar(255),
	seq_no int,
	successor int,
	vap_id bigint
		constraint FKiq2b6o9d8o7u1mxtkvieq20ad
			references m_vap
)
go

create table stg_SyncPOETD
(
	IONo varchar(50),
	PONo varchar(50),
	POItem int,
	Plant varchar(50),
	DlvDt datetime,
	VendorCd varchar(50),
	VendorName varchar(256),
	POQty numeric(18,5),
	UOM varchar(50),
	UpdatedBy nvarchar(50),
	UpdatedDt datetime,
	CreatedDt datetime constraint DF_stg_SyncPOETD_CreatedDt default getdate(),
	SrcERP varchar(10)
)
go

create table vw_fg_issuance_dtl_v2
(
	id bigint identity
		primary key,
	active bit,
	asn_no varchar(255),
	booking_no varchar(255),
	carton_id bigint,
	carton_no int,
	invoice_no varchar(255),
	iono varchar(255),
	po_id bigint,
	pono varchar(255),
	sbu_id bigint,
	ship_date date,
	split_no int,
	ucc_barcode varchar(255)
)
go

create table mo_events
(
	id bigint identity
		constraint PK_mo_events
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	actual_duration int,
	actual_end date,
	actual_qty int,
	actual_start date,
	code varchar(255),
	description varchar(255),
	level_no int,
	orig_req_duration int,
	pass_type varchar(255),
	plan_duration int,
	plan_end date,
	plan_start date,
	po_end date,
	po_start date,
	predecessor int,
	remarks varchar(255),
	req_duration int,
	req_end date,
	req_start date,
	responsible varchar(255),
	seq_no int,
	successor int,
	event_id bigint
		constraint FKkxq27ee81lp0qwxxgppqqij04
			references m_event,
	mo_id bigint
		constraint FK83091c0y8x3yni3dtda445k73
			references mo_hdr,
	vap_id bigint
		constraint FK47iki3ajyef56xd934sb9r8bt
			references m_vap,
	mono varchar(20),
	vap varchar(50),
	event_seq int,
	key_event varchar(50),
	lead_lag int,
	rec_id varchar(50),
	ex_fty_dt date,
	mo_qty int,
	plan_qty int,
	act_qty int
)
go

create index FGWarehouse_SQLOPS_mo_events_856_855
	on mo_events (active, mo_id)
go

create index FGWarehouse_SQLOPS_mo_events_854_853
	on mo_events (active, mo_id, id, created_by, sbu_id, time_created, time_updated, updated_by, actual_duration, actual_end, actual_qty, actual_start, code, description, level_no, orig_req_duration, pass_type, plan_duration, plan_end, plan_start, po_end, po_start, predecessor, remarks, req_duration, req_end, req_start, responsible, seq_no, successor, event_id, vap_id)
go

create index FGWarehouse_SQLOPS_mo_events_115_114
	on mo_events (mono)
go

create index FGWarehouse_SQLOPS_mo_events_1003_1002
	on mo_events (mono, actual_start)
go

create index mo_events_mono_seq
	on mo_events (mono, event_seq, active, actual_duration, actual_end, actual_qty, actual_start, plan_end, plan_start, req_duration, req_end, req_start, ex_fty_dt)
go

create index mo_events_mono_actual_duration
	on mo_events (mono, actual_duration, orig_req_duration)
go

create index [NonClusteredIndex-20230927-152129]
	on mo_events (mono, vap)
go

create table bo_hdr_recalculate
(
	MONo varchar(20) not null,
	BONo int not null,
	Mfg_Loc varchar(20) not null,
	Line varchar(20) not null,
	Plan_Qty int not null,
	SMV decimal(18,5),
	Eff decimal(5,2),
	EATM int,
	Plan_Start datetime not null,
	Plan_Finish datetime not null,
	Actual_Start datetime,
	Actual_Finish datetime,
	Plant_Color varchar(50),
	Prd_Typ varchar(50),
	Prd_Typ2 varchar(50),
	Dif varchar(50),
	Plant varchar(20),
	MO_Qty int not null,
	MO_Cus_Del_Dt datetime not null,
	Completed bit,
	Created_By nvarchar(50) not null,
	Time_Created datetime not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Completed_Remarks nvarchar(4000),
	Trans_Id varchar(50),
	Trans_Dt datetime,
	Process varchar(50),
	Prod_Month datetime,
	CP_No varchar(20),
	id int identity,
	active bit,
	sbu_id int,
	code varchar(12),
	description varchar(100),
	total_planned_qty int,
	total_output_qty int,
	rec_id uniqueidentifier,
	eff_count int,
	prev_bono int,
	prev_plan_qty int,
	next_bono int,
	next_plan_qty int,
	step_no varchar(20),
	re_order_seq int
)
go

create table qconn_inline_qc_det
(
	id bigint identity
		primary key,
	parent_id bigint not null,
	worker varchar(50) not null,
	qty int,
	elapsed int,
	time_created datetime2,
	created_by nvarchar(50),
	time_updated datetime2,
	updated_by nvarchar(50)
)
go

create table wip_style_product_incentive
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	incentive float,
	code varchar(255),
	description varchar(255),
	eff_date datetime2,
	hrs_from float,
	hrs_to float,
	product_type varchar(255),
	style_no varchar(255)
)
go

create table bo_learn_curve_recalculate
(
	MONo varchar(20) not null,
	BONo varchar(20) not null,
	Line varchar(20) not null,
	Learn_Curve varchar(20),
	Interval int,
	Period_01 numeric(18,4),
	Period_02 numeric(18,4),
	Period_03 numeric(18,4),
	Period_04 numeric(18,4),
	Period_05 numeric(18,4),
	Period_06 numeric(18,4),
	Period_07 numeric(18,4),
	Period_08 numeric(18,4),
	Period_09 numeric(18,4),
	Period_10 numeric(18,4),
	Period_11 numeric(18,4),
	Period_12 numeric(18,4),
	Period_13 numeric(18,4),
	Period_14 numeric(18,4),
	Period_15 numeric(18,4),
	Period_16 numeric(18,4),
	Period_17 numeric(18,4),
	Period_18 numeric(18,4),
	Period_19 numeric(18,4),
	Period_20 numeric(18,4),
	Period_21 numeric(18,4),
	Period_22 numeric(18,4),
	Period_23 numeric(18,4),
	Period_24 numeric(18,4),
	Period_25 numeric(18,4),
	Period_26 numeric(18,4),
	Period_27 numeric(18,4),
	Period_28 numeric(18,4),
	Period_29 numeric(18,4),
	Period_30 numeric(18,4),
	Created_By nvarchar(50) not null,
	Time_Created datetime not null,
	Updated_By nvarchar(50),
	Time_Updated datetime,
	Trans_Id varchar(50),
	Trans_Dt datetime,
	Mfg_Loc varchar(20) not null,
	id int identity,
	active bit,
	sbu_id int,
	code varchar(12),
	description varchar(100),
	rec_id uniqueidentifier
)
go

create table stg_SyncProdOut
(
	IONo varchar(50),
	MONo varchar(50),
	Process varchar(50),
	ActStartDate datetime,
	ActFinDate datetime,
	RcptSLOC varchar(4),
	YieldQty numeric(18,5),
	ProdComp varchar(1),
	CreatedDt datetime constraint DF_stg_SyncProdOut_CreatedDt default getdate(),
	SrcERP varchar(10)
)
go

create table vw_fg_loading_plan
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	cartons_for_loading int,
	code varchar(255),
	container_no varchar(255),
	description varchar(255),
	destination varchar(255),
	loaded_cartons int,
	loading_plan_date date,
	loading_plan_id bigint,
	loading_plan_no varchar(255),
	loading_plan_pl_status varchar(255),
	loading_plan_qty int,
	loading_status varchar(255),
	loading_status_date datetime2,
	picked_cartons int,
	pono varchar(255),
	remarks varchar(255),
	ship_date date,
	split_no varchar(255),
	target_loading_date date,
	vendor varchar(255)
)
go

create table wip_style_schedule_report
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	actual_prod_month date not null,
	code varchar(255),
	description varchar(255),
	iono varchar(255),
	item_no varchar(255),
	plan_sew date,
	prod_line varchar(255),
	remarks varchar(255),
	sewing_dt date,
	style_no varchar(255) not null
)
go

create table m_line
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	capacity int not null,
	code varchar(255)
		constraint UK_r1xvwybq07ios4dviya81o732
			unique,
	description varchar(255),
	floor_no int not null,
	layout varchar(255),
	status varchar(255),
	type varchar(255),
	building_id bigint
		constraint FK3k3m0n94gr5aph9t4ei4wlrd1
			references m_building,
	mfg_loc varchar(10),
	locked_by varchar(30)
)
go

create table app_user_access_prodline
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	line_id bigint
		constraint FKegifpnwdcyqb0w3t9w9peygo3
			references m_line,
	user_id bigint
		constraint FKekq0ojdag9l7nh5wv6onyf2jq
			references app_user
)
go

create table stg_SyncSalesGrp
(
	SalesGrp varchar(50),
	Description nvarchar(256),
	CreatedDt datetime constraint DF_stg_SyncSalesGrp_CreatedDt default getdate(),
	SrcERP varchar(10)
)
go

create table vw_fg_pl_report
(
	id bigint identity
		primary key
)
go

create table m_workers
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	display_name varchar(255),
	empno varchar(255),
	first_name varchar(255),
	inactive bit,
	last_name varchar(255),
	middle_name varchar(255),
	position varchar(255),
	rfid varchar(255)
)
go

create table wip_user_access
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	created_date varchar(255),
	description varchar(255),
	is_admin bit,
	module_name varchar(255),
	template varchar(255),
	updated_date varchar(255),
	user_name varchar(255),
	widgets varchar(255),
	work_sections varchar(255)
)
go

create table m_positions
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alt_description varchar(255),
	code varchar(255),
	description varchar(255)
)
go

create table m_mfg_locs
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alt_description varchar(255),
	code varchar(255)
		constraint UK_2w8qjduh7ms8igq9lmpd833sq
			unique,
	default_loc bit not null,
	default_ws varchar(30),
	description varchar(255),
	level_no int,
	parent_mfg_loc varchar(30),
	seq_start int,
	w_ticket bit not null,
	gvap_id bigint
		constraint FKmwdf0l7ctja3hvbg02ailcn2c
			references m_gvap,
	parent_rec_id bigint
		constraint FK5qprer2tpow6bys4v90rhjisp
			references m_mfg_locs,
	local bit,
	mfg_loc_short_cd varchar(3),
	std_bndl_qty int,
	multiple_bndl bit constraint DF_m_mfg_locs_multiple_bundle default 0
)
go

create table user_mfg_loc
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	description varchar(255),
	mfg_loc_id bigint not null
		constraint FKla5as06a6eurph2bsgkwbe02j
			references m_mfg_locs,
	user_id bigint not null
		constraint FKnb16jpt7a7n1sfxb819fx9j4e
			references app_user,
	code varchar(255)
)
go

create table stg_SyncVendor
(
	VendorCd varchar(50),
	Name nvarchar(256),
	CreatedDt datetime constraint DF_stg_SyncVendor_CreatedDt default getdate(),
	SrcERP varchar(10)
)
go

create table qconn_inline_qc_hdr
(
	id bigint identity
		primary key,
	building varchar(20) not null,
	vap varchar(20) not null,
	prodline varchar(20) not null,
	pono varchar(20),
	mono varchar(20) not null,
	style varchar(50) not null,
	time_created datetime2,
	created_by nvarchar(50),
	time_updated datetime2,
	updated_by nvarchar(50),
	status varchar(15),
	customer varchar(20)
)
go

create table vw_fg_po_pl_carton_inventory
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	carton_no int,
	code varchar(255),
	color varchar(255),
	description varchar(255),
	downloaded bit,
	inbound_date date,
	inbound_qty int,
	iono varchar(255),
	order_qty int,
	outbound_qty int,
	pono varchar(255),
	size varchar(255),
	split_no int,
	style varchar(255),
	trans_id int,
	ucc_barcode varchar(255)
)
go

create table Events_Temp_Det
(
	RecId varchar(50) not null,
	EventSeq int not null,
	KeyEvent varchar(50),
	ReqStart datetime,
	ReqEnd datetime,
	PlanStart datetime,
	PlanEnd datetime,
	ActualStart datetime,
	ActualEnd datetime,
	ReqDuration int,
	PlanDuration int,
	ActualDuration int,
	Responsible varchar(50),
	VAP varchar(50),
	Remarks nvarchar(100),
	Predecessor int,
	Successor int,
	Deleted bit,
	CreatedDt datetime constraint DF_EventsTempDet_CreatedDt default getdate() not null,
	CreatedBy varchar(50),
	UpdatedDt datetime,
	UpdatedBy varchar(50),
	LeadLag int,
	PassType varchar(20),
	LevelNo int,
	SeqNo int,
	Active bit,
	constraint PK_EventsTempDet
		primary key (RecId, EventSeq)
)
go

create table m_skill_library
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	alt_description varchar(255),
	code varchar(255),
	description varchar(255),
	svap varchar(255),
	vap varchar(255)
)
go

create table wip_workers_daily_line_attendance
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	emp_no varchar(255),
	hris_logs varchar(255),
	line_section varchar(255),
	time_log_1 datetime2,
	time_log_2 datetime2,
	time_log_3 datetime2,
	time_log_4 datetime2,
	work_date date
)
go

create table m_size_seq
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	seq int,
	size varchar(255)
)
go

create table m_mo_colors
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	mo_id bigint not null
		constraint FK2smgeflkdfvraw7qxp0a2en7r
			references mo_hdr
)
go

create table stg_SyncCF
(
	DocType varchar(20) not null,
	MfgLoc varchar(20) not null,
	IONo varchar(20) not null,
	PlanMonth datetime not null,
	Season varchar(20),
	StyleNo varchar(50),
	ProdYr varchar(4),
	ProdMo varchar(2),
	PlantCd varchar(50),
	OrderQty numeric(18,5),
	TCSMV numeric(18,5),
	UpdatedDt datetime,
	constraint PK_stg_SyncCF
		primary key (DocType, MfgLoc, IONo, PlanMonth)
)
go

create table vw_fg_receiving_dtl
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	carton_allocation_qty int,
	bin varchar(255),
	check_point varchar(15)
		constraint UK_b4610sd8dnob5l20lrfe1wdln
			unique,
	code varchar(255),
	description varchar(255),
	is_complete bit,
	pallet varchar(255),
	qty int,
	type varchar(3)
		constraint UK_chxar75f7foytgqvfm70ek82v
			unique,
	ucc_barcode varchar(255),
	carton_id bigint not null
		constraint UK_1ls9n01o5vyaelq9v4hji2rc9
			unique
		constraint FKj99m0m3xmejp9j2dfqiwf73f3
			references fg_carton,
	carton_allocation_id bigint
		constraint FKnm7brap9hjesht6bq3iqmx38r
			references fg_carton_allocation,
	purchase_order_id bigint not null
		constraint FKkdvvajiggdr3atv2vpoyjiyo2
			references fg_purchase_order,
	rack_id bigint
		constraint FK99cyj4ajnqsj8kso1j187cl0a
			references fg_rack,
	scanning_hdr_id bigint not null
		constraint FKfdi56sfyvqri0ax6ffx94jhoi
			references fg_carton_scanning_hdr,
	warehouse_id bigint
		constraint FK5t9uwc2cbn6xt3bqvt3qcbruy
			references fg_warehouse
)
go

create table m_breaktime_matrix
(
	id bigint identity
		constraint m_breaktime_matrix_PK
			primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	breaktime int,
	code varchar(255),
	description varchar(255),
	min_hrs_worked float,
	time_from time,
	time_to time,
	work_breaktimes_id bigint
		constraint FKigrgnkxb1m588btui00wmc72g
			references m_work_breaktimes
)
go

create table wip_workers_incentive
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	bundle_no int,
	code varchar(255),
	deleted bit,
	description varchar(255),
	feature varchar(255),
	feature_desc varchar(255),
	mono varchar(255),
	operation varchar(255),
	output_dt datetime2,
	qty int,
	scan_mode varchar(255),
	scan_type varchar(255),
	seq int,
	smv float,
	svap varchar(255),
	vap varchar(255),
	work_section varchar(255),
	worker_id varchar(255)
)
go

create table Events_Temp_Hdr
(
	RecId varchar(50) constraint DF_EventsTempHdr_RecId default newid() not null
		constraint PK_EventsTempHdr
			primary key,
	Desc1 nvarchar(100) not null,
	Desc2 nvarchar(100),
	Deleted bit constraint DF_EventsTempHdr_Deleted default 0,
	CreatedDt datetime constraint DF_EventsTempHdr_CreatedDt default getdate() not null,
	CreatedBy varchar(50) not null,
	UpdatedDt datetime,
	UpdatedBy varchar(50)
)
go

create table m_load_priority
(
	id bigint identity,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255),
	description varchar(255),
	seq int
)
go

create table m_order_status
(
	id bigint identity
		primary key,
	active bit,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	code varchar(255)
		constraint UK_q4kkvka4s53oonttt8gi7j9aj
			unique,
	description varchar(255)
)
go

create table io_hdr
(
	id bigint identity
		primary key,
	active bit constraint DF_io_hdr_active default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	board_color varchar(50),
	code varchar(255),
	cust_del_dt date,
	cust_desc varchar(250),
	description varchar(255),
	iono varchar(20),
	merch_smv float,
	order_qty int,
	plan_smv float,
	psd_dt date,
	remarks varchar(1000),
	req_ex_fty_dt date,
	src_erp varchar(10),
	style_no varchar(100),
	tc_smv float,
	uom varchar(20),
	cus_grp_id bigint
		constraint FKqb58wkviuescy9xa4owwpu19y
			references m_customers,
	cust_style_id bigint
		constraint FKeowk9wladdrjv0aapo27gyr16
			references m_cust_style,
	mfg_loc_id bigint
		constraint FKpeak0acrbaf2r6b4t43wfc0pp
			references m_mfg_locs,
	order_status_id bigint
		constraint FKeku1rsge0sulaeuever382ixb
			references m_order_status,
	order_type_id bigint
		constraint FKkronu6a72eic381hd06saq8bv
			references m_order_types,
	plant_id bigint
		constraint FK4dx3394ga6rs1dgsnyru3cl92
			references m_plants,
	prod_type_id bigint
		constraint FK71by43xlq5ixpax7oacj1nyw0
			references m_prod_type,
	sales_grp_id bigint
		constraint FKncowqgyt6owglm8xh8s0r2vhi
			references m_sales_grp,
	season_id bigint
		constraint FKrmlycdh0hq8ceg0j6gwy6kq01
			references m_season,
	mfg_loc varchar(20),
	cus_grp varchar(20),
	season varchar(20)
)
go

create index FGWarehouse_SQLOPS_io_hdr_81_80
	on io_hdr (iono, id)
go

create index FGWarehouse_SQLOPS_io_hdr_389_388
	on io_hdr (iono, id, sbu_id)
go

create index FGWarehouse_SQLOPS_io_hdr_1621_1620
	on io_hdr (iono)
go

create table io_det
(
	id bigint identity
		constraint PK__io_det__3213E83F8AC6471F
			primary key,
	active bit constraint DF_io_det_active default 1,
	created_by varchar(50),
	sbu_id bigint not null,
	time_created datetime2,
	time_updated datetime2,
	updated_by varchar(50),
	co_status varchar(50),
	code varchar(255),
	color varchar(20),
	cono varchar(50),
	cpo_dt date,
	cpo_item int,
	cust_color varchar(20),
	cust_size varchar(20),
	description varchar(255),
	dlv_dt date,
	ex_fty_dt date,
	io_ln varchar(50),
	pod_dt date,
	cpo_no varchar(50),
	qty int,
	remarks varchar(1000),
	rs_dt date,
	shipped_qty int,
	size varchar(20),
	vsl_dt date,
	dest_id bigint
		constraint FKb6498dtgotm8yvflb6k4vdgbl
			references m_destination,
	io_id bigint
		constraint FKofleog1mk4wphw7shp6147fsa
			references io_hdr,
	order_type_id bigint
		constraint FKxq8ej0f5uow6yvgmyjny9mfx
			references m_order_types,
	ship_mode_id bigint
		constraint FK5f23f2b0kiaiysoj99n49pc2v
			references m_ship_mode,
	ship_to_cust_id bigint
		constraint FKtnlrl0lq60ggvr8wtn7fp834r
			references m_customers,
	iono varchar(20),
	item_no varchar(50) constraint DF_io_det_item_no default newid(),
	cust_style varchar(20),
	cust_desc varchar(100),
	cust_dest varchar(50),
	style_no varchar(100),
	ship_to_cust varchar(20),
	bill_to_cust varchar(20),
	sold_to_cust varchar(20),
	dest varchar(50),
	psd_dt datetime,
	lpd_dt datetime,
	ship_mode varchar(20),
	garm_qty int,
	cm_price float,
	act_qty float,
	webbing varchar(50),
	co_remarks nvarchar(100),
	so_remarks nvarchar(50),
	sales_ord_type varchar(50),
	fty_del_dt datetime,
	fab_pattern nvarchar(10),
	ioln varchar(50)
)
go

create index FGWarehouse_SQLOPS_io_det_97_96
	on io_det (qty, cono, ex_fty_dt, pod_dt, io_id)
go

create index FGWarehouse_SQLOPS_io_det_966_965
	on io_det (item_no, io_ln)
go

create index FGWarehouse_SQLOPS_io_det_95_94
	on io_det (io_id, qty, cono, ex_fty_dt, pod_dt)
go

create index FGWarehouse_SQLOPS_io_det_91_90
	on io_det (qty, iono, item_no)
go

create index FGWarehouse_SQLOPS_io_det_89_88
	on io_det (iono, qty, item_no)
go

create index FGWarehouse_SQLOPS_io_det_87_86
	on io_det (color, cono, size, id, co_status, io_id)
go

create index FGWarehouse_SQLOPS_io_det_85_84
	on io_det (color, cono, size, io_id)
go

create index iodet_1
	on io_det (iono, item_no, io_ln)
go

create index iodet_ioln
	on io_det (io_ln, item_no)
go












CREATE VIEW [dbo].[qconn_progression_tickets_v3] as

   SELECT 
        id = row_number()over(order by ah.MONo, ah.PTNo, ds.prodline ),
        ah.MONo, a.IONO, a.customer, a.pono, ah.time_Created as lay_date,
        a.StyleNo, a.product as prodType, ah.LayNo, ah.PTNo,
        ds.prodline as line,
        ah.Bundle_No as bundleno, ah.Color, ah.Size, a.order_qty,   --> MOHdr order Qty

        -- mo_plan_qty = (SELECT SUM(PlanQty) from BOHdr (nolock) where MONo = ah.mono),  --> MO plan qty SUM  base on BOHdr
        -- mo_plan_qty = a.mo_plan_qty,
        line_plan_qty = ISNULL(ds.line_plan_qty,0), --> qty plan based on BOHDR
--         pt_bundle_qty = ah.Qty, --> plan qty per PT

        inspected_qty = isnull(good_qty, 0) + isnull(ds.reject_qty, 0) /*+ isnull(ds.repaired_qty, 0) + isnull(ds.unrepairable_qty, 0) + isnull(ds.replaceable_qty, 0)*/,
--         passed_qty = isnull(good_qty, 0) - isnull(ds.reworked_qty, 0),                  -- rft per line
        passed_qty = CASE when isnull(good_qty, 0) - isnull(ds.reworked_qty, 0) > 0 THEN
                        isnull(good_qty, 0) - isnull(ds.reworked_qty, 0)                  -- rft per line
                    ELSE
                        0
                    END,

        rejected_qty = isnull(ds.reject_qty, 0) + isnull(ds.reworked_qty, 0) /*+ isnull(ds.repaired_qty, 0)*/,
        actual_rejected_qty = isnull(ds.reject_qty, 0),

        reworked_qty = isnull(ds.reworked_qty, 0),
        repaired_qty = isnull(ds.repaired_qty, 0),
        unrepairable_qty = isnull(ds.unrepairable_qty, 0),
        replaceable_qty = isnull(ds.replaceable_qty, 0),
        good_qty = isnull(good_qty, 0),                                                  --> Scan Good (includes reworked/repair)

        CASE when ISNULL(a.multi,0) = 1 THEN
            CASE WHEN ISNULL(ah.Qty,0) = ISNULL( ds.pt_output ,0) AND ISNULL( ds.pt_output ,0) > 0 AND isnull(ds.reject_qty, 0) -   isnull(ds.unrepairable_qty, 0) = 0 THEN 'COMPLETED'
				WHEN ds.force_complete = 1 THEN 'COMPLETED'
                 -- WHEN ISNULL(ds.pt_line_sets,0) = 0 AND ds.pt_line_inspected = 0 THEN 'PENDING'
                 WHEN ds.pt_line_inspected = 0 THEN 'PENDING'
                 -- WHEN ISNULL(ds.pt_line_sets,0) > 0 OR (ds.pt_inspected > 0 AND ds.pt_inspected < ah.Qty) THEN 'IN_PROGRESS'
                 ELSE 'IN_PROGRESS'
            END
        ELSE
--             CASE WHEN ISNULL(a.mo_plan_qty,0) = ISNULL( a.mo_output,0) THEN 'COMPLETED'
            CASE WHEN ISNULL(ds.line_plan_qty,0) = ISNULL(ds.pt_line_inspected,0) AND ISNULL( ds.pt_output ,0) > 0 AND isnull(ds.reject_qty, 0) -   isnull(ds.unrepairable_qty, 0) = 0 THEN 'COMPLETED'
                WHEN ds.force_complete = 1 THEN 'COMPLETED'
				-- WHEN ISNULL(ds.pt_line_sets,0) = 0 AND ds.pt_line_inspected = 0 THEN 'PENDING'
                WHEN ds.pt_line_inspected = 0 THEN 'PENDING'
                ELSE 'IN_PROGRESS'
            END
        END status,
        allocated_qty = CASE when ISNULL(a.multi,0) = 1 THEN ISNULL(ah.Qty,0) ELSE ISNULL(ds.line_plan_qty,0) END,
        bundle_qty = CASE when ISNULL(a.multi,0) = 1 THEN ISNULL(ah.Qty,0) ELSE ISNULL(ds.line_plan_qty,0) END,
        available_qty =     CASE when ISNULL(a.multi,0) = 1 THEN
                                ISNULL(ds.pt_line_sets,0) - ISNULL(ds.pt_line_inspected,0)
                            ELSE ISNULL(a.mo_set,0) - ISNULL(a.mo_inspected,0) END,
        mo_available_qty =     CASE when ISNULL(a.multi,0) = 1 THEN
                                ISNULL(ds.pt_line_sets,0) - ISNULL(ds.pt_line_inspected,0)
                            ELSE ISNULL(a.mo_set,0) - ISNULL(a.mo_inspected,0) END,

--         rft_qty = isnull(good_qty, 0) - isnull(ds.reworked_qty, 0),         --> Rft per line
        rft_qty  = CASE when isnull(good_qty, 0) - isnull(ds.reworked_qty, 0) > 0 THEN
                        isnull(good_qty, 0) - isnull(ds.reworked_qty, 0)                  -- rft per line
                    ELSE
                        0
                    END,
        min_received_line = ISNULL(ds.min_sets,0),                          --> Complete parts received per line
        min_received_sets = ds.pt_sets,
        total_output_qty = ds.pt_output,
        total_inspected_qty = ds.pt_inspected,
        total_bundles = a.bundle_count,

        mo_qty = a.mo_plan_qty,     -- mo_qty = (SELECT SUM(PlanQty) from BOHdr (nolock) where MONo = ah.mono),  --> MO plan qty SUM  base on BOHdr
        mo_inspected_qty = a.mo_inspected,
        ds.min_sets,

        total_rejected_qty = 0, total_reworked_qty = 0, total_unrepairable = 0, total_repaired_qty = 0, total_good_qty = 0,
        assy_ppack = isnull(ds.assy_ppack, 0),
        ds.last_scanDt, ah.time_updated as updatedDt, ds.inBO, ds.assy_status, ds.date_updated,

--         qty_left = ISNULL(ds.pt_line_sets,0)  - ISNULL(ds.pt_line_inspected,0),
        qty_left =  CASE when ISNULL(a.multi,0) = 1 THEN
                        ISNULL(ds.pt_line_sets,0) - ISNULL(ds.pt_line_inspected,0)
                    ELSE ISNULL(ds.line_plan_qty,0) - ISNULL(ds.pt_line_inspected,0) END,

        line_available_qty =  ISNULL(ds.line_plan_qty,0) - ds.pt_line_inspected,
        a.destination ,a.multi

        , a.mo_plan_qty, a.mo_output, ds.pt_line_sets, ds.pt_line_inspected
        , a.mo_set, a.mo_inspected

		--begin 09/11/2021 added by Donel
		, replacement = cast(lh.replacement as integer)
		, excess = cast(ISNULL(lh.excess,0) as integer)
		--,b.ioline
		,ioline = isnull( (select STUFF((select  ',' +  iOLn from MO_Det aa inner join IO_Det bb on aa.Item_No = bb.Item_No where aa.MONo = a.MONo FOR XML PATH('')), 1, 1, '') ),'')
		--,ex_fty_dt = isnull( (select top 1 convert(date,rev_EX_FTY_DT) from view_wip_ex_factory where mono = a.mono order by rev_EX_FTY_DT ),'1900-01-01')
		--,ex_fty_dt = stuff((select distinct ',' + convert(varchar(10),view_wip_ex_factory.rev_EX_FTY_DT,101) 
		--				from view_wip_ex_factory where MONo  = a.mono  for XML  PATH ('')),1,1,'')
		,ex_fty_dt = cast(getdate() as date) --stuff((select distinct ',' + convert(varchar(10),case when view_wip_ex_factory.actual_ex_fty_dt is NULL then view_wip_ex_factory.rev_EX_FTY_DT else view_wip_ex_factory.actual_ex_fty_dt end,101) 
					 --	from view_wip_ex_factory where MONo  = a.mono  for XML  PATH ('')),1,1,'')
		,force_complete = isnull(force_complete,0)

    /*SELECT a.mono, ah.ptno, a.multi, ds.prodline, ds.min_sets,
           (isnull(ds.good_qty, 0) + isnull( ds.reject_qty, 0) + isnull( ds.repaired_qty, 0) + isnull( ds.unrepairable_qty, 0) + isnull( ds.replaceable_qty, 0)) as output,
           ISNULL(ds.line_plan_qty,0) as line_plan_qty,
           ds.pt_sets, ds.pt_inspected*/
    FROM qconn_output_detail_info_v3 a (nolock)
        INNER JOIN Laying_PT (nolock) ah ON a.MONo = ah.MONo
        INNER JOIN qconn_output_detail_scan_v3 ds (nolock) ON ds.MOno = ah.MONo AND ds.PTno = ah.PTNo AND ah.LayNo = ds.layNo

		--begin added 09/11/2021 added by Donel
		--added for column excess and replacement 07/29/2021
		inner join Laying_Hdr (nolock) lh ON ah.MONo = lh.MONo and ah.LayNo = lh.LayNo
		--added for column ioline 08/03/2021
		--inner join (select MONo, IONo, concat(IONO, '-', SplitNo) as ioline, ProdType, ProdMonth from MOHdr (nolock)) b on a.mono = b.MONo
/*		--added for column xftydate 08/27/2021
		left outer join modet (nolock) md on a.mono = md.mono and a.pono = md.cpono and md.qty > 0
		left outer join iohdr (nolock) ioh on ioh.iono = b.iono
	--end added 09/11/2021
*/
    WHERE  --a.mono in ('13127401001','xxxxx')  AND
         (      ( a.multi = 1  AND (ds.pt_sets > 0 OR ds.pt_inspected > 0) )
                OR
                ( a.multi = 0  AND ISNULL(ds.line_plan_qty,0) > 0 AND (a.mo_set > 0 or a.mo_inspected > 0 ) )
         )


go





CREATE VIEW [dbo].[View_Event]
AS
SELECT        etd.EventSeq, etd.KeyEvent, etd.ReqDuration, etd.Responsible, etd.VAP, etd.Remarks, etd.Deleted, etd.Predecessor, etd.Successor, etd.LevelNo, etd.PassType, 
                         etd.SeqNo, etd.Active
FROM            dbo.Events_Temp_Det AS etd INNER JOIN
                         dbo.Events_Temp_Hdr ON etd.RecId = dbo.Events_Temp_Hdr.RecId
WHERE        (dbo.Events_Temp_Hdr.Desc2 = N'Default')


go

CREATE view view_event_logs
as
    select id, method, request_url, request_param, request_body, created_by, created_date, agent, ip_address, application FROM archive.dbo.event_logs
    where application = 'IMAPPSV3'
go


create VIEW [dbo].[prodlines]
AS
SELECT prod_line as prodline, desc1, desc2, deleted = case when active = 1 then 0 else 1 end
,created_by as createdby, time_created as createddt, updated_by as updatedby, time_updated as updateddt
,mfg_loc as mfgloc, calendar, process, learn_curve as learncurve, day_gap as daygap, efficiency, prod_grp as prodgrp
,lean, fty_loc as ftyloc
from m_prod_lines
go


create VIEW [dbo].[vap]
AS
SELECT code as vap, description as desc1,'' as desc2, wbt, lean, wpt, check_point as 'checkpoint'
,plan_operation as 'plan', initial_check_point as initchkpt
,deleted = case when active = 1 then 0 else 1 end
,created_by as createdby, time_created as createddt, updated_by as updatedby, time_updated as updateddt

from m_vap
go

CREATE view vw_scan_logs_history
AS
	select a.id, e.module, e.id as module_id,  b.id as po_id, b.pono, c.split_no, d.id as carton_id, d.carton_no, d.ucc_barcode,
		a.created_by as user_name, isnull(a.is_scanned,0) as is_scanned, a.sbu_id, a.active, a.time_created
	from fg_scan_logs_history a with (nolock)
	inner join fg_purchase_order b with (nolock) on a.purchase_order_id = b.id
	inner join fg_purchase_order_dtl c with (nolock) on c.purchase_order_id = b.id
	inner join fg_carton d with (nolock) on d.id = a.carton_id
	inner join (select id, description as module from fg_references where ref_type = 'APP_MODULES') e on e.id = a.module_id
go






CREATE VIEW [dbo].[wipscan]
AS

select ROW_NUMBER() OVER ( ORDER BY mono, ptno, prodline, scandt ) as id,
mono, ptno, max(layno) as layno, 1 as loadtype, 1 as seq, 'ASSY-PPCK' as vap, 'ISS' as svap, sum(good) as qty, max(createdby) as createdby 
, max(createddt) as createddt, prodline as worksection, NULL as updateddt, scandt,  max(createdby) as authorizedby, 'D' as daynightshift, 1 as qcseq
from (
	select mono, a.ptno, max(layno) as layno , prodline, count(1) as good, max(createdby) as createdby, max(createddt) as createddt
	, cast(a.createddt as date) as scandt
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	where reject = 0 
	group by mono, a.ptno, a.prodline, cast(a.createddt as date)
	
	union all
	select mono, a.ptno, NULL as layno, a.prodline, sum(1) as good, max(fixeduserid) as createdby, max(fixeddt) as createddt
	, cast(c.fixeddt as date) as scandt 
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	inner join endlineqcrfid c on a.ptno  = c.ptno and a.seq = c.seq and c.status = 'PASSED'
	where reject = 1 
	group by mono, a.ptno, a.prodline, cast(c.fixeddt as date)
	
	union all
	select mono, a.ptno, NULL as layno, a.prodline, sum(c.qty) as good, max(userid) as createdby, max(transdt) as createddt
	, cast(c.transdt as date) as scandt 
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	inner join endlineqcrfid c on a.ptno  = c.ptno and a.seq = c.seq and c.status = 'CONDPASS' and cpapproveduserid is not NULL
	where reject = 1 
	group by mono, a.ptno, a.prodline,  cast(c.transdt as date)

	) a
	group by mono, ptno, prodline, scandt


go




CREATE VIEW [dbo].[bodailytarget]
AS
/*
select --ROW_NUMBER() OVER ( ORDER BY mono, bono, line, date ) as id,
mono, bono, line, date, qty
, created_by as createdby, time_Created as createddt, updated_by as updatedby, time_updated as updateddt
, trans_id as transid, mfg_loc as mfgloc
from bo_daily_target
*/
select mono,bono,line, plan_qty as qty
, created_by as createdby, time_Created as createddt, updated_by as updatedby, time_updated as updateddt
, trans_id as transid, mfg_loc as mfgloc
from bo_hdr

go

CREATE view [dbo].[view_wip_svap]
as
select  ROW_NUMBER() OVER( ORDER BY seq ) AS id, seq, a.vap, svap = a.svap_code, description
from (
  select * from (
  select seq = (case when svap_code = 'ICUT' then 1  when svap_code = 'SKI' then 2 when svap_code = 'GLU' then 3 when svap_code = 'FCUT' then 4 when svap_code = 'CCON' then 5 else 0 end), vap, svap_code, upper(description) as description from m_svap where vap = 'CUT'
  ) a where seq > 0
  union
  select seq = (case when svap_code = 'EMB' then 11  when svap_code = 'INK1' then 12 when svap_code = 'CEN' then 13 when svap_code = 'LNG' then 14 when svap_code = 'STR' then 15 when svap_code = 'HDL' then 16 else 0 end), vap, svap_code, upper(description) as description from m_svap where svap_code in ('HDL','LNG','INK1','CEN')
  union
  select seq = (case when svap_code = 'INK2' then 21  when svap_code = 'ASSY' then 22 else 0 end), vap , svap_code, upper(description) as description from m_svap where vap = 'SEW'
) a
go




CREATE VIEW [dbo].[ordSyncIOHdr_vw]
AS
SELECT        IONo, Order_Type, Season, Plant, Cust_Grp, Sales_Grp, UOM, Cust_Style, Cust_Style_Desc, Style_No, Order_Status, Prod_Type, Merch_SMV, Tc_SMV, Src_ERP, Mfg_Loc, 
                         Prod_Type_Desc, MAX(Aplq_Type) AS Aplq_Type, MAX(Embro_Type) AS Embro_Type, MAX(Prnt_Type) AS Prnt_Type, MAX(Wash_Type) AS Wash_Type, MAX(HT_Type) AS HT_Type, 
                         IO_Desc
						 ,mfg_loc_id,prod_type_id,cust_style_id,order_status_id
FROM            dbo.IO_Sync
GROUP BY IONo, Order_Type, Season, Plant, Cust_Grp, Sales_Grp, UOM, Cust_Style, Cust_Style_Desc, Style_No, Order_Status, Prod_Type, Merch_SMV, Tc_SMV, Src_ERP, Mfg_Loc, 
                         Prod_Type_Desc, IO_Desc
						 ,mfg_loc_id,prod_type_id,cust_style_id,order_status_id


go

CREATE view [dbo].[view_wip_vap]
as
select seq = 1, vap='CUT', svap = 'CUT', upper(description) as description, icon_class = 'fas fa-cut', code = 'cutting', color = 'amber' from m_vap where code = 'CUT'
union
-- select seq = 2, vap = 'EMB', svap = 'EMB', upper(description) as description, icon_class = 'fas fa-marker', code = 'embroidery', color = 'orange' from m_vap where code = 'EMBR'
--   union
-- select seq = 2, vap = 'PRT', svap = 'PRT', upper(description) as description, icon_class = 'fas fa-print', code = 'embroidery', color = 'orange' from m_vap where vap = 'PRT'
-- union
select seq = 4, vap ='CEN', svap = 'CEN', upper(description) as description, icon_class = 'fas fa-users', code = 'bpp', color = 'light-green'  from m_vap where code = 'CEN'
union
select seq = 5, vap='SEW' , svap = 'ASSY', 'ASSEMBLY' as description, icon_class = 'fas fa-shopping-bag', code = 'assembly', color = 'blue'  from m_vap where code = 'SEW'
go

CREATE VIEW m_event_successor_predecessor AS
    SELECT x.code as event_code,
          (SUBSTRING((SELECT DISTINCT  ',  ' + RTRIM(cast( code  as varchar)) AS 'data()'
                            FROM (
                                SELECT code from m_event b WHERE b.successor = CAST(x.code as Int)
                                UNION
                                SELECT predecessor from m_event b WHERE b.code = x.code
                                ) a   FOR XML PATH('')),4,2000)) as predecessor_display,
          (SUBSTRING((SELECT DISTINCT  ',  ' + RTRIM(cast( code  as varchar)) AS 'data()'
                            FROM (
                                SELECT code from m_event b WHERE b.predecessor = CAST(x.code as Int)
                                UNION
                                SELECT successor from m_event b WHERE b.code = x.code
                                ) a   FOR XML PATH('')),4,2000)) as successor_display
    FROM m_event x
go







CREATE VIEW [dbo].[MO_Mat_List_vw]
AS

SELECT ROW_NUMBER() OVER ( ORDER BY mh.mono, IO_Mat_List.mat_no ) as id,
IO_Mat_List.sbu_id,dbo.IO_Mat_List.IONo, mh.MONo, dbo.IO_Mat_List.CONo, dbo.IO_Mat_List.Mat_No AS Mtrl_No, dbo.IO_Mat_List.Mat_Desc, dbo.IO_Mat_List.Mat_Typ, dbo.IO_Mat_List.Mat_Typ_Desc, 
                         MAX(dbo.IO_Mat_List.In_Post_Dt) AS In_Post_Dt, MAX(dbo.IO_Mat_List.Plant_Avail_Dt) AS In_Tran_ETA_Dt, dbo.IO_Mat_List.Mat_No + dbo.IO_Mat_List.Mat_Desc AS Mat_No, 
                         MAX(dbo.IO_Mat_List.Ex_Mill_Dt) AS Ex_Mill_Dt, MAX(dbo.IO_Mat_List.Plant_Avail_Dt) AS Plant_Avail_Dt, dbo.IO_Mat_List.Process, dbo.IO_Mat_List.DC_Qty, dbo.IO_Mat_List.In_Tran_Qty, 
                         dbo.IO_Mat_List.WH_Qty, MAX(dbo.IO_Mat_List.In_Avail_Qty) AS In_Avail_Qty, ISNULL(bo.Plan_Qty, 0) AS Plan_Qty, mh.PO_Qty, ISNULL(bo.Plan_Qty, 0) 
                         - MAX(ISNULL(dbo.IO_Mat_List.In_Avail_Qty, 0)) AS Bal, [Mat_Specs_EN],[Mat_Specs_CN],[LETA_Fty], Mat_Type_EN, Mat_Type_CN, Depart_Ind, Mat_Color_EN
FROM            dbo.IO_Mat_List with (nolock) 
INNER JOIN
          (SELECT dbo.MO_Hdr.IONo, dbo.MO_Hdr.MONo, ''/*dbo.MODet.CPONo*/ AS CONo, SUM(dbo.MO_Det.Qty) AS PO_Qty
			FROM dbo.MO_Hdr WITH (NOLOCK) 
			INNER JOIN dbo.MO_Det WITH (NOLOCK) ON dbo.MO_Hdr.MONo = dbo.MO_Det.MONo
			WHERE  (dbo.MO_Det.Qty > 0)
            GROUP BY dbo.MO_Hdr.IONo, dbo.MO_Hdr.MONo/*, dbo.MODet.CPONo*/) AS mh ON /*dbo.IO_Mat_List.CONo = mh.CONo AND */
										dbo.IO_Mat_List.IONo = mh.IONo 
LEFT OUTER JOIN
            (SELECT MONo, SUM(Plan_Qty) AS Plan_Qty
              FROM  dbo.BO_Hdr with (nolock)
              GROUP BY MONo) AS bo ON mh.MONo = bo.MONo

GROUP BY IO_Mat_List.sbu_id,dbo.IO_Mat_List.IONo, mh.MONo, dbo.IO_Mat_List.CONo, dbo.IO_Mat_List.Mat_No, dbo.IO_Mat_List.Mat_Desc, dbo.IO_Mat_List.Mat_Typ, dbo.IO_Mat_List.Mat_Typ_Desc, 
                         dbo.IO_Mat_List.Mat_No + dbo.IO_Mat_List.Mat_Desc, dbo.IO_Mat_List.Process, dbo.IO_Mat_List.DC_Qty, dbo.IO_Mat_List.In_Tran_Qty, dbo.IO_Mat_List.WH_Qty, ISNULL(bo.Plan_Qty, 0), 
                         mh.PO_Qty, [Mat_Specs_EN],[Mat_Specs_CN],[LETA_Fty], Mat_Type_EN, Mat_Type_CN, Depart_Ind, Mat_Color_EN


go


CREATE VIEW [dbo].[ordMOEventsUpdate2vw]
AS
SELECT        TOP (100) PERCENT 0 AS [Select], dbo.IO_Hdr.Season, dbo.MO_Hdr.Style_No, dbo.MO_Hdr.MONo, md.CONo, md.CPO_No, dbo.MO_Hdr.IONo, --dbo.IO_Hdr.IONo, 
                         dbo.MO_Events.Event_Seq, dbo.Events.KeyEvent, dbo.MO_Events.Plan_Start, dbo.MO_Events.Plan_End, dbo.MO_Events.Actual_Start, dbo.MO_Events.Actual_End, 
                         dbo.MO_Events.Plan_Duration, dbo.MO_Events.Actual_Duration, dbo.MO_Events.Responsible, dbo.MO_Events.VAP, dbo.MO_Events.Remarks, dbo.MO_Events.Predecessor, 
                         dbo.MO_Events.Successor, dbo.MO_Events.Req_Start, dbo.MO_Events.Req_End, dbo.MO_Events.Req_Duration, dbo.MO_Events.Lead_Lag
						 , DATEDIFF(d, dbo.MO_Events.Req_Start, dbo.MO_Events.Req_End) + 1 AS Req_Dur
						 , DATEDIFF(d, dbo.MO_Events.Plan_Start, dbo.MO_Events.Plan_End) + 1 AS Plan_Dur
						 , DATEDIFF(d, dbo.MO_Events.Actual_Start, dbo.MO_Events.Actual_End) + 1 AS Act_Dur
						 , -1 * ISNULL(DATEDIFF(d, dbo.MO_Events.Req_Start, ISNULL(dbo.MO_Events.Plan_Start, CONVERT(date, GETDATE()))), 1) AS Plan_Var
						 , -1 * ISNULL(DATEDIFF(d, dbo.MO_Events.Req_Start, ISNULL(dbo.MO_Events.Actual_Start, CONVERT(date, GETDATE()))), 1) AS Act_Var
						 , CONVERT(int, md.PO_Qty) AS PO_Qty
						 , CONVERT(int, dbo.MO_Events.Actual_Qty) AS Act_Qty, CONVERT(int, ISNULL(dbo.MO_Events.Actual_Qty, 0) - ISNULL(md.PO_Qty, 0)) AS Bal_Qty
						 , CASE WHEN isnull(MO_Events.Predecessor, 0) = 0 THEN MO_Events.Event_Seq ELSE MO_Events.Predecessor END AS Head, 
                         CASE WHEN isnull(MO_Events.Successor, 0) = 0 THEN MO_Events.Event_Seq ELSE MO_Events.Successor END AS Tail, CASE WHEN isnull(MO_Events.Successor, 0) 
                         = 0 THEN 'FP' ELSE 'BP' END AS Pass_Type, dbo.Events.CodeDur, dbo.MO_Events.Req_Start AS Req_Start_To, dbo.MO_Events.PO_Start, dbo.MO_Events.PO_End
						 , -1 * ISNULL(DATEDIFF(d, dbo.MO_Events.PO_Start, ISNULL(dbo.MO_Events.Plan_Start, CONVERT(date, GETDATE()))), 1) AS PO_Plan_Var
						 , -1 * ISNULL(DATEDIFF(d, dbo.MO_Events.PO_Start, ISNULL(dbo.MO_Events.Actual_Start, CONVERT(date, GETDATE()))), 1) AS PO_Act_Var
						 , dbo.MO_Events.Plan_Start AS Plan_Start_To
						 , md.POD_Dt
						 , dbo.Events.OutputSrc, md.POD_Dt AS From_POD, md.POD_Dt AS To_POD, bo.Plan_Qty, CONVERT(int, md.PO_Qty) - ISNULL(bo.Plan_Qty, 0) AS UnPlan_Qty, 
                         DATEPART(iso_week, md.POD_Dt) AS CalWk, dbo.MO_Events.Seq_No, dbo.MO_Hdr.Prod_Month
		FROM            dbo.Events 
		INNER JOIN dbo.MO_Events WITH (NoLock) 
		INNER JOIN dbo.IO_Hdr 
		INNER JOIN dbo.MO_Hdr ON dbo.IO_Hdr.IONo = dbo.MO_Hdr.IONo ON dbo.MO_Events.MONo = dbo.MO_Hdr.MONo ON dbo.Events.EventSeq = dbo.MO_Events.Event_Seq 
		INNER JOIN
                    (SELECT        MONo, Min(CONo) AS CONo, Min(cPO_No) AS CPO_No, SUM(Qty) AS PO_Qty, MIN(POD_Dt) AS POD_Dt
                     FROM            dbo.MO_Det
                     WHERE        (Qty > 0) AND (POD_Dt IS NOT NULL)
                     GROUP BY MONo) AS md ON dbo.MO_Hdr.MONo = md.MONo 
		LEFT OUTER JOIN
                     (SELECT        MONo, SUM(Plan_Qty) AS Plan_Qty
                      FROM            dbo.BO_Hdr
                      GROUP BY MONo) AS bo ON dbo.MO_Hdr.MONo = bo.MONo

		WHERE        --(dbo.IO_Hdr.Order_Type_id  <> 1) 
						----AND (dbo.MOHdr.MfgLoc IN ('PHWOV', 'PHKNT')) 
						--AND (dbo.MO_Hdr.MO_Status NOT IN ('Cancelled', 'Complete')) 
						 (dbo.MO_Events.Active = 1) 
						 --and dbo.MOEvents.POStart is not null
		ORDER BY PassType, Head


go

CREATE view view_mo_bo_learning_curve
AS
SELECT A.* FROM (
    select 1 as period, period_01 as efficiency, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 2, period_02, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 3, period_03, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 4, period_04, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 5, period_05, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 6, period_05, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 7, period_07, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 8, period_08, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 9, period_09, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 10, period_10, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 11, period_11, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 12, period_12, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 13, period_13, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 14, period_14, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 15, period_15, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 16, period_16, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 17, period_17, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 18, period_18, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 19, period_19, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 20, period_20, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 21, period_21, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 22, period_22, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 23, period_23, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 24, period_24, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 25, period_25, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 26, period_26, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 27, period_27, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 28, period_28, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 29, period_29, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
    UNION ALL
    select 30, period_30, mono, bono, line, code, description  from ImappsV2.dbo.BO_Learn_Curve
  ) A
go

CREATE VIEW vw_ioList
AS
  select a.id, a.active, b.description as sbu, c.description as mfg_loc, d.description as plant,
    e.code as prod_type, e.description as prod_type_desc,  a.iono, f.description as season, g.description as cus_grp, a.style_no,
    a.cust_del_dt, a.psd_dt, a.board_color,  a.merch_smv, a.tc_smv, a.plan_smv,
    a.req_ex_fty_dt, h.description as cust_style
  from tmp.dbo.io_hdr a
  inner join tmp.dbo.app_sbu b on a.sbu_id = b.id
  inner join tmp.dbo.m_mfg_locs c on a.mfg_loc_id = c.id
  inner join tmp.dbo.m_plants d on a.plant_id = d.id
  inner join tmp.dbo.m_prod_type e on a.prod_type_id = e.id
  inner join tmp.dbo.m_season f on a.season_id = f.id
  inner join tmp.dbo.m_customers g on a.cus_grp_id = g.id
  inner join tmp.dbo.m_cust_style h on a.cust_style_id = h.id
go

create view vw_ob_group_operations
AS 
	select a.*, b.feature_desc, b.operation_desc, c.smv,
		isnull(b.revised_smv,0) as revised_smv, mo.merchsmv
	from mo_hdr mo
	INNER JOIN ob_group_operations a on a.mono = mo.mono
	INNER JOIN OB b on a.mono = b.mono and a.operation = b.operation and a.feature = b.feature
	INNER JOIN ob_smv_det c on a.mono = c.mono and a.operation = c.operation and a.feature = c.feature
go

CREATE VIEW vw_io_list
AS
  select a.id, a.active, b.description as sbu, c.description as mfg_loc, d.description as plant,
    e.code as prod_type, e.description as prod_type_desc,  a.iono, f.description as season, g.description as cus_grp, a.style_no,
    a.cust_del_dt, a.psd_dt, a.board_color,  a.merch_smv, a.tc_smv, a.plan_smv,
    a.req_ex_fty_dt, h.description as cust_style
  from tmp.dbo.io_hdr a
  inner join tmp.dbo.app_sbu b on a.sbu_id = b.id
  inner join tmp.dbo.m_mfg_locs c on a.mfg_loc_id = c.id
  inner join tmp.dbo.m_plants d on a.plant_id = d.id
  inner join tmp.dbo.m_prod_type e on a.prod_type_id = e.id
  inner join tmp.dbo.m_season f on a.season_id = f.id
  inner join tmp.dbo.m_customers g on a.cus_grp_id = g.id
  inner join tmp.dbo.m_cust_style h on a.cust_style_id = h.id
go

CREATE view [dbo].[view_wip_workers_output_by_worksection]
  AS
    --/*
    SELECT ROW_NUMBER()over(order by mo_id) as id, mo_id, style=isnull(style, ''), isnull(color, '') color, svap,
    workSection = (select code from  dbo.m_work_sections where id = a.work_sections_id)
    , convert(datetime,convert(varchar(12), output_date, 101)  + ' ' + RIGHT(CONCAT('00', DATEPART(hour, output_date)), 2) + ':00:00')   date
    , RIGHT(CONCAT('00', DATEPART(hour, output_date)), 2) hour, sum(output_qty) qty
    from wip_workers_output a(nolock)
    group by mo_id, style, color, svap, work_sections_id
    ,convert(datetime,convert(varchar(12), output_date, 101)  + ' ' + RIGHT(CONCAT('00', DATEPART(hour, output_date)), 2) + ':00:00') ,
    DATEPART(hour, output_date)
go

create view vw_io_list_no_mo
AS
  select distinct a.*
  from ImappsV2.dbo.vw_ioList a
  INNER JOIN tmp.dbo.io_det b on a.id = b.io_id
  LEFT OUTER JOIN tmp.dbo.mo_hdr c ON a.IONo = c.iono
  where b.qty > 0
go

create view view_learning_curve
AS
SELECT A.* FROM (
    select 1 as period, period_01 as efficiency, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 2, period_02, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 3, period_03, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 4, period_04, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 5, period_05, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 6, period_05, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 7, period_07, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 8, period_08, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 9, period_09, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 10, period_10, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 11, period_11, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 12, period_12, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 13, period_13, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 14, period_14, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 15, period_15, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 16, period_16, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 17, period_17, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 18, period_18, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 19, period_19, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 20, period_20, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 21, period_21, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 22, period_22, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 23, period_23, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 24, period_24, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 25, period_25, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 26, period_26, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 27, period_27, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 28, period_28, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 29, period_29, line_code, code, description  from ImappsV2.dbo.m_line_lc
    UNION ALL
    select 30, period_30, line_code, code, description  from ImappsV2.dbo.m_line_lc
  ) A
go

CREATE view vw_ob_smv
AS
	select c.id, c.active, c.created_by, c.sbu_id, c.time_created, c.time_updated, c.updated_by, c.code,
		  mo.mono, c.operation, b.operation_desc, c.feature,  b.feature_desc, b.seq, c.smv,
			b.vap, b.svap, case when c.eff_dt is null then convert(date,c.time_created)  else convert(date,c.eff_dt) end as eff_dt,
			c.approved_by, approved_dt, c.revised,
			case when c.revised = 1 then c.created_by else '' end as revised_by,
			case when c.revised = 1 then c.time_created else null end as revised_dt
	from mo_hdr mo
	INNER JOIN ob_group_operations a on a.mono = mo.mono
	INNER JOIN OB b on a.mono = b.mono and a.operation = b.operation and a.feature = b.feature
	INNER JOIN ob_smv_det c on a.mono = c.mono and a.operation = c.operation and a.feature = c.feature
go





CREATE VIEW [dbo].[prdMOExcessCutQtyvw]

AS

SELECT 
Laying_Hdr.MONo,
SUM(Laying_PT.Qty) AS Excess_qty
FROM 
dbo.Laying_Hdr WITH(NOLOCK)
INNER JOIN Laying_PT WITH(NOLOCK) ON Laying_Hdr.MONo = Laying_PT.MONo
AND Laying_Hdr.LayNo = Laying_PT.LayNo
WHERE [Status] = 'G'
AND ISNULL(Excess,0) = 1
GROUP BY Laying_Hdr.MONo


go




create VIEW [dbo].[prdMOReplacementCutQtyvw]

AS

SELECT 
dbo.Laying_Hdr.MONo,
SUM(dbo.Laying_PT.Qty) AS Replace_qty
FROM 
dbo.Laying_Hdr WITH(NOLOCK)
INNER JOIN dbo.Laying_PT WITH(NOLOCK) ON dbo.Laying_Hdr.MONo = dbo.Laying_PT.MONo
AND dbo.Laying_Hdr.LayNo = dbo.Laying_PT.LayNo
WHERE [Status] = 'G'
AND ISNULL(Replacement,0) = 1
GROUP BY dbo.Laying_Hdr.MONo


go

CREATE VIEW [dbo].[prdGetBoSavedvw]

AS


	SELECT
		B.id,
		B.sbu_id,
		B.MONo as MONo
		,B.BONo as BONo
		,(SELECT TOP 1 CPO_No FROM dbo.MO_Det WITH (NOLOCK) WHERE MONo = B.MONo and Qty > 0) as CPONo
		,M.IONo
		,M.Style_No
		,M.Remarks
		,M.Prod_Type
		,(SELECT sum(Qty) FROM dbo.MO_Det WITH (NOLOCK) WHERE MONo = B.MONo and Qty > 0) as MO_Qty
		,B.Mfg_Loc as Mfg_Loc
		,B.Line as Line_Cd
		,B.Plan_Qty as Plan_Qty
		,B.SMV as SMV
		,B.Eff as Eff
		,B.EATM as EATM
		,(SELECT TOP 1 Dest FROM dbo.MO_Det WITH (NOLOCK) WHERE MONo = B.MONo and Qty > 0) as Dest
		,B.Plan_Start as Plan_Start
		,B.Plan_Finish as Plan_Finish
		,B.Actual_Start as Actual_Start
		,B.Actual_Finish as Actual_Finish
		,ISNULL((SELECT sum(ISNULL(Qty,0)) FROM dbo.BO_Daily_Output WITH (NOLOCK) WHERE MONo = B.MONo and BONo = B.BONo and Line = B.Line),0) as Total_Output_Qty
		,(SELECT ISNULL(SUM(Excess_qty),0) FROM dbo.prdMOExcessCutQtyvw WITH(NOLOCK) WHERE MONo = B.MONo) as Excess_Qty
		,(SELECT ISNULL(SUM(Replace_qty),0) FROM dbo.prdMOReplacementCutQtyvw WHERE MONo = B.MONo) as Replace_Qty
		,B.Plan_Qty - ISNULL((SELECT sum(ISNULL(Qty,0)) FROM dbo.BO_Daily_Output WITH (NOLOCK) WHERE MONo = B.MONo and BONo = B.BONo and Line = B.Line),0) as Balance
		,(SELECT TOP 1 dateadd(day, -2, POD_DT) FROM dbo.MO_Det WITH (NOLOCK) WHERE MONo = B.MONo and Qty > 0) as LSF_Dt
		,M.Rev_Ex_Fty_Dt as Req_Ex_Fty_Dt
		,(SELECT TOP 1 Board_Color FROM dbo.m_Prod_Type WITH (NOLOCK) WHERE Prod_Type = M.Prod_Type) as Prod_Board_Color
		,(SELECT TOP 1 POD_Dt FROM dbo.MO_Det WITH (NOLOCK)  WHERE MONo = B.MONo and Qty > 0) as POD_Dt
		,M.Prod_Month as Prod_Month
		,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH (NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Leather') as Mat_ETA
		,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH (NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Textile') as Mat_Tex_ETA
		,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH (NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Hardware') as Mat_Hrd_ETA
		,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH (NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Zipper') as Mat_Zip_ETA
		,CASE WHEN ISNULL((SELECT TOP 1 DATEDIFF(dd,Plan_Start,Actual_Start) FROM dbo.MO_Events WITH (NOLOCK) WHERE MONo = M.MONo and Actual_Start IS NOT NULL ORDER BY Plan_Start DESC),0) > 0
			THEN (SELECT TOP 1 dateadd(day, DATEDIFF(dd,A.Plan_Start,A.Actual_Start), B.Plan_Start)  FROM dbo.MO_Events A WITH (NOLOCK) inner join dbo.MO_Events B WITH (NOLOCK) on A.MONo = B.MONo WHERE A.MONo = M.MONo and A.Actual_Start IS NOT NULL and B.VAP = 'SEW' ORDER BY A.Plan_Start DESC) ELSE NULL END as CP_Date
		,B.Completed as Completed
		,B.Created_By as Created_By
		,B.Time_Created as Time_Created
		,B.Updated_By as Updated_By
		,B.Time_Updated as Time_Updated
		,(SELECT TOP 1 Season FROM IO_Hdr WITH (NOLOCK) WHERE IONo = M.IONo) as Season
		,(SELECT TOP 1 Cus_Grp FROM IO_Hdr WITH (NOLOCK) WHERE IONo = M.IONo) as Cus_Grp
		,(SELECT TOP 1 Color FROM dbo.MO_Det WITH (NOLOCK) WHERE MONo = B.MONo and Qty > 0) as Color
		,(SELECT TOP 1 IO_Ln FROM dbo.IO_Det WITH(NOLOCK) WHERE Item_No = (SELECT TOP 1 Item_No FROM dbo.MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0)) as IOLn
	  , code = null
	  , description = null
	  , b.active
	FROM
		BO_Hdr B WITH (NOLOCK)
		LEFT OUTER JOIN MO_Hdr M WITH (NOLOCK) on B.MONo = M.MONo ----TO REMOVE BOs THAT DOES NOT EXIST IN MOHdr
		--LEFT OUTER JOIN CustOrders C on C.MONo = M.MONo
	WHERE
		--B.MfgLoc = @MfgLoc
		--AND B.ActualFinish IS NULL --AND Completed <> 1  ----USE ActualFinish INSTEAD OF Completed TO KNOW Complete BOs
		B.MONo IS NOT NULL
		AND B.BONo IS NOT NULL
		AND B.Line IS NOT NULL
go



create VIEW [dbo].[prdGetPlannedSavedvw]

AS
   

	SELECT   ROW_NUMBER() OVER ( ORDER BY b.sbu_id, B.MONo ,M.IONo, M.Style_No, M.Remarks, M.Prod_Type, B.Mfg_Loc, B.Line, B.SMV, BH.Plan_Start, BH.Plan_Finish  
		,BH.Actual_Start, BH.Actual_Finish, M.Rev_Ex_Fty_Dt, M.Prod_Type, M.Prod_Month, B.Completed, BH.Time_Created, BH.Time_Updated) as id,
		b.sbu_id,
		B.MONo as MONo  
		,(SELECT TOP 1 CPO_No FROM dbo.MO_Det WITH (NOLOCK) WHERE MONo = B.MONo and Qty > 0) as CPONo
		,M.IONo
		,M.Style_No
		,M.Remarks
		,M.Prod_Type
		,(SELECT sum(Qty) FROM dbo.MO_Det WITH (NOLOCK) WHERE MONo = B.MONo and Qty > 0) as MO_Qty
		,B.Mfg_Loc as Mfg_Loc  
		,B.Line as Line_Cd  
		,SUM(B.Plan_Qty) as Plan_Qty  
		,B.SMV as SMV  
		,(SELECT TOP 1 Dest FROM dbo.MO_Det WITH (NOLOCK) WHERE MONo = B.MONo and Qty > 0) as Dest  
		,BH.Plan_Start  
		,BH.Plan_Finish  
		,BH.Actual_Start  
		,BH.Actual_Finish  
		,ISNULL((SELECT sum(ISNULL(Qty,0)) FROM dbo.BO_Daily_Output WITH (NOLOCK) WHERE MONo = B.MONo and Line = B.Line),0) as Total_Output_Qty
		,(SELECT ISNULL(SUM(Excess_qty),0) FROM dbo.prdMOExcessCutQtyvw WITH(NOLOCK) WHERE MONo = B.MONo) as Excess_Qty
		,(SELECT ISNULL(SUM(Replace_qty),0) FROM dbo.prdMOReplacementCutQtyvw WHERE MONo = B.MONo) as Replace_Qty
		,SUM(B.Plan_Qty) - ISNULL((SELECT sum(ISNULL(Qty,0)) FROM dbo.BO_Daily_Output WITH (NOLOCK) WHERE MONo = B.MONo and Line = B.Line),0) as Balance
		,(SELECT TOP 1 E.RejectType FROM qconn_EndLineQCRFID E WITH (NOLOCK) INNER JOIN Laying_PT L WITH (NOLOCK) on E.PTNo = L.PTNo WHERE L.MONo = B.MONo and E.ProdLine = B.Line) as Reject_Type
		,(SELECT count(1) FROM qconn_EndLineQCRFID E WITH (NOLOCK) INNER JOIN Laying_PT L WITH (NOLOCK) on E.PTNo = L.PTNo WHERE L.MONo = B.MONo and E.ProdLine = B.Line) Reject_Qty
		--,(SELECT count(DISTINCT(RejectRFID)) FROM qcEndlineQualityInfo WITH (NOLOCK) WHERE MONo = B.MONo and RejectType = 'UNREPAIRABLE' and ProdLine = B.Line) as RejectQty
		,(SELECT TOP 1 dateadd(day, -2, POD_DT) FROM dbo.MO_Det WITH (NOLOCK) WHERE MONo = B.MONo and Qty > 0) as LSF_Dt
		,M.Rev_Ex_Fty_Dt as Req_Ex_Fty_Dt
		,(SELECT TOP 1 Board_Color FROM dbo.m_Prod_Type WITH (NOLOCK) WHERE Prod_Type = M.Prod_Type) as Prod_Board_Color
		,(SELECT TOP 1 POD_Dt FROM dbo.MO_Det WITH (NOLOCK)  WHERE MONo = B.MONo and Qty > 0) as POD_Dt
		,M.Prod_Month as Prod_Month
		,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH (NOLOCK) WHERE MONo = B.MONo and Mat_Typ = 'Leather') as Mat_ETA
		,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH (NOLOCK) WHERE MONo = B.MONo and Mat_Typ = 'Textile') as Mat_Tex_ETA
		,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH (NOLOCK) WHERE MONo = B.MONo and Mat_Typ = 'Hardware') as Mat_Hrd_ETA
		,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH (NOLOCK) WHERE MONo = B.MONo and Mat_Typ = 'Zipper') as Mat_Zip_ETA
		,CASE WHEN Coalesce((SELECT TOP 1 DATEDIFF(dd,Plan_Start,Actual_Start) FROM dbo.MO_Events WITH (NOLOCK) WHERE MONo = B.MONo and Actual_Start IS NOT NULL ORDER BY Plan_Start DESC),0) > 0 
			THEN (SELECT TOP 1 dateadd(day, DATEDIFF(dd,A.Plan_Start,A.Actual_Start), B.Plan_Start ) FROM dbo.MO_Events A WITH (NOLOCK) inner join dbo.MO_Events B WITH (NOLOCK) on A.MONo = B.MONo WHERE A.MONo = B.MONo and A.Actual_Start IS NOT NULL and B.VAP = 'SEW' ORDER BY A.Plan_Start DESC) ELSE NULL END as CP_Date
		,B.Completed as Completed  
		,(SELECT TOP 1 Created_By FROM BO_Hdr WITH (NOLOCK) WHERE MONo = B.MONo and Line = B.Line and time_created = BH.time_created) as Created_By  
		,BH.Time_Created  
		,(SELECT TOP 1 Updated_By FROM BO_Hdr WITH (NOLOCK) WHERE MONo = B.MONo and Line = B.Line and time_updated = BH.time_updated) as Updated_By  
		,BH.time_updated  
		,(SELECT TOP 1 Season FROM IO_Hdr WITH (NOLOCK) WHERE IONo = M.IONo) as Season
		,(SELECT TOP 1 Cus_Grp FROM IO_Hdr WITH (NOLOCK) WHERE IONo = M.IONo) as Cus_Grp
		,(SELECT TOP 1 Color FROM dbo.MO_Det WITH (NOLOCK) WHERE MONo = B.MONo and Qty > 0) as Color
		,(SELECT TOP 1 IO_Ln FROM dbo.IO_Det WITH(NOLOCK) WHERE Item_No = (SELECT TOP 1 Item_No FROM dbo.MO_Det WITH(NOLOCK) WHERE MONo = B.MONo and Qty > 0)) as IOLn
	FROM 
		BO_Hdr B WITH (NOLOCK) 
		LEFT OUTER JOIN MO_Hdr M WITH (NOLOCK) on B.MONo = M.MONo ----TO REMOVE BOs THAT DOES NOT EXIST IN MOHdr
		--LEFT OUTER JOIN CustOrders C on C.MONo = M.MONo
		OUTER APPLY
		(
			SELECT 
				SUM(Plan_Qty) as Plan_Qty, MIN(Plan_Start) as Plan_Start, MAX(Plan_Finish) as Plan_Finish, MIN(Actual_Start) as Actual_Start, MAX(Actual_Finish) as Actual_Finish, 
				MIN(Time_created) as Time_Created, MAX(Time_Updated) as Time_Updated
			FROM 
				BO_Hdr WITH (NOLOCK)
			WHERE
				Line = B.Line and MONo = B.MONo
		) BH
	WHERE 
		--B.MfgLoc = @MfgLoc   
		--AND B.ActualFinish IS NULL --AND Completed <> 1  ----USE ActualFinish INSTEAD OF Completed TO KNOW Complete BOs		 
		B.MONo IS NOT NULL  
		AND B.BONo IS NOT NULL 
		AND B.Line IS NOT NULL
		--AND B.MONo = '11754501001'
	GROUP BY
		b.sbu_id,
		B.MONo
		,M.IONo
		,M.Style_No
		,M.Remarks
		,M.Prod_Type
		,B.Mfg_Loc
		,B.Line
		,B.SMV
		,BH.Plan_Start  
		,BH.Plan_Finish  
		,BH.Actual_Start  
		,BH.Actual_Finish  
		,M.Rev_Ex_Fty_Dt
		,M.Prod_Type
		,M.Prod_Month
		,B.Completed
		--,B.CreatedBy as CreatedBy  
		,BH.Time_Created
		--,B.UpdatedBy as UpdatedBy  
		,BH.Time_Updated
	--ORDER BY 
	--	B.Line
	--	,B.PlanStart
	--	,B.MONo
	--	,B.BONo


go

CREATE VIEW [dbo].[ordMOEventsUpdateV3vw]
AS
SELECT        TOP (100) PERCENT 0 AS [Select], dbo.IO_Hdr.Season, dbo.MO_Hdr.Style_No, dbo.MO_Hdr.MONo, md.CONo, md.CPO_No, dbo.MO_Hdr.IONo, --dbo.IO_Hdr.IONo,
                         dbo.MO_Events.Event_Seq, dbo.Events.KeyEvent
						 ,mo_events.MO_Qty, mo_events.Plan_Qty, mo_events.mo_qty - mo_events.plan_qty as Unplanned_Qty
						 , dbo.MO_Events.Req_Duration, dbo.MO_Events.Actual_Duration--, dbo.MO_Events.Plan_Duration
						 , mo_events.ex_fty_dt as ExFactory_Date
						 , dbo.MO_Events.Req_Start as ExFactoryDate_Req_Start, dbo.MO_Events.Req_End as ExFactoryDate_Req_Finish
						 , dbo.MO_Events.Plan_Start as Sew_Plan_Start, dbo.MO_Events.Plan_End as Sew_Plan_Finish

						 , dbo.MO_Events.Actual_Start, dbo.MO_Events.Actual_End
						 , dbo.MO_Events.Act_Qty as Actual_Qty
						 , dbo.mo_events.id
	 					 , dbo.Events.Predecessor
						 , dbo.Events.Successor
						 , dbo.Events.PassType
						 , dbo.Events.levelNo
						 , dbo.Events.seqNo

						 --, dbo.MO_Events.VAP--, dbo.MO_Events.Remarks, dbo.MO_Events.Predecessor, dbo.MO_Events.Successor
						 --, dbo.MO_Events.Lead_Lag

						 /*, DATEDIFF(d, dbo.MO_Events.Req_Start, dbo.MO_Events.Req_End) + 1 AS Req_Dur
						 , DATEDIFF(d, dbo.MO_Events.Plan_Start, dbo.MO_Events.Plan_End) + 1 AS Plan_Dur
						 , DATEDIFF(d, dbo.MO_Events.Actual_Start, dbo.MO_Events.Actual_End) + 1 AS Act_Dur
						 , -1 * ISNULL(DATEDIFF(d, dbo.MO_Events.Req_Start, ISNULL(dbo.MO_Events.Plan_Start, CONVERT(date, GETDATE()))), 1) AS Plan_Var
						 , -1 * ISNULL(DATEDIFF(d, dbo.MO_Events.Req_Start, ISNULL(dbo.MO_Events.Actual_Start, CONVERT(date, GETDATE()))), 1) AS Act_Var
						 , CONVERT(int, md.PO_Qty) AS PO_Qty
						 , CONVERT(int, dbo.MO_Events.Actual_Qty) AS Act_Qty, CONVERT(int, ISNULL(dbo.MO_Events.Actual_Qty, 0) - ISNULL(md.PO_Qty, 0)) AS Bal_Qty
						 , CASE WHEN isnull(MO_Events.Predecessor, 0) = 0 THEN MO_Events.Event_Seq ELSE MO_Events.Predecessor END AS Head,
                         CASE WHEN isnull(MO_Events.Successor, 0) = 0 THEN MO_Events.Event_Seq ELSE MO_Events.Successor END AS Tail, CASE WHEN isnull(MO_Events.Successor, 0)
                         = 0 THEN 'FP' ELSE 'BP' END AS Pass_Type, dbo.Events.CodeDur, dbo.MO_Events.Req_Start AS Req_Start_To, dbo.MO_Events.PO_Start, dbo.MO_Events.PO_End
						 , -1 * ISNULL(DATEDIFF(d, dbo.MO_Events.PO_Start, ISNULL(dbo.MO_Events.Plan_Start, CONVERT(date, GETDATE()))), 1) AS PO_Plan_Var
						 , -1 * ISNULL(DATEDIFF(d, dbo.MO_Events.PO_Start, ISNULL(dbo.MO_Events.Actual_Start, CONVERT(date, GETDATE()))), 1) AS PO_Act_Var
						 , dbo.MO_Events.Plan_Start AS Plan_Start_To
						 , md.POD_Dt
						 , dbo.Events.OutputSrc, md.POD_Dt AS From_POD, md.POD_Dt AS To_POD, bo.Plan_Qty, CONVERT(int, md.PO_Qty) - ISNULL(bo.Plan_Qty, 0) AS UnPlan_Qty,
                         DATEPART(iso_week, md.POD_Dt) AS CalWk, dbo.MO_Events.Seq_No, dbo.MO_Hdr.Prod_Month
						 */
		FROM            dbo.Events
		INNER JOIN dbo.MO_Events WITH (NoLock)
		INNER JOIN dbo.IO_Hdr
		INNER JOIN dbo.MO_Hdr ON dbo.IO_Hdr.IONo = dbo.MO_Hdr.IONo ON dbo.MO_Events.MONo = dbo.MO_Hdr.MONo ON dbo.Events.EventSeq = dbo.MO_Events.Event_Seq
		INNER JOIN
                    (SELECT        MONo, Min(CONo) AS CONo, Min(cPO_No) AS CPO_No, SUM(Qty) AS PO_Qty, MIN(POD_Dt) AS POD_Dt
                     FROM            dbo.MO_Det
                     WHERE        (Qty > 0) AND (POD_Dt IS NOT NULL)
                     GROUP BY MONo) AS md ON dbo.MO_Hdr.MONo = md.MONo
		LEFT OUTER JOIN
                     (SELECT        MONo, SUM(Plan_Qty) AS Plan_Qty
                      FROM            dbo.BO_Hdr
                      GROUP BY MONo) AS bo ON dbo.MO_Hdr.MONo = bo.MONo

		WHERE        --(dbo.IO_Hdr.Order_Type_id  <> 1)
						----AND (dbo.MOHdr.MfgLoc IN ('PHWOV', 'PHKNT'))
						--AND (dbo.MO_Hdr.MO_Status NOT IN ('Cancelled', 'Complete'))
						 (dbo.MO_Events.Active = 1)
						 --and dbo.MOEvents.POStart is not null
		ORDER BY PassType, Head
go






CREATE VIEW [dbo].[getIOLine]
AS

select ioln as ioline,a.mono from mo_det a with(index(pk_mo_det) nolock )
inner join io_det b with(index(iodet_1) nolock ) on b.iono = substring(a.mono,1,8) and b.item_no = a.item_no


go





CREATE view [dbo].[qconn_daily_summary_v3]
    as
      SELECT id, trans_date, line, a.mono, style as styleNo, color, ptno,
          ISNULL(good_qty,0) as good_qty,
          --ISNULL(good_qty,0) -  ISNULL(prev_reworked,0) as new_good_qty,
          ISNULL(reject_qty,0)  as reject_qty,
          ISNULL(reworked_qty,0) + ISNULL(prev_reworked,0)  as reworked_qty,
          ISNULL(prev_reworked,0)  as prev_reworked,
          ISNULL(repaired_qty,0) as repaired_qty,
          ISNULL(unreapairable_qty,0) as unrepairable,
          ISNULL(replaceable_qty,0) as replaceable_qty,
          ISNULL(reject_qty,0) - ISNULL(reworked_qty,0) as actual_reject_qty,
          ISNULL(good_qty,0) - (ISNULL(reworked_qty,0) + ISNULL(prev_reworked,0)) as rft_qty,
          --ISNULL(good_qty,0) - (ISNULL(reworked_qty,0)) as rft_qty,
          ISNULL(reject_qty,0) + (ISNULL(good_qty,0) - (ISNULL(reworked_qty,0) + ISNULL(prev_reworked,0))) as inspected_qty
		  --,e.ioline
		  ,ioline = stuff((select distinct ',' + convert(varchar(12),getIOLine.ioline) from getIOLine where MONo  = a.mono  for XML  PATH ('')),1,1,'')

		  ,e.custstyle
		  ,ISNULL(a.condpass_qty,0)  as condpass_qty
      from qconn_output_detail_daily_v3 a

	   -- added for column e.custStyle 8/11/2021
		inner join (select a.IONo, season,x.description as custStyle,b.mono, b.ioline from IO_Hdr a 
					left outer join m_cust_style x on x.id = a.cust_style_id
					inner join (select MONo,IONo, concat(IONO, '-', Split_No) as ioline, Prod_Type, Prod_Month from MO_Hdr) b on a.iono = b.iono ) e on a.mono = e.mono


      where good_qty > 0 or reject_qty > 0 or reworked_qty > 0 or prev_reworked > 0 or repaired_qty > 0 or
          unreapairable_qty > 0 or replaceable_qty > 0 or condpass_qty > 0


go










CREATE view [dbo].[qconn_mo_output_summary_v3]
    as
        select distinct
            id = (row_number() over (order by a.line, c.customer, b.Prod_Month, e.season, b.Prod_Type, a.mono, a.style, a.color, c.order_qty, d.allocated_qty)),
            a.line, c.customer, b.Prod_Month as plan_month, e.season, 
			--f.ioline,
			ioline = stuff((select distinct ',' + convert(varchar(12),getIOLine.ioline) from getIOLine where MONo  = a.mono  for XML  PATH ('')),1,1,''),
            b.Prod_Type as ProdType, a.mono, a.style, a.color, c.order_qty, d.allocated_qty,
            d.allocated_qty - ISNULL(sum(good_qty),0) as line_balance,
            ISNULL(sum(good_qty),0) as good_qty,
            ISNULL(sum(reject_qty),0)  as reject_qty,
            ISNULL(sum(reworked_qty),0) as reworked_qty, -- + ISNULL(sum(prev_reworked),0)
--             ISNULL(sum(repaired_qty),0) as repaired_qty,
--             ISNULL(sum(replaceable_qty),0) as replaceable_qty,
            ISNULL(sum(unreapairable_qty),0) as unrepairable_qty,
            ISNULL(sum(reject_qty),0) - ISNULL(sum(reworked_qty),0) as actual_reject_qty,
            ISNULL(sum(good_qty),0) - ISNULL(sum(reworked_qty),0) as rft_qty, -- + ISNULL(sum(prev_reworked),0)
            ISNULL(sum(good_qty),0) + (ISNULL(sum(reject_qty),0) - ISNULL(sum(reworked_qty),0)) as inspected_qty, -- + ISNULL(sum(prev_reworked),0)
            CAST( max(a.UpdatedDt) as date) as time_updated
			,c.custStyle
			,ISNULL(sum(secondquality_qty),0) as secondquality_qty
			,ISNULL(min(CASE WHEN ISNULL( lh.Replacement,0) = 1 THEN l.Qty END ),0) as replacement_qty
			,ISNULL(sum(condpass_qty),0) as condpass_qty
			,ISNULL(sum(disposed_qty),0) as disposed_qty
        from qconn_output_detail_daily_v3 a
            inner join (select MONo, IONo, concat(IONO, '-', Split_No) as ioline, Prod_Type, Prod_Month from MO_Hdr) b on a.mono = b.MONo
            inner join (select mono, customer, order_qty, custStyle from qconn_output_detail_info_v3) c on a.mono = c.MONo
            inner join (select mono, line, isnull(sum(Plan_Qty),0) as allocated_qty from BO_Hdr group by mono, line) d on a.mono = d.MONo and a.line = d.Line
            inner join (select x.IONo, x.season, y.description ascustStyle from IO_Hdr x
						left outer join m_cust_style y on y.id = x.cust_style_id) e on b.IONo = e.IONo
			INNER JOIN Laying_PT l ON l.PTNo = a.ptno
            LEFT JOIN Laying_Hdr (nolock) lh ON l.MONo = lh.MONo and l.LayNo = lh.LayNo

			--begin added by donel for ioline from iodet 09/24/2021
			--inner join (
			--			select ioln as ioline,a.mono from modet a
			--			inner join iodet b on b.iono = substring(a.mono,1,8) and b.itemno = a.itemno ) f on f.mono = a.mono
			--end
        where good_qty > 0 or reject_qty > 0 or reworked_qty > 0 or prev_reworked > 0 or repaired_qty > 0 or
            unreapairable_qty > 0 or replaceable_qty > 0 or condpass_qty > 0 or disposed_qty > 0
        group by a.line, c.customer, b.Prod_Month, e.season, b.ioline, b.Prod_Type, a.mono, a.style, c.custStyle, a.color, c.order_qty, d.allocated_qty


go








CREATE view [dbo].[qconn_progression_ticket_details_V3]
as


Select  
		id = (row_number() over (order by a.MONo, a.StyleNo, a.Color, a.PTNo, a.ProdLine, a.RFID, a.Seq,d.desc1, c.desc1)),
	  a.MONo, a.StyleNo, a.Color, a.PTNo, a.ProdLine, a.Shift, a.RFID, a.Seq,  a.CardColor,
	  a.DefectType , --= case when b.RejectType = 'REWORK' then 'REJECT' else b.RejectType end,
	  a.NewSeq, a.Status,  a.TagColor, a.RejectType, a.UserID, a.TransDt,  a.CreatedBy, a.CreatedDt,
	  a.UpdatedBy, a.UpdatedDt, a.FixedUserID, a.FixedDt
	  ,a.ioLine
	  ,a.custStyle
	--,  b.category_desc1,b.defect_type_desc1
	,d.desc1 as category_desc1, c.desc1 as defect_type_desc1
	,count(1) as 'Frequency'
	,a.remarks
	from qconn_progression_ticket_details (nolock) a
	--inner join qconn_pt_defects (nolock) b on b.ptno = a.PTNo and b.Seq = a.seq
	inner join endlineqcdet b on b.ptno = a.ptno and b.seq = a.seq
	inner join DefectTypes c on b.DefectType = c.DefectType
    inner join DefectsCat d on c.DefectCat = d.DefectCat
	where a.Status = 'reject'
	--order by a.ptno,a.seq,a.rfid,category_desc1,b.defect_type_desc1
	group by a.MONo, a.StyleNo, a.Color, a.PTNo, a.ProdLine, a.Shift, a.RFID, a.Seq,  a.CardColor
	,a.DefectType
	,a.NewSeq, a.Status,  a.TagColor, a.RejectType, a.UserID, a.TransDt,  a.CreatedBy, a.CreatedDt
	,a.UpdatedBy, a.UpdatedDt, a.FixedUserID, a.FixedDt
	,a.ioLine,a.custStyle
	--,b.category_desc1,b.defect_type_desc1
	,d.desc1, c.desc1,a.remarks


go


CREATE view [dbo].[qconn_defect_summary_header]
as
--     select row_number() over (order by SoldToCust, Season, ProdType, d.StyleNo) as id,
--            SoldToCust as customer, Season, ProdType, d.StyleNo, sum(DefectQty) as total_defect,
--            min(prod_start) as prod_start, max(prod_end) as prod_end
--     from EndLineQCDet a inner join DefectTypes b on a.DefectType=b.DefectType
--     inner join LayingPT c on a.PTNo = c.PTNo
--     inner join MODet d on c.MONo = d.MONo
--     inner join MOHdr e on d.MONo = e.MONo
--     inner join IOHdr f on e.IONo = f.IONo
--     inner join (select mono, min(ScanDt) as prod_start, max(ScanDt) as prod_end
--                 from WIPScan where VAP = 'assy-ppck' group by mono) g on e.MONo = g.MONo
--     group by SoldToCust, Season, ProdType, d.StyleNo
--     having sum(DefectQty) > 0

    select row_number() over (order by SoldToCust, f.Season, Prod_Type, d.StyleNo) as id,
           SoldToCust as customer, f.Season, Prod_Type as ProdType, d.StyleNo, d.CustStyle, sum(DefectQty) as total_defect,
           min(prod_start) as prod_start, max(prod_end) as prod_end
    from EndLineQCDet a inner join DefectTypes b on a.DefectType=b.DefectType
    inner join Laying_PT (nolock) c on a.PTNo = c.PTNo
--     inner join MODet d on c.MONo = d.MONo
--     inner join MOHdr e on d.MONo = e.MONo
    inner join MO_Hdr (nolock) e on c.MONo = e.MONo
    inner join IO_Hdr (nolock) f on e.IONo = f.IONo
    inner join (select distinct mono, Style_No as StyleNo, Cust_Style as CustStyle, Sold_To_Cust as SoldToCust from MO_Det (nolock)) d on d.MONo = e.MONo and d.StyleNo = e.Style_No
    inner join (select mono, min(ScanDt) as prod_start, max(ScanDt) as prod_end
                from WIPScan where VAP = 'assy-ppck' group by mono) g on e.MONo = g.MONo
    group by SoldToCust, f.Season, Prod_Type, d.StyleNo, d.CustStyle
    having sum(DefectQty) > 0
go


CREATE VIEW modet
AS
SELECT [id]
      ,[active]
      ,[created_by]
      ,[sbu_id]
      ,[time_created]
      ,[time_updated]
      ,[updated_by]
      ,[act_qty] as actqty
      ,[bill_to_cust] as billtocust
      ,[cm_price] as cmprice
      ,[co_remarks] as coremarks
      ,[co_status] as costatus
      ,[code]
      ,[color]
      ,[colortcsmv]
      ,[cono]
      ,[cpo_dt]
      ,[cpo_item]
      ,[cpo_no] as cpono
      ,[cust_color] as custcolor
      ,[cust_desc] as custdesc
      ,[cust_dest] as custdest
      ,[cust_size] as custsize
      ,[cust_style] as custstyle
      ,[description]
      ,[dest]
      ,[dlv_dt] as dlvdt
      ,[ex_fty_dt] as exftydt
      ,[fab_pattern] as fabpattern
      ,[garm_qty] as garmqty
      ,[item_no] as itemno
      ,[lpd_dt] as lpddt
      ,[plan_dt] as plandt
      ,[pod_dt] as poddt
      ,[priority]
      ,[psd_dt] psddt
      ,[qty]
      ,[remarks]
      ,[rs_dt]
      ,[sales_ord_type] as salesordtype
      ,[ship_mode] as shipmode
      ,[ship_to_cust] as shiptocust
      ,[size]
      ,[sold_to_cust] as soldtocust
      ,[style_no] as styleno
      ,[vsl_dt] as vsldt
      ,[webbing]
      ,[mo_id]
      ,[mono]
  FROM mo_det

go


CREATE view [dbo].[iohdr] as 
SELECT [id]
      ,[active]
      ,[created_by]
      ,[sbu_id]
      ,[time_created]
      ,[time_updated]
      ,[updated_by]
      ,[board_color] as boardcolor
      ,[code]
      ,[cust_del_dt] as custdeldt
      ,[cust_desc] as custdesc
      ,[description]
      ,[iono]
      ,[merch_smv] as merchsmv
      ,[order_qty] as orderqty
      ,[plan_smv] as plansmv
      ,[psd_dt] as psddt
      ,[remarks]
      ,[req_ex_fty_dt] as reqexftydt
      ,[src_erp] as srcerp
      ,[style_no] as styleno
      ,[tc_smv] as tcsmv
      ,[uom]
      ,[cus_grp_id]
      ,[cust_style_id]
      ,[mfg_loc_id]
      ,[order_status_id]
      ,[order_type_id]
      ,[plant_id]
      ,[prod_type_id]
      ,[sales_grp_id]
      ,[season_id]
      ,[mfg_loc] as mfgloc
      ,[cus_grp] as cusgrp
      ,[season]
  FROM io_hdr


go

create view mohdr 
as 
SELECT  [id]
      ,[active]
      ,[created_by]
      ,[sbu_id]
      ,[time_created]
      ,[time_updated]
      ,[updated_by]
      ,[sub_mat_lead] as submatlead
      ,[base_plan] as baseplan
      ,[board_color] as boardcolor
      ,[cancel_mo_dt] cancelmodt
      ,[code]
      ,[cono]
      ,[cus_del_dt] as cusdeldt
      ,[date_rerouted] as datererouted
      ,[description]
      ,[eff]
      ,[fty_loc] ftyloc
      ,[garm_part] as garmpart
      ,[iono]
      ,[learn_curve] as learncurve
      ,[lpd_dt]  as lpddt
      ,[main_mat_lead] as mainmatlead
      ,[mat_prep_lead] matpreplead
      ,[merchsmv]
      ,[mfg_loc] as mfgloc
      ,[mo_status] mostatus
      ,[mono]
      ,[parent_mono] as parentmono
      ,[plan_completed] as plancompleted
      ,[plansmv]
      ,[plant]
      ,[post_sew] as postsew
      ,[pre_sew] as presew
      ,[prod_days] as proddays
      ,[prod_min] as prodmin
      ,[prod_month] as prodmonth
      ,[prod_type] as prodtype
      ,[psd_dt] as psddt
      ,[re_routed] as rerouted
      ,[ref_auto_create_mo] as refautocreatemon
      ,[remarks]
      ,[req_ex_fty_dt] as reqexftydt
      ,[req_main_mateta] as reqmainmateta
      ,[req_mateta] as reqmateta
      ,[req_prod_start] as reqprodstart
      ,[req_sub_mateta] as reqsubmateta
      ,[rerouted_by] as reroutedby
      ,[rev_cus_del_dt] as revcustdeldt
      ,[rev_ex_fty_dt] as revexftydt
      ,[source_mono] as sourcemono
      ,[source_pono] as sourceponbo
      ,[split_no] as splitno
      ,[style_no] as styleno
      ,[tcsmv]
      ,[transit_days] as transitdays
      ,[season]
  FROM mo_hdr

go


CREATE view [dbo].[iodet] 
as 
SELECT  [id]
      ,[active]
      ,[created_by]
      ,[sbu_id]
      ,[time_created]
      ,[time_updated]
      ,[updated_by]
      ,[co_status] as costatus
      ,[code]
      ,[color]
      ,[cono]
      ,[cpo_dt] as cpodt
      ,[cpo_item] as cpoitem
      ,[cust_color] as custcolor
      ,[cust_size] as custsize
      ,[description]
      ,[dlv_dt] as dlvdt
      ,[ex_fty_dt] as exftydt
      ,[io_ln] as ioln
      ,[pod_dt] as poddt
      ,[cpo_no] as cpono
      ,[qty]
      ,[remarks]
      ,[rs_dt] as rsdt
      ,[shipped_qty] as shippedqty
      ,[size]
      ,[vsl_dt] as vsldt
      ,[dest_id]
      ,[io_id]
      ,[order_type_id]
      ,[ship_mode_id]
      ,[ship_to_cust_id]
      ,[iono] 
      ,[item_no] as itemno
      ,[cust_style] as custstyle
      ,[cust_desc] as custdesc
      ,[cust_dest] as custdest
      ,[style_no] as styleno
      ,[ship_to_cust] as shiptocust
      ,[bill_to_cust] as billtocust
      ,[sold_to_cust] as soldtocust
      ,[dest]
      ,[psd_dt] as psddt
      ,[lpd_dt] as lpddt
      ,[ship_mode] as shipmode
      ,[garm_qty] as grmqty
      ,[cm_price] as cmprice
      ,[act_qty] as actqty
      ,[webbing]
      ,[co_remarks] as coremarks
      ,[so_remarks] as soremarks
      ,[sales_ord_type] as  salesordtype
      ,[fty_del_dt] as ftydeldt
      ,[fab_pattern] as fabpattern
      --,[ioln]
  FROM io_det


go


CREATE view [dbo].[qconn_pt_defects]
as
    select a.PTNo, a.Seq, d.ProdLine as line, e.NewRFID, a.DefectQty as qty, a.Frequency,
       b.DefectCat as category_code, c.Desc1 as category_desc1, c.Desc2 as category_desc2,
       b.DefectType, b.Desc1 as defect_type_desc1, b.Desc2 as defect_type_desc2, b.Level,
       a.CreatedDt, a.CreatedBy
    from EndLineQCDet a inner join DefectTypes b on a.DefectType=b.DefectType
        inner join DefectsCat c on b.DefectCat=c.DefectCat
        inner join EndLineQCHdr d on a.PTNo=d.PTNo and a.Seq=d.Seq
        inner join EndLineQCRFID e on d.PTNo=e.PTNo and d.Seq=e.Seq
go


create view [dbo].[qconn_mo_daily_output_summary_v3]
    as
        select distinct
            id = (row_number() over (order by a.line, a.mono, convert(date, a.UpdatedDt))),
            a.line, a.mono,
            ISNULL(sum(good_qty),0) as good_qty,
            ISNULL(sum(reject_qty),0)  as reject_qty,
            ISNULL(sum(reworked_qty),0) + ISNULL(sum(prev_reworked),0) as reworked_qty,
--             ISNULL(sum(repaired_qty),0) as repaired_qty,
--             ISNULL(sum(replaceable_qty),0) as replaceable_qty,
            ISNULL(sum(unreapairable_qty),0) as unrepairable,
            ISNULL(sum(reject_qty),0) - ISNULL(sum(reworked_qty),0) - ISNULL(sum(prev_reworked),0) as actual_reject_qty,
            ISNULL(sum(good_qty),0) - ISNULL(sum(reworked_qty),0) as rft_qty, -- + ISNULL(sum(prev_reworked),0)
            ISNULL(sum(good_qty),0) + (ISNULL(sum(reject_qty),0) - ISNULL(sum(reworked_qty),0)) as inspected_qty, -- + ISNULL(sum(prev_reworked),0)
            convert(date, a.UpdatedDt) as trans_date
        from qconn_output_detail_daily_v3 a
        where good_qty > 0 or reject_qty > 0 or reworked_qty > 0 or prev_reworked > 0 or repaired_qty > 0 or
            unreapairable_qty > 0 or replaceable_qty > 0
        group by a.line, a.mono, convert(date, a.UpdatedDt)
go

CREATE view vw_ob_layingpt
AS
	select id = row_number()over(order by a.id) ,a.mono, b.bundle_no, b.id as pt_id, a.svap, a.seq, a.feature, next_check_point, 
	a.created_by, a.time_created, a.updated_by, a.time_updated, a.active, a.sbu_id, a.code, a.description
	from OB a inner join laying_pt b on a.mono = b.mono
go







CREATE VIEW [dbo].[plnDailyMOOutQtyvw]
AS

		SELECT   MIN(dbo.WIP_Scan.Scan_Dt) AS Date_Tran, dbo.WIP_Scan.MONo, dbo.m_Prod_Lines.Prod_Line, SUM(dbo.WIP_Scan.Qty) AS Output
			, cast(min(dbo.WIP_Scan.Scan_Dt) as date ) AS Group_Dt
		FROM   (SELECT        v.VAP, v.SVAP, v.GVAP, v.MONo
                FROM            dbo.MO_VAP_SVAP AS v 
				INNER JOIN dbo.m_GVAP AS gv ON v.gvap = gv.code
                WHERE        (gv.[Plan] = 1) AND (v.Load_Off = 1) 
				AND (v.Seq = (SELECT MAX(Seq) AS Expr1
								FROM dbo.MO_VAP_SVAP
								WHERE (Active = 1) AND (Load_Off = 1) AND (MONo = v.MONo) AND (GVAP = v.GVAP)))) AS MGV 
								INNER JOIN dbo.WIP_Scan (nolock) ON MGV.MONo = dbo.WIP_Scan.MONo AND MGV.VAP = dbo.WIP_Scan.VAP AND MGV.SVAP = dbo.WIP_Scan.SVAP 
								INNER JOIN dbo.m_GVAP ON MGV.GVAP = dbo.m_GVAP.code 
								LEFT OUTER JOIN dbo.m_Prod_Lines ON dbo.WIP_Scan.Work_Section = dbo.m_Prod_Lines.Prod_Line
		WHERE        (dbo.m_GVAP.[Plan] = 1)
		GROUP BY  Cast(dbo.WIP_Scan.Scan_Dt as date), dbo.WIP_Scan.MONo, dbo.m_Prod_Lines.Prod_Line
		HAVING         (dbo.m_Prod_Lines.Prod_Line IS NOT NULL)
/*
SELECT        Date_Tran, 
MONo, Prod_Line, Output--, Group_Dt
FROM            (SELECT        MIN(dbo.WIP_Scan.Scan_Dt) AS Date_Tran, dbo.WIP_Scan.MONo, dbo.m_Prod_Lines.Prod_Line, SUM(dbo.WIP_Scan.Qty) AS Output
					, cast(min(dbo.WIP_Scan.Scan_Dt) as date ) AS Group_Dt
                          FROM            
						  (SELECT        v.VAP, v.SVAP, v.GVAP, v.MONo
                                                    FROM            dbo.MO_VAP_SVAP AS v 
													INNER JOIN dbo.m_GVAP AS gv ON v.gvap = gv.code
                                                    WHERE        (gv.[Plan] = 1) AND (v.Load_Off = 1) AND (v.Seq =
                                                                                  (SELECT MAX(Seq) AS Expr1
                                                                                    FROM dbo.MO_VAP_SVAP
                                                                                    WHERE (Active = 1) AND (Load_Off = 1) AND (MONo = v.MONo) AND (GVAP = v.GVAP)))) AS MGV 
																					INNER JOIN dbo.WIP_Scan (nolock) ON MGV.MONo = dbo.WIP_Scan.MONo AND MGV.VAP = dbo.WIP_Scan.VAP AND MGV.SVAP = dbo.WIP_Scan.SVAP 
																					INNER JOIN dbo.m_GVAP ON MGV.GVAP = dbo.m_GVAP.code 
																					LEFT OUTER JOIN dbo.m_Prod_Lines ON dbo.WIP_Scan.Work_Section = dbo.m_Prod_Lines.Prod_Line
											WHERE        (dbo.m_GVAP.[Plan] = 1)
											GROUP BY  Cast(dbo.WIP_Scan.Scan_Dt as date), dbo.WIP_Scan.MONo, dbo.m_Prod_Lines.Prod_Line
											HAVING         (dbo.m_Prod_Lines.Prod_Line IS NOT NULL)
				UNION ALL
                          SELECT        MIN(o.Output_Dt) AS Date_Tran, o.MONo, o.Prod_Line, SUM(o.Qty) AS Qty, o.Output_Dt AS Group_Dt
                          FROM  dbo.WIP_Sub_Con AS o 
						  INNER JOIN dbo.MO_Hdr AS h ON o.MONo = h.MONo
                          WHERE        (h.Mfg_Loc IN
                                                       (SELECT        Mfg_Loc
                                                         FROM            dbo.m_Mfg_Locs AS MfgLocs_1
                                                         WHERE        (Level_No = 2)))
                          GROUP BY o.MONo, o.Prod_Line, o.Output_Dt
                        UNION ALL
                          SELECT        MIN(o.Output_Dt) AS Date_Tran, h.MONo, o.Prod_Line, SUM(o.Qty) AS Qty, o.Output_Dt AS Group_Dt
                          FROM            dbo.WIP_Output AS o INNER JOIN
                                                   (Select distinct h.Mfg_Loc, h.MONo, d.CONo from dbo.MO_Det d inner join dbo.MO_Hdr h on d.MONo = h.MONo) AS h ON o.CONo = h.CONo
                          WHERE        (h.Mfg_Loc IN
                                                       (SELECT        Mfg_Loc
                                                         FROM            dbo.m_Mfg_Locs AS MfgLocs_1
                                                         WHERE        (Level_No = 2)))
                          GROUP BY h.MONo, o.Prod_Line, o.Output_Dt
					UNION ALL
                          SELECT        MIN(o.Output_Dt) AS Date_Tran, h.MONo, o.Prod_Line, SUM(o.Qty) AS Qty, o.Output_Dt AS Group_Dt
                          FROM            dbo.Prod_Line_Output AS o INNER JOIN
                                                   dbo.MO_Hdr AS h ON o.MONo = h.MONo
                          WHERE        (h.Mfg_Loc IN
                                                       (SELECT        Mfg_Loc
                                                         FROM            dbo.m_Mfg_Locs AS MfgLocs_1
                                                         WHERE        (Level_No = 2)))
                          GROUP BY h.MONo, o.Prod_Line, o.Output_Dt
                        UNION ALL
                          SELECT        MIN(o.Output_Dt) AS Date_Tran, o.MONo, h.Mfg_Loc, SUM(o.Qty) AS Qty, MIN(o.Output_Dt) AS Group_Dt
                          FROM            dbo.WIP_Sub_Con AS o INNER JOIN
                                                   dbo.MO_Hdr AS h ON o.MONo = h.MONo
                          WHERE        (h.Mfg_Loc IN
                                                       (SELECT        Mfg_Loc
                                                         FROM            dbo.m_Mfg_Locs AS MfgLocs_1
                                                         WHERE        (Level_No = 2)))

                          GROUP BY o.MONo, h.Mfg_Loc) AS x

*/





go



CREATE VIEW [dbo].[plnBOHdrvw]
AS
SELECT        MONo, BONo, Line, Plan_Start, Count(Line) OVER (PARTITION BY MONo, Line) AS Multi_Line
FROM            dbo.BO_Hdr


go

CREATE view vw_orders
AS
	select * from fg_purchase_order a
go



CREATE VIEW [dbo].[plnDailyMOBOMultiLnOutvw]
AS
SELECT o.Date_Tran, o.MONo, o.Prod_Line, o.Output
FROM  dbo.plnDailyMOOutQtyvw AS o 
INNER JOIN (SELECT DISTINCT MONo, Line
            FROM            dbo.plnBOHdrvw
            WHERE        (Multi_Line > 1)) AS bo ON o.MONo = bo.MONo AND o.Prod_Line = bo.Line


go



CREATE VIEW [dbo].[plnDailyMOBOOutQtyvw]
AS
SELECT o.Date_Tran, o.MONo, p.BONo, o.Prod_Line, o.Output
FROM  dbo.plnDailyMOOutQtyvw AS o 
inner JOIN dbo.plnBOHdrvw AS p ON o.MONo = p.MONo AND o.Prod_Line = p.Line
WHERE (p.Multi_Line = 1)


go

CREATE view vw_inventory_by_po_pl
AS
--- INVENTORY Per PO
SELECT 
	id = row_number()over(order by pono, split_no),
	A.*
FROM (
		select a.pono, a.iono, a.style_code, a.colors, a.factory, a.buyer,
			 isnull(b.split_no,0) as split_no, b.ship_date, b.asn_no, b.booking_no, b.ship_to, b.ship_mode,

			 order_qty = sum(c.carton_qty),
			 total_cartons = count(c.carton_no),

			 fg_received_qty = sum(case when warehouse_rcv = 1 then c.carton_qty else 0 end),
			 fg_received_cartons = sum(case when warehouse_rcv = 1 then 1 else 0 end),

			 fg_issued_qty = sum(case when warehouse_iss = 1 then c.carton_qty else 0 end),
			 fg_issued_cartons = sum(case when warehouse_iss = 1 then 1 else 0 end),

			 available_qty =  sum(case when warehouse_rcv = 1 then c.carton_qty else 0 end) - sum(case when warehouse_iss = 1 then c.carton_qty else 0 end),
			 available_cartons = sum(case when warehouse_rcv = 1 then 1 else 0 end) - sum(case when warehouse_iss = 1 then 1 else 0 end),
			 pl_status = '',
			 a.sbu_id,
			 a.active
		from fg_purchase_order a
		inner join fg_purchase_order_dtl b on a.id = b.purchase_order_id
		inner join fg_carton c on c.purchase_order_dtl_id = b.id
		--WHERE c.in_stock = 1
		GROUP BY
			a.pono, a.iono, a.style_code, a.colors, a.factory, a.buyer,
			 b.split_no, b.asn_no, b.booking_no, b.ship_date, b.ship_to, b.ship_mode, a.sbu_id,a.active
) A
go

CREATE view vw_inventory_by_carton
AS
--- INVENTORY Per PO
SELECT
	id = row_number()over(order by pono, split_no),
	A.*
FROM (
		select a.pono, a.iono, a.style_code, a.colors, a.factory, a.buyer,
			 isnull(b.split_no,0) as split_no, b.ship_date, b.asn_no, b.booking_no, b.ship_to, b.ship_mode,

			 carton_no, ucc_barcode,
			 order_qty = sum(c.carton_qty),
			 total_cartons = count(c.carton_no),

			 fg_received_qty = sum(case when warehouse_rcv = 1 then c.carton_qty else 0 end),
			 fg_received_cartons = sum(case when warehouse_rcv = 1 then 1 else 0 end),

			 fg_issued_qty = sum(case when warehouse_iss = 1 then c.carton_qty else 0 end),
			 fg_issued_cartons = sum(case when warehouse_iss = 1 then 1 else 0 end),

			 available_qty =  sum(case when warehouse_rcv = 1 then c.carton_qty else 0 end) - sum(case when warehouse_iss = 1 then c.carton_qty else 0 end),
			 available_cartons = sum(case when warehouse_rcv = 1 then 1 else 0 end) - sum(case when warehouse_iss = 1 then 1 else 0 end),
			 pl_status = '',
			 a.sbu_id,
			 a.active
		from fg_purchase_order a
		inner join fg_purchase_order_dtl b on a.id = b.purchase_order_id
		inner join fg_carton c on c.purchase_order_dtl_id = b.id
		--WHERE pono = 'PO20Q3FN00311'
		GROUP BY
			a.pono, a.iono, a.style_code, a.colors, a.factory, a.buyer, carton_no, ucc_barcode,
			 b.split_no, b.asn_no, b.booking_no, b.ship_date, b.ship_to, b.ship_mode, a.sbu_id,a.active
) A
go

CREATE view vw_inventory_by_carton_size
AS
--- INVENTORY Per PO
SELECT
	id = row_number()over(order by pono, split_no),
	A.*
FROM (
		select a.pono, a.iono, a.style_code, a.colors, a.factory, a.buyer,
			 isnull(b.split_no,0) as split_no, b.ship_date, b.asn_no, b.booking_no, b.ship_to, b.ship_mode,
			 carton_no, ucc_barcode,
			 d.size, d.color,
			 order_qty =  (select sum(carton_qty) from fg_carton with(nolock) where purchase_order_dtl_id = b.id ),
			 qty = sum(d.qty),
			 carton_qty = sum(c.carton_qty),
			 total_cartons = count(c.carton_no),

			 fg_received_qty = sum(case when warehouse_rcv = 1 then c.carton_qty else 0 end),
			 fg_received_cartons = sum(case when warehouse_rcv = 1 then 1 else 0 end),

			 fg_issued_qty = sum(case when warehouse_iss = 1 then c.carton_qty else 0 end),
			 fg_issued_cartons = sum(case when warehouse_iss = 1 then 1 else 0 end),

			 available_qty =  sum(case when warehouse_rcv = 1 then c.carton_qty else 0 end) - sum(case when warehouse_iss = 1 then c.carton_qty else 0 end),
			 available_cartons = sum(case when warehouse_rcv = 1 then 1 else 0 end) - sum(case when warehouse_iss = 1 then 1 else 0 end),
			 pl_status = '',
			 a.sbu_id,
			 a.active
		FROM fg_purchase_order a
		inner join fg_purchase_order_dtl b on a.id = b.purchase_order_id
		inner join fg_carton c on c.purchase_order_dtl_id = b.id
		inner join fg_carton_allocation d on d.carton_id = c.id
		--WHERE pono = 'MAY162022-0' --'PO20Q3FN00311'
		GROUP BY
			a.pono, a.iono, a.style_code, a.colors, a.factory, a.buyer, carton_no, ucc_barcode, d.size, d.color,
			 b.split_no, b.asn_no, b.booking_no, b.ship_date, b.ship_to, b.ship_mode, a.sbu_id,a.active,  b.id
) A
go

CREATE View vw_mo_svap_bundle_status
as
    SELECT
        a.sbu_id,
        a.mo_id,
        a.mono,
        d.bundle_no AS bundle_no,
        a.svap AS svap,
        a.next_check_point,
        f.seq,
        f.vap,
        d.qty,
        CASE
            WHEN SUM(d.qty - COALESCE(e.output_qty, 0)) > 0 THEN 0
            ELSE 1
        END AS output_complete,
        CASE
            WHEN d.qty - COALESCE(g.issued_qty, 0) > 0 THEN 0
            ELSE 1
        END AS issuance_complete,
        CASE
            WHEN d.qty - COALESCE(g.received_qty, 0) > 0 THEN 0
            ELSE 1
        END AS next_check_point_received_complete
    FROM Ob a
    INNER JOIN mo_hdr b ON a.mo_id = b.id
    INNER JOIN laying_hdr c ON b.mono = c.mono
    INNER JOIN laying_pt d ON d.mono = c.mono
    INNER JOIN mo_vap_svap f ON a.mo_id = f.mo_id AND a.svap + '-' + a.next_check_point = f.vap
    LEFT JOIN wip_workers_output e ON a.mo_id = e.mo_id AND a.id = e.ob_id AND a.svap = e.svap and e.bundle_no = d.bundle_no
    LEFT JOIN wip_scan_part g ON g.mo_id = a.mo_id AND e.id = g.output_id -- OUTPUT
    WHERE
        a.sbu_id = 1
        AND a.active = 1
        AND f.svap ='ISS'
        --AND a.svap = 'INK1' AND a.next_check_point = 'COM'
        --AND a.mono = '15260501006'
        --and a.svap = 'SKI'
    GROUP BY
        a.sbu_id, a.mo_id, a.mono, a.next_check_point, d.bundle_no, a.svap, f.vap,
        d.qty, g.issued_qty, g.received_qty, f.seq
go

CREATE view prdMOOutputExceededForm
as
select id = row_number()over(order by a.MONo),
  a.sbu_id, a.MONo, a.BONo, a.Line, coalesce(a.Plan_Qty,0) as Plan_Qty, coalesce(b.Output_Qty,0) as Output_Qty,( coalesce(a.plan_qty,0) - coalesce(b.output_qty,0) ) as Balance
from bo_hdr a
left outer join (select sbu_id, mono, bono, line, sum(qty) as output_qty from bo_daily_output group by sbu_id, mono, bono, line ) b on b.sbu_id = a.sbu_id and b.mono = a.mono and b.bono = a.bono and b.line = a.line
where ( coalesce(a.plan_qty,0) - coalesce(b.output_qty,0) ) < 0
go

CREATE view [dbo].[qconn_progression_ticket_details]
as

select top 10 
    id = (row_number() over (order by d.MONo, d.StyleNo, b.Color, b.PTNo, b.ProdLine, b.NewRFID, b.Seq)),
    d.MONo, d.StyleNo, d.Color, b.PTNo, b.ProdLine, 'D' as Shift, b.NewRFID as RFID, b.Seq, b.Color as CardColor,
    DefectType = case when b.RejectType = 'REWORK' then 'REJECT' else b.RejectType end,
    b.NewSeq, b.Status, b.Color as TagColor, b.RejectType, b.UserID, b.TransDt, b.UserID as CreatedBy, b.TransDt as CreatedDt,
    b.UserID as UpdatedBy, b.FixedDt as UpdatedDt--, b.FixedUserID, b.FixedDt
	, case when b.FixedUserID is not NULL then b.FixedUserID  else b.ConvertToShipUserID end as FixedUserID 
	, case when b.FixedDt is not NULL then b.FixedDt else b.ConvertToShipDt end as FixedDt
	--,b.FixedUserID
	--,b.FixedDt
	,d.ioLine
	,d.custStyle
	,b.remarks
from EndlineQCRFID b (nolock)
inner join Laying_PT c (nolock) on b.PTNo = c.PTNo
-- inner join view_mo_all d (nolock) on c.MONo = d.mono
inner join
    (select hdr.MONo, hdr.Style_No as StyleNo, dtl.Cust_Color as Color, concat(hdr.IONO, '-', hdr.Split_No) as ioLine, a.custStyle from MO_Hdr (nolock) hdr
        inner join (select distinct MONo, Cust_Color from MO_Det (nolock) where (Sales_Ord_Type <> 'CS' or Sales_Ord_Type is null) and Qty > 0) dtl on hdr.MONo = dtl.MONo

		-- added for column d.custStyle 8/11/2021
		left outer join (select IONo,y.description as CustStyle from IO_Hdr x left outer join m_cust_Style y on y.id = x.cust_style_id ) a on a.iono = hdr.iono

    ) d on c.MONo = d.mono

go

CREATE VIEW [dbo].[vw_mo_details]
AS
  select a.id as mo_id, b.id , a.mfg_loc,a.iono,a.mono,b.cono, b.cpo_no as 'customer_pono', b.sales_ord_type as so_type, a.prod_month as 'plan_month'
		,b.style_no ,b.cust_style as 'customer_style'
		,a.season
		, b.color, b.color as color_description
		,a.plansmv as plan_sah
		,a.tcsmv, b.dlv_dt as delivery_date
		,isnull(b.dest,'') as destination, a.req_ex_fty_dt, b.ex_fty_dt, b.qty
		,0 as shipped_qty, '' as allow_over_ship, b.co_status
		,isnull(b.remarks,'') as co_remarks,a.mo_status,isnull(a.remarks,'') as remarks,
		b.sbu_id, b.created_by, b.time_created, b.updated_by, b.time_updated, b.active, b.code,
		with_icut_output = 0 -- default for now
	from mo_hdr a
	inner join mo_det b on b.mono = a.mono
go

CREATE PROCEDURE usp_recalculate_lines_and_save
--declare
		@recId VARCHAR(50) ='',
		@mfgLoc VARCHAR(20) ='',
		@line VARCHAR(20) = '',
		@monox VARCHAR(20) ='',
		@currentDate VARCHAR(50) = '',
		@numDate INT = 6,
		@userID NVARCHAR(100) = ''
AS
/*
SET @recId = '65451468-3bbf-4f40-8180-ec0ba6bc7f7f'
SET @line = 'L03'
SET @mfgLoc = 'TARLAC'
SET @currentDate = '2023-08-09'
SET @numDate = 88
SET @userId = 'admin'
SET @monox =  ''
--*/
/*
This script is written in T-SQL, the language used to interact with Microsoft SQL Server databases. The script starts by declaring a number of variables that are used throughout the script.

It then performs the following steps:

    Deletes any existing records in the BOHdrRecalc and BOLearnCurveRecalc tables that have the same RecID as the value assigned to the @RecId variable.

    Creates two temporary tables, @HdrTmp and @MOTmp, that store data from the BOHdr and BODailyOutput tables.

    Loops through the number of dates specified by the @NumDate variable and does the following for each iteration:
    a. Selects the values for a single record from the @MOTmp table.
    b. Checks if there is an existing record in the @HdrTmp table that has the same Line, MO and BO values.
    c. If there is a record, it updates the BOQty value. If there is no matching record, it creates a new BO number.
    d. Subtracts the BOQty value from the PlanQty value in the @HdrTmp table.
    e. Decrements the @RowNum variable.

The script seems to be used to recalculate the BO values based on daily output. However, without access to the underlying data and the complete context of the script, it is difficult to say for certain what the script is doing or what its purpose is.
*/

/*DECLARE @RecId VARCHAR(50), @MfgLoc VARCHAR(20), @Line VARCHAR(20), @CurrentDate VARCHAR(50), @NumDate INT, @UserID NVARCHAR(100)
SET @RecId = '2E5BE0B8-A97B-4270-B5B3-B1F2C2180375' --SELECT newid()
SET @MfgLoc = 'TARLAC'
SET @Line = @Line
SET @CurrentDate = '2/24/2023 12:00:00 AM'
SET @NumDate = 6
SET @UserID = 'eduard'*/

-- INITIALIZE, VARIABLE DECLARATION
-- INSERT INTO BOTimestamp VALUES(@MfgLoc,'Recalc Start - ' + @Line + ' - ' + @RecId,@UserID,getdate())

DECLARE @DateNum INT, @RowNum INT, @Date DATETIME, @Num INT, @TransDt DATETIME
DECLARE @MONo VARCHAR(20), @BONo VARCHAR(20), @Qty INT, @BOQty INT, @EffCount INT
DECLARE @NewBONo VARCHAR(20), @NewPlanQty INT, @NewPlanStart DATETIME, @NewPlanFinish DATETIME
DECLARE @MOQty INT, @RecalcQty INT

DECLARE @Today DATE
SET @Today = CAST(@CurrentDate as date)

------------------------------------------------------------------------------------------------------------------
	---- *** Step 1. THIS BLOCK WILL CREATE BACK DATES BOs BASED ON OUTPUT, AND UPDATE THE EXISTING PLAN = PLAN - OUTPUT
------------------------------------------------------------------------------------------------------------------
---- CREATE TEMP TABLE BOHdr TO SUBTRACT DAILY OUTPUT QTY
	DECLARE @HdrTmp TABLE (Ln VARCHAR(20), MO VARCHAR(20), BO VARCHAR(20), Qty INT, OrigPlanQty INT)
	INSERT INTO @HdrTmp
	SELECT B.Line, B.MONo, B.BONo, B.Plan_Qty, b.Plan_Qty as OrigPlanQty
	FROM BO_Hdr B INNER JOIN mo_hdr M on B.MONo = M.MONo
	WHERE B.Line = @Line and B.Plan_Qty > 0 AND M.plan_completed = 0 --AND DATEADD(dd, DATEDIFF(dd, 0, [PlanFinish]), 0) >= @Today - @NumDate
	--test here
	--SELECT * FROM @HdrTmp

---- CREATE TEMP TABLE TO STORE MO WITH **OUTPUT** FROM THE DATE RANGE
	DECLARE @MOTmp TABLE (Num INT, MO VARCHAR(20), BO VARCHAR(20), Ln VARCHAR(20), Dt DATETIME, Qty INT)
	INSERT INTO @MOTmp
	SELECT ROW_NUMBER() OVER(ORDER BY [Date]) AS Number, D.MONo, D.BONo, D.Line, D.[Date], D.Qty
	FROM BO_Daily_Output D
		INNER JOIN BO_Hdr H on D.MONo = H.MONo and D.BONo = H.BONo and D.Line = H.Line
		INNER JOIN mo_hdr M on H.MONo = M.MONo
	WHERE D.Line = @Line and D.Qty > 0
		AND DATEADD(dd, DATEDIFF(dd, 0, D.[Date]), 0) >= getdate() - @NumDate
		AND M.plan_completed = 0
		and D.Line = @Line
		and d.MONo = case when @monox = '' then d.MONo else @monox end
	--SELECT * FROM @MOTmp


	SELECT TOP 1 @Num = Num FROM @MOTmp ORDER BY Num
	SELECT @RowNum = Count(*) FROM @MOTmp
	SET @DateNum = @NumDate

	---- DELETE IF EXISTING BOHdrRecalc/BOLearnCurveRecalc RECID
	DELETE FROM bo_hdr_recalculate WHERE rec_id = @RecId
	DELETE FROM bo_learn_curve_recalculate WHERE rec_id = @RecId

	DECLARE  @prevPlanQty int
	DECLARE  @prevBono int

	---- LOOP FOR NUMBER OF AFFECTED DATES
	WHILE @RowNum > 0
	BEGIN
		--print @Today - @DateNum
		SELECT @MONo = MO, @BONo = BO, @Qty = Qty, @Date = Dt FROM @MOTmp WHERE Num = @Num

		SELECT @prevPlanQty = OrigPlanQty, @prevBono = BO FROM @HdrTmp WHERE Ln = @Line and MO = @MONo and BO = @BONo

		SET @BOQty = @Qty

		---- CHECK IF THERE IS EXISTING BO WITH SAME QTY, ELSE CREATE A NEW BO NUMBER
		IF EXISTS(SELECT 'x' FROM @HdrTmp WHERE Ln = @Line and MO = @MONo and BO = @BONo ) --and Qty <= @Qty)
		BEGIN
			--print 'exists'
			SELECT TOP 1 @NewBONo = BO FROM @HdrTmp WHERE Ln = @Line and MO = @MONo and BO = @BONo --and Qty <= @Qty

			---- IF OUTPUT QTY IS BIGGER THAN ORDER QTY, REVISE @BOQty EQUAL TO ORDER QTY
			IF((SELECT ISNULL(SUM(Qty),0) FROM @HdrTmp WHERE Ln = @Line and MO = @MONo and BO = @BONo) < @Qty)
			BEGIN
				SELECT @BOQty = ISNULL(SUM(Qty),0) FROM @HdrTmp WHERE Ln = @Line and MO = @MONo and BO = @BONo
			END
		END

		ELSE
		BEGIN
			--print 'not exists'
			SELECT TOP 1 @NewBONo = bono + 1 FROM bo_hdr WHERE MONo = @MONo ORDER BY CAST(BONo AS INT) DESC
			--print 'BOHdr: ' + @NewBONo
      -- IF data already exist in BOHdrRecalc then assign new NewBONo -- CHECK HERE. REMOVE Aug 1, 2023
			/*WHILE EXISTS(SELECT 'x' FROM bo_hdr_recalculate WHERE MONo = @MONo and BONo = @NewBONo and rec_id = @RecId)
			BEGIN
				SELECT TOP 1 @NewBONo = BONo + 1 FROM bo_hdr_recalculate WHERE MONo = @MONo and rec_id = @RecId ORDER BY CAST(BONo AS INT) DESC
				--print 'BOHdrRecalc: ' + @NewBONo
			END*/
		END
		--print @NewBONo

    --SELECT Num = @Num, RowNum = @RowNum, @MONo as MO, @BONo as BO, Line = @Line, @Qty as Qty, @Date as Date, @NewBONo as NewBONo, @BOQty as BOQty, 'x' as here, @NewPlanStart as NewPlanStart , @NewPlanFinish as NewPlanFinish
		EXEC [prdRecalcBoDateSP] @MONO, @DATE, @PLANSTART = @NewPlanStart output, @PLANFINISH = @NewPlanFinish output

		IF(@NewPlanStart IS NOT NULL AND @NewPlanFinish IS NOT NULL)
		BEGIN
			----- GET NUMBER OF OUTPUT DAYS FROM EARLIER SAME MO AND LINE
			SELECT @EffCount = count('x') FROM BO_Daily_Output WHERE Line = @Line and MONo = @MONo and BONo = @BONo and DATEADD(dd, DATEDIFF(dd, 0, [Date]), 0) < DATEADD(dd, DATEDIFF(dd, 0, @Date), 0)

			SET @TransDt = getdate()
			IF EXISTS(SELECT 'x' FROM bo_hdr_recalculate WHERE Rec_ID = @RecId and Trans_Dt = @TransDt)
			BEGIN
				SET @TransDt = DATEADD(SS, 1, @TransDt)
			END

			----TO AVOID DUPLICATE BONo
			WHILE EXISTS(SELECT 'x' FROM bo_hdr_recalculate WHERE MONo = @MONo and BONo = @NewBONo and Rec_ID = @RecId)
			BEGIN
				SELECT TOP 1 @NewBONo = BONo + 1 FROM bo_hdr_recalculate WHERE MONo = @MONo and Rec_ID = @RecId ORDER BY CAST(BONo AS INT) DESC

        WHILE EXISTS(SELECT 'x' FROM bo_hdr WHERE MONo = @MONo and BONo = @NewBONo )
        BEGIN
            SET @NewBONo = @NewBONo + 1
        END
			END

			INSERT INTO bo_hdr_recalculate(Rec_ID, MONo, BONo, CP_No, Mfg_Loc, Line, Plan_Qty, SMV, Eff, Plan_Start, Plan_Finish,
																		 MO_Qty, MO_Cus_Del_Dt, Time_Created, Completed_Remarks, total_output_qty, Trans_Dt,
																		 Created_By, Eff_count, Prd_Typ, Prd_Typ2, Prod_Month, Plant_Color, sbu_id, active, prev_bono,
																		 prev_plan_qty, step_no)
			SELECT TOP 1 @RecId, MONo, @NewBONo, CP_No, @MfgLoc, Line, @BOQty, SMV,
			(case when cast(@BONo as int) > 999 then '999' else @BONo end),
			@NewPlanStart, @NewPlanFinish, MO_Qty, MO_Cus_Del_Dt, Time_Created, Completed_Remarks, @Qty, @TransDt, @UserID, @EffCount,
				Prd_Typ, Prd_Typ2, Prod_Month, Plant_Color, sbu_id, active, @prevBono, @prevPlanQty, '1'
			FROM BO_Hdr WHERE MONo = @MONo and Line = @Line

			INSERT INTO bo_learn_curve_recalculate(rec_id,MONo,BONo, Mfg_Loc, Line,Learn_Curve,Interval,period_01,period_02,period_03,period_04,period_05,period_06,period_07,period_08,period_09,period_10,
																						 period_11,period_12,period_13,period_14,period_15, period_16,period_17,period_18,period_19,period_20,period_21,period_22,period_23,period_24,
																						 period_25,period_26,period_27,period_28,period_29,period_30,Created_By,Time_Created,Updated_By,Time_Updated,Trans_Dt) --TransBy
			SELECT TOP 1 @RecId,MONo,@NewBONo, @MfgLoc, Line,Learn_Curve,Interval,period_01,period_02,period_03,period_04,period_05,period_06,period_07,period_08,period_09,period_10,period_11,period_12,period_13,period_14,period_15,
				period_16,period_17,period_18,period_19,period_20,period_21,period_22,period_23,period_24,period_25,period_26,period_27,period_28,period_29,period_30,@UserID,@TransDt,Updated_By,Time_Updated,@TransDt
			FROM BO_Learn_Curve WHERE MONo = @MONo and BONo = @BONo and Line = @Line

			---- UPDATE/SUBTRACT PLANQTY
			UPDATE @HdrTmp SET Qty = (CASE WHEN Qty - @Qty < 0 THEN 0 ELSE Qty - @Qty END) WHERE Ln = @Line and MO = @MONo and BO = @BONo

		END

		---- GET NEXT MO
		SELECT TOP 1 @Num = Num FROM @MOTmp WHERE Num > @Num ORDER BY Num
		SET @RowNum = @RowNum - 1
	END


/*-------------------------------------------------------------------------------------------------------------------------------------
Step 2.
STEP 2. add plan for the balance to the CURRENT DATE
1. GET the total daily output where date is previous per Line = @Line and MONo = @MONo and BONo = @BONo
2. GET the total plan qty per Line = @Line and MONo = @MONo and BONo = @BONo
3. IF(@ReclacQty < @ActiveQty)
		IF (total daily output < the planQty) THEN ADD A NEW PLAN TO THE CURRENT DATE
---------------------------------------------------------------------------------------------------------------------------------------*/
-- 	DECLARE #DOTmp TABLE (Num INT, MO VARCHAR(20), BO VARCHAR(20), Ln VARCHAR(20), Qty INT)

	IF OBJECT_ID(N'TEMPDB..#DOTmp') IS NOT NULL DROP TABLE #DOTmp
	IF OBJECT_ID(N'TEMPDB..#BOTmp') IS NOT NULL DROP TABLE #BOTmp

	--INSERT DAILY OUTPUT TO TEMP

	SELECT ROW_NUMBER() OVER(ORDER BY [Date]) AS Num, MONo, BONo, Line, Qty
	INTO #DOTmp
	FROM
	(
		--GET THE LIST OF MO WHERE OUTPUT IS GREATER THAN THE PLAN
		SELECT D.MONo, D.BONo, D.Line, SUM(D.Qty) as Qty, MIN([Date]) as [Date]
		FROM BO_Daily_Output D
			INNER JOIN BO_Hdr H on D.MONo = H.MONo and D.BONo = H.BONo and D.Line = H.Line
			INNER JOIN mo_hdr M on H.MONo = M.MONo
		WHERE D.Line = @Line and D.Qty > 0
			AND DATEADD(dd, DATEDIFF(dd, 0, D.[Date]), 0) >= getdate() - @NumDate
			--AND DATEADD(dd, DATEDIFF(dd, 0, D.[Date]), 0) < @Today
			AND M.Plan_Completed = 0
			--and d.MONo = '11151901001' and D.BONo = '1'
		GROUP BY D.MONo, D.BONo, D.Line
	) A

	---- GET NUMBER OF MO WITH OUTPUT ON A SPECIFIC DATE
	SELECT TOP 1 @Num = Num FROM #DOTmp ORDER BY Num
	SELECT @RowNum = Count(*) FROM #DOTmp
	DECLARE @PreviousOutputQty INT, @PlannedQty INT, @OtherQty INT, @Balance int

	-- LOOP FOR EACH MO
	WHILE @RowNum > 0
	BEGIN
		--print @Num
		SELECT @MONo = MONO, @BONo = BONO FROM #DOTmp WHERE Num = @Num
		--print @MONo

		---- GET TOTAL QTY OF BODailyOutput where date is previous
		SELECT @PreviousOutputQty = ISNULL(SUM(Qty),0) FROM BO_Daily_Output WHERE Line = @Line and MONo = @MONo and BONo = @BONo and DATEADD(dd, DATEDIFF(dd, 0, [Date]), 0) < @Today
		--print @ReclacQty

		---- GET TOTAL QTY OF MO STARTING DATE TODAY
		-- IF planQty in BO_HDR is less than MO QTY THEN GET BO_HDR planQty else get MODET qty + prdMOExcessCutQtyvw
		SELECT @PlannedQty = CASE WHEN (SELECT ISNULL(SUM(Plan_Qty),0) FROM BO_Hdr WHERE Line = @Line and MONo = @MONo and BONo = @BONo) <
																	((SELECT ISNULL(SUM(Qty),0) FROM mo_det WHERE MONo = @MONo)+(SELECT ISNULL(SUM(Excess_qty),0) FROM prdMOExcessCutQtyvw WHERE MONo = @MONo))
													THEN (SELECT ISNULL(SUM(Plan_Qty),0) FROM BO_Hdr WHERE Line = @Line and MONo = @MONo and BONo = @BONo)
												ELSE ((SELECT ISNULL(SUM(Qty),0) FROM MO_Det WHERE MONo = @MONo)+(SELECT ISNULL(SUM(Excess_qty),0) FROM prdMOExcessCutQtyvw WHERE MONo = @MONo))
												END
		--print @ActiveQty
		--test here
		--select @PreviousOutputQty as PreviousOutputQty,  @PlannedQty as PlannedQty

		-- IF DAILY OUTPUT FROM PREVIOUS DAY IS LESS THAN THE PLAN QTY
		IF(@PreviousOutputQty < @PlannedQty)
		BEGIN

			SET @Balance = @PlannedQty - @PreviousOutputQty

			---- SET BONo
			SET @NewBONo = @BONo
			WHILE EXISTS(SELECT 'x' FROM bo_hdr_recalculate WHERE MONo = @MONo and BONo = @NewBONo and rec_id = @RecId)
			BEGIN
				SELECT TOP 1 @NewBONo = BONo + 1 FROM bo_hdr_recalculate WHERE MONo = @MONo and rec_id = @RecId ORDER BY CAST(BONo AS INT) DESC
			END

			--added Aug 1
			WHILE EXISTS(SELECT 'x' FROM bo_hdr WHERE MONo = @MONo and BONo = @NewBONo )
			BEGIN
				SELECT TOP 1 @NewBONo = BONo + 1 FROM bo_hdr WHERE MONo = @MONo ORDER BY CAST(BONo AS INT) DESC
			END

			----- GET BODailyOutput WHERE (DATE > TODAY)
			SELECT @Qty = ISNULL(SUM(Qty),0) FROM BO_Daily_Output WHERE Line = @Line and MONo = @MONo and DATEADD(dd, DATEDIFF(dd, 0, [Date]), 0) >= @Today
			--SELECT  * FROM BODailyOutput WHERE Line = @Line and MONo = '11151901001' and DATEADD(dd, DATEDIFF(dd, 0, [Date]), 0) >= '2023-02-09 08:37:00.000'

			----- GET NUMBER OF OUTPUT DAYS FROM EARLIER SAME MO AND LINE
			SELECT @EffCount = count('x') FROM BO_Daily_Output WHERE Line = @Line and MONo = @MONo and DATEADD(dd, DATEDIFF(dd, 0, [Date]), 0) < @Today
			--SELECT * FROM BODailyOutput WHERE Line = @Line and MONo = '11151901001' and DATEADD(dd, DATEDIFF(dd, 0, [Date]), 0) < '2023-02-09 08:37:00.000'


			SET @TransDt = getdate()
			IF EXISTS(SELECT 'x' FROM bo_hdr_recalculate WHERE rec_id = @RecId and Trans_Dt = @TransDt)
			BEGIN
				SET @TransDt = DATEADD(SS, 1, @TransDt)
			END

			--Test here
			--select @PreviousOutputQty as OutputPrev , @PlannedQty as Planned, @BONo as BOno, @NewBONo as NewBONo, 'here' as 'here', @MONo as mono, @Line as Line, @RecId as RecId,  @Today as Today, @Qty  as Qty, @EffCount as EffCount

			-- FINAL ASSIGN NEW BONO. Aug 8, 2023
			WHILE EXISTS(SELECT 'x' FROM bo_hdr_recalculate WHERE Rec_ID = @RecId and  MONo = @MONo and BONo = @NewBONo )
			BEGIN
				SELECT TOP 1 @NewBONo = BONo + 1 FROM bo_hdr_recalculate WHERE Rec_ID = @RecId and  MONo = @MONo ORDER BY CAST(BONo AS INT) DESC
			END

			WHILE EXISTS(SELECT 'x' FROM bo_hdr_recalculate WHERE Rec_ID = @RecId and  MONo = @MONo and BONo = @NewBONo )
			BEGIN
				SELECT TOP 1 @NewBONo = BONo + 1 FROM bo_hdr  WHERE MONo = @MONo ORDER BY CAST(BONo AS INT) DESC
			END

			INSERT INTO bo_hdr_recalculate(rec_id, MONo, BONo, CP_No, Mfg_Loc, Line, Plan_Qty, SMV, Eff, Plan_Start, Plan_Finish, MO_Qty, MO_Cus_Del_Dt, Created_By,
																		 Time_Created, Completed_Remarks, total_output_qty, Trans_Dt, eff_count,Prd_Typ, Prd_Typ2, Prod_Month, Plant_Color, sbu_id, active,
																		next_bono, next_plan_qty,  step_no, prev_bono, prev_plan_qty
			)
			SELECT TOP 1 @RecId as RecId, MONo, @NewBONo as NewBONo, CP_No, Mfg_Loc, Line,  @Balance as Balance, SMV, 0 as Eff, dateadd(minute, 450,  cast ( CAST( @Today as date) as  datetime )) as PlanStart,  dateadd(minute, 450,  cast ( CAST( @Today as date) as  datetime )) as PlanFinish,
				MO_Qty, MO_Cus_Del_Dt,  @UserID as UserID, Time_Created, Completed_Remarks, @Qty as OutputQty, @TransDt as TransDt, @EffCount as EffCount, Prd_Typ, Prd_Typ2, Prod_Month, Plant_Color,sbu_id, active,
								@NewBONo, @Balance,  '2', @BONo, @PlannedQty
			FROM BO_Hdr
			WHERE MONo = @MONo and Line = @Line

			INSERT INTO bo_learn_curve_recalculate(rec_id,MONo,BONo, Mfg_Loc, Line,Learn_Curve,Interval,period_01,period_02,period_03,period_04,period_05,period_06,period_07,period_08,period_09,period_10,
																						 period_11,period_12,period_13,period_14,period_15, period_16,period_17,period_18,period_19,period_20,period_21,period_22,period_23,period_24,
																						 period_25,period_26,period_27,period_28,period_29,period_30,Created_By,Time_Created,Updated_By,Time_Updated,Trans_Dt) --TransBy
			SELECT TOP 1 @RecId,MONo,@NewBONo, @MfgLoc, Line,Learn_Curve,Interval,period_01,period_02,period_03,period_04,period_05,period_06,period_07,period_08,period_09,period_10,period_11,period_12,period_13,period_14,period_15,
				period_16,period_17,period_18,period_19,period_20,period_21,period_22,period_23,period_24,period_25,period_26,period_27,period_28,period_29,period_30,@UserID,@TransDt,Updated_By,Time_Updated,@TransDt
			FROM BO_Learn_Curve WHERE MONo = @MONo and BONo = @NewBONo and Line = @Line

		END

		---- GET NEXT MO
		SELECT TOP 1 @Num = Num FROM #DOTmp WHERE Num > @Num ORDER BY Num
		SET @RowNum = @RowNum - 1
	END

/*
	select * from bo_hdr_recalculate where MONo = '15162101001'
	select * from BO_Hdr where MONo = '15162101001' and Line = @Line
*/

---------------------------------------------------------------------------------------------------------------------------------------
---- *** STEP 3.
---- *** THIS BLOCK WILL REPLAN BOs NOT AFFECTED BY OUTPUT
---------------------------------------------------------------------------------------------------------------------------------------

	---- INSERT INTO TEMP TABLE LIST OF MO THAT WAS NOT AFFECTED BY Recalc
	-- BO vs Output. where MO BO LINE with NO OUTPUT EXCLUDED

	SELECT DISTINCT ROW_NUMBER() OVER(ORDER BY B.Plan_Start, B.Plan_Finish) AS Num, B.MONo, B.BONo, B.Plan_Start
	INTO #BOTmp
	FROM BO_Hdr B
		LEFT OUTER JOIN #DOTmp D on B.Line = D.Line and B.MONo = D.MONo and B.BONo = D.BONo
		INNER JOIN mo_hdr M on B.MONo = M.MONo
	WHERE B.Line = @Line
			AND D.MONO IS NULL --and DATEADD(dd, DATEDIFF(dd, 0, [PlanFinish]), 0) >= @Today - @NumDate
			AND M.Plan_Completed = 0

		DROP TABLE #DOTmp

---- GET FIRST MO NOT AFFECTED BY Recalc
	SELECT TOP 1 @Num = Num FROM #BOTmp ORDER BY Num
	SELECT @RowNum = Count(*) FROM #BOTmp

	DECLARE @PlanQty INT

-- LOOP FOR EACH MO
	WHILE @RowNum > 0
	BEGIN
		--print @Date
		SELECT @MONo = MONO, @BONo = BONO, @Date = Plan_Start FROM #BOTmp WHERE Num = @Num
		--print @MONo

		--SELECT TOP 1 @NewBONo = BONo FROM BOHdr WHERE Line = @Line and MONo = @MONo and PlanStart = @Date
		SET @NewBONo = @BONo
		--print @NewBONo

		----- GET ONLY CURRENT DATED OUTPUT IF ANY FOR NON AFFECTED BO
		SELECT @Qty = ISNULL(SUM(Qty),0) FROM BO_Daily_Output WHERE Line = @Line and MONo = @MONo and BONo = @NewBONo and DATEADD(dd, DATEDIFF(dd, 0, [Date]), 0) >= @Today

		SELECT @PlanQty = CASE
											WHEN (SELECT ISNULL(SUM(plan_qty),0) FROM BO_Hdr WHERE MONo = @MONo and BONo = @NewBONo and Line = @Line and Plan_Start = @Date) <
																((SELECT ISNULL(SUM(Qty),0) FROM mo_det WHERE MONo = @MONo)+(SELECT ISNULL(SUM(Excess_qty),0) FROM prdMOExcessCutQtyvw WHERE MONo = @MONo))
												THEN (SELECT ISNULL(SUM(plan_qty),0) FROM BO_Hdr WHERE MONo = @MONo and BONo = @NewBONo and Line = @Line and Plan_Start = @Date)
											ELSE ((SELECT ISNULL(SUM(Qty),0) FROM mo_det WHERE MONo = @MONo)+(SELECT ISNULL(SUM(Excess_qty),0) FROM prdMOExcessCutQtyvw WHERE MONo = @MONo))
											END

		SELECT @MOQty = ((SELECT ISNULL(SUM(Qty),0) FROM mo_det WHERE MONo = @MONo)+(SELECT ISNULL(SUM(Excess_qty),0) FROM prdMOExcessCutQtyvw WHERE MONo = @MONo))

		SELECT @RecalcQty = ISNULL(SUM(plan_qty),0) FROM bo_hdr_recalculate WHERE Rec_ID = @Recid and MONo = @MONo


		IF (@PlanQty + @RecalcQty > @MOQty)
		BEGIN
			SET @PlanQty = @MOQty - @RecalcQty
		END

		IF(@PlanQty > 0)
		BEGIN
			SET @TransDt = getdate()
			IF EXISTS(SELECT 'x' FROM bo_hdr_recalculate WHERE Rec_ID = @RecId and Trans_Dt = @TransDt)
			BEGIN
				SET @TransDt = DATEADD(SS, 1, @TransDt)
			END

			---select (SELECT TOP 1 convert(date,Plan_Start) FROM #BOTmp WHERE convert(date,Plan_Start) = convert(date,@Date) ) as Date , convert(date,@Today) as today
			--SELECT 'x' FROM bo_hdr WHERE MONo = @MONo and BONo = @NewBONo
			-- FINAL ASSIGN NEW BONO. Aug 8, 2023
			WHILE EXISTS(SELECT 'x' FROM bo_hdr_recalculate WHERE Rec_ID = @RecId and  MONo = @MONo and BONo = @NewBONo )
			BEGIN
				SELECT TOP 1 @NewBONo = BONo + 1 FROM bo_hdr_recalculate WHERE Rec_ID = @RecId and  MONo = @MONo ORDER BY CAST(BONo AS INT) DESC
			END

			WHILE EXISTS(SELECT 'x' FROM bo_hdr_recalculate WHERE Rec_ID = @RecId and  MONo = @MONo and BONo = @NewBONo )
			BEGIN
				SELECT TOP 1 @NewBONo = BONo + 1 FROM bo_hdr  WHERE MONo = @MONo ORDER BY CAST(BONo AS INT) DESC
			END

			---- CHECK IF NON AFFECTED BO IS BACK DATED THEN MOVE TO CURRENT DATE
			IF((SELECT TOP 1 Plan_Start FROM #BOTmp WHERE convert(date,Plan_Start) = convert(date,@Date) ) < convert(date,@Today))
			BEGIN
				print 'back dated'
				INSERT INTO bo_hdr_recalculate(rec_id, MONo, BONo, CP_No, Mfg_Loc, Line, Plan_Qty, SMV, Eff, Plan_Start, Plan_Finish, MO_Qty, MO_Cus_Del_Dt,
																			 Created_By, Time_Created, Completed_Remarks, total_output_qty, Trans_Dt, eff_count, Prd_Typ, Prd_Typ2, Prod_Month, Plant_Color,
																			 sbu_id, active, step_no
				)
				SELECT TOP 1 @RecId as RecId, MONo, @NewBONo as NewBONo, CP_No, Mfg_Loc, Line,  @PlanQty , SMV, 0 as Eff, @Today as PlanStart, @Today as PlanFinish,
				MO_Qty, MO_Cus_Del_Dt,  @UserID as UserID, Time_Created, Completed_Remarks, @Qty as OutputQty, @TransDt as TransDt, -1 as EffCount, Prd_Typ, Prd_Typ2, Prod_Month, Plant_Color,
																			sbu_id, active, '3'
			FROM BO_Hdr
			WHERE MONo = @MONo and BONo = @NewBONo and Line = @Line and Plan_Start = @Date
			END
			ELSE
			BEGIN
				print 'not back dated' + ' ' + @MONo
				INSERT INTO bo_hdr_recalculate(rec_id, MONo, BONo, CP_No, Mfg_Loc, Line, Plan_Qty, SMV, Eff, Plan_Start, Plan_Finish, MO_Qty, MO_Cus_Del_Dt,
																			 Created_By, Time_Created, Completed_Remarks, total_output_qty, Trans_Dt, eff_count, Prd_Typ, Prd_Typ2, Prod_Month, Plant_Color,
																			sbu_id, active, step_no
				)
				SELECT TOP 1 @RecId, MONo, @NewBONo, CP_No, Mfg_Loc, Line, @PlanQty, SMV, 0, Plan_Start, Plan_Finish, MO_Qty, MO_Cus_Del_Dt, @UserID,
																			Time_Created, Completed_Remarks, @Qty, @TransDt, -1, Prd_Typ, Prd_Typ2, Prod_Month, Plant_Color,
																			sbu_id, active, '4'
					FROM BO_Hdr WHERE MONo = @MONo and BONo = @NewBONo and Line = @Line and Plan_Start = @Date
			END

			/*INSERT INTO bo_learn_curve_recalculate(rec_id,MONo,BONo, Mfg_Loc, Line,Learn_Curve,Interval,period_01,period_02,period_03,period_04,period_05,period_06,period_07,period_08,period_09,period_10,
																						 period_11,period_12,period_13,period_14,period_15, period_16,period_17,period_18,period_19,period_20,period_21,period_22,period_23,period_24,
																						 period_25,period_26,period_27,period_28,period_29,period_30,Created_By,Time_Created,Updated_By,Time_Updated,Trans_Dt) --TransBy
			SELECT TOP 1 @RecId,MONo,@NewBONo, @MfgLoc, Line,Learn_Curve,Interval,period_01,period_02,period_03,period_04,period_05,period_06,period_07,period_08,period_09,period_10,period_11,period_12,period_13,period_14,period_15,
				period_16,period_17,period_18,period_19,period_20,period_21,period_22,period_23,period_24,period_25,period_26,period_27,period_28,period_29,period_30,@UserID,@TransDt,Updated_By,Time_Updated,@TransDt
			FROM BO_Learn_Curve WHERE MONo = @MONo and BONo = @NewBONo and Line = @Line*/

		END

		---- GET NEXT MO
		SELECT TOP 1 @Num = Num FROM #BOTmp WHERE Num > @Num ORDER BY Num
		SET @RowNum = @RowNum - 1
	END


---------------------------------------------------------------------------------------------------------------------------------------
---- *** STEP 4.
---- *** COMBINE THE BONO OF THE SAME MONO ON THE CURRENT DATE
---------------------------------------------------------------------------------------------------------------------------------------
-- DECLARE CURRENT START DATE
declare @StartDateTime datetime
declare @StartDate date

SELECT @StartDateTime =  CONVERT(DATETIME, CONVERT(VARCHAR, GETDATE(), 101) + ' 07:30:00', 120), @StartDate = getdate()

update bo_hdr_recalculate set active = 0 where rec_id in ( @recId ) and convert(date,Plan_Start) = @StartDate and step_no != '5'

DELETE FROM bo_hdr_recalculate where rec_id in ( @recId) and step_no = '5'
INSERT INTO bo_hdr_recalculate(MONo,  BONo, Mfg_Loc, Line,  Plan_Qty, SMV, Plan_Start, Plan_Finish, Prd_Typ, MO_Qty, MO_Cus_Del_Dt, rec_id,
   Prod_Month, sbu_id, step_no, Created_By, Time_Created, active, re_order_seq
)
select MONo, min(BONo) as BONo, Mfg_Loc, Line, sum(case when step_no  IN ('','1') then 0 else Plan_Qty end)   as Plan_Qty, SMV, Plan_Start = @StartDateTime, Plan_Finish = @StartDateTime, Prd_Typ, MO_Qty, MO_Cus_Del_Dt, rec_id,
Prod_Month, sbu_id, step_no = 5, 'System', getdate(), active = 1, row_number()over(order by MONo) as  re_order_seq
from bo_hdr_recalculate where rec_id in ( @recId )  and convert(date,Plan_Start) = @StartDate
group by MONo,  Mfg_Loc, Line, SMV,   Prd_Typ, MO_Qty, MO_Cus_Del_Dt,Prod_Month, sbu_id, rec_id


--RETURN THE COMPARISON
select id=row_number()over(order by Plan_Start), a.*, locked_by = ''
from (
	select   mono, bono, mfg_loc, building_code ='', line_cd = Line, cp_no, plan_qty, smv, eff, plan_start, plan_finish,
            actual_start, actual_finish, plant_color, board_color = '', prd_typ_cd = Prd_Typ, prd_type2_cd =Prd_Typ, total_output_qty,
            prod_month, completed, created_by, time_created, time_updated, cus_del_dt = MO_Cus_Del_Dt , Trans_Id = @recId, Updated_By
	from bo_hdr_recalculate a
	where line = @line and rec_id = @recId and active = 1
	union ALL
	select   	mono, bono, mfg_loc, building_code ='', line_cd = Line, cp_no, plan_qty, smv, eff, plan_start, plan_finish,
            actual_start, actual_finish, plant_color, board_color ='', prd_typ_cd = Prd_Typ, prd_type2_cd = Prd_Typ2, total_output_qty,
            prod_month, completed, created_by, time_created, time_updated, cus_del_dt = MO_Cus_Del_Dt , Trans_Id, Updated_By
	from bo_hdr a
	where line = @line
	and not exists(select 1 from bo_hdr_recalculate bb where bb.mono = a.mono and bb.line = a.line and bb.bono = a.bono and bb.rec_id = @recId )
) a
go

CREATE procedure usp_mo_split_merge
--declare
	@process VARCHAR(10),       -->  merge,split
	@moId bigint,
	@moDet VARCHAR(1000),
	@username varchar(30) = 'admin',
	@showId BIT = 1
AS

/*set @process =''
set @moId  = '111672'
set @moDet = '121347'
set @username = 'admin'
set @showId = 1*/

SET NOCOUNT ON
    DECLARE @mono varchar(30), @iono varchar(30)
    DECLARE @monoMX INT = 0, @ConoCount INT
    DECLARE @currentMOId BIGINT, @newMono varchar(30)

    select @mono = mono from mo_hdr where id = @moId

    update mo_det set mo_id = @moId, mono= @mono 
    where id in (
            SELECT CAST(splitdata as bigint) as moDetId
            FROM fnSplitString(@moDet,',')
    )

--REMOVE FIRST
/*
    PRINT 'GET MONO, IONO base on Det.ids'
    SELECT DISTINCT TOP 1 @iono = mh.iono, @mono = mh.mono, @currentMOId = a.mo_id
    from mo_det a
        INNER JOIN mo_hdr mh ON a.mo_id = mh.id
    WHERE  a.id in (
            SELECT CAST(splitdata as bigint) as moDetId
            FROM fnSplitString(@moDet,',')
            )
    AND mh.active = 1



        IF @moId IS NULL    --> NEW MONO
        BEGIN
            SELECT @monoMX = MAX( CAST( RIGHT(mono,3) as int) )
            FROM mo_hdr
            where iono = @iono -- AND active  = 1
            GROUP BY iono

            SET @newMono = SUBSTRING(@mono,1, LEN(@mono)-3 ) + RIGHT('000' + CAST(@monoMX+1 as varchar(100)),3)

            -- create new base on currennt selected det
            INSERT INTO mo_hdr(active, mono, created_by, sbu_id, time_created, time_updated, updated_by, sub_mat_lead,
                               base_plan, board_color, cancel_mo_dt, code, cono, cus_del_dt, date_rerouted,
                               description, eff, fty_loc, garm_part, iono, learn_curve, lpd_dt, main_mat_lead,
                               mat_prep_lead, merchsmv, mfg_loc, mo_status, parent_mono, plan_completed,
                               plansmv, plant, post_sew, pre_sew, prod_days, prod_min, prod_month, prod_type,
                               psd_dt, re_routed, ref_auto_create_mo, remarks, req_ex_fty_dt, req_main_mateta,
                               req_mateta, req_prod_start, req_sub_mateta, rerouted_by, rev_cus_del_dt, rev_ex_fty_dt,
                               source_mono, source_pono, split_no, style_no, tcsmv, transit_days)
            SELECT 1 as  active, @newMono, @username as created_by, sbu_id, getdate()  as time_created, time_updated, updated_by, sub_mat_lead,
                               base_plan, board_color, cancel_mo_dt, code, '' as cono, cus_del_dt, date_rerouted,
                               description, eff, fty_loc, garm_part, iono, learn_curve, lpd_dt, main_mat_lead,
                               mat_prep_lead, merchsmv, mfg_loc, mo_status, parent_mono, plan_completed,
                               plansmv, plant, post_sew, pre_sew, prod_days, prod_min, prod_month, prod_type,
                               psd_dt, re_routed, ref_auto_create_mo, '' as remarks, req_ex_fty_dt, req_main_mateta,
                               req_mateta, req_prod_start, req_sub_mateta, rerouted_by, rev_cus_del_dt, rev_ex_fty_dt,
                               source_mono, source_pono, split_no, style_no, tcsmv, transit_days
            FROM mo_hdr
            WHERE id = @currentMOId

            SET @moId = @@identity

        END ELSE    --> Selected MO
        BEGIN
            SET @newMono =  @mono
        END

        Update a SET
            mono = @newMono, mo_id = @moId
        from mo_det a
            INNER JOIN mo_hdr mh ON a.mo_id = mh.id
        WHERE mh.iono = @iono --> making sure its on the same IOno
              AND a.id in (
                SELECT CAST(splitdata as bigint) as moDetId
                FROM fnSplitString(@moDet,',')
                )

        UPDATE a SET cono = CASE WHEN c.dCtr = 1 THEN b.cono WHEN c.dCtr > 1 THEN '' ELSE '' END,
            active = CASE WHEN c.dCtr >= 1 THEN 1 ELSE 0 END
        /*SELECT a.id, a.mono, a.active, a.cono,
            CASE WHEN c.dCtr = 1 THEN b.cono WHEN c.dCtr > 1 THEN '' ELSE '' END as cono,
            CASE WHEN c.dCtr >= 1 THEN 1 ELSE 0 END as active,
            '-->', b.cono, c.**/
        FROM mo_hdr a
            LEFT JOIN mo_det b ON a.id = b.mo_id
            LEFT JOIN (
                SELECT a.id, SUM(CASE WHEN b.id IS NOT NULL THEN 1 ELSE 0 END ) as dCtr
                FROM mo_hdr a
                    LEFT JOIN mo_det b ON a.id = b.mo_id
                WHERE a.iono = @iono
                GROUP BY a.id
            ) c ON c.id = a.id
        WHERE a.iono = @iono

        /*SELECT @ConoCount = COUNT(1)
        FROM mo_det
        WHERE mo_id = @moId

        IF @ConoCount = 1
        BEGIN
            UPDATE a SET cono = b.cono, active = 1
            FROM mo_hdr a
                INNER JOIN mo_det b ON a.id = b.mo_id
            WHERE a.id = @moId
        END ELSE IF @ConoCount > 1
        BEGIN
            UPDATE mo_hdr SET cono = '', active = 1,  updated_by = @username, time_updated = getdate()
            WHERE id = @moId
        END
        BEGIN
            UPDATE a
                SET cono = b.cono, active = 1
            FROM mo_hdr a
                INNER JOIN mo_det b ON a.id = b.mo_id
            WHERE a.id = @moId
        END*/

*/
    if @showId = 1
        SELECT @moId as id
go

CREATE procedure usp_copy_calendar
  @fromId int = 0,
  @toId int = 0,
  @toYear varchar(4) = 2024
AS

--   declare
--   @fromId int = 2,
--   @toId int = 3

declare
  @fromYear varchar(4)
  --@toYear varchar(4)

select top 1 @fromYear = year(date_from) from m_calendar_exception  where calendar_id = @fromId



DECLARE @calendarDetTmp TABLE (num int, active bit, sbu_id int, code varchar(20), date_from datetime, date_to datetime,
  date_year varchar(4), ex_name nvarchar(100), has_work bit, calendar_id int)
INSERT INTO @calendarDetTmp
select num =row_number()over(order by date_from), active, sbu_id, code,
    date_from  =  convert(datetime, replace(date_from, @fromYear, @toYear)),
    date_to    =  convert(datetime, replace(date_to, @fromYear, @toYear)),
    date_year = @toYear, ex_name, has_work,
    calendar_id = @toId
from m_calendar_exception
where date_year = @fromYear

declare @Num int, @RowNum int, @holidayDate datetime
SET @Num = 1
SELECT @RowNum = Count(*) FROM @calendarDetTmp

WHILE (@Num <= @RowNum)
BEGIN
    select @holidayDate = date_from from @calendarDetTmp where num = @Num
    IF NOT EXISTS(select 1 from m_calendar_exception where date_from = @holidayDate )
      begin
          INSERT INTO m_calendar_exception(active, created_by, sbu_id, time_created, code, date_from, date_to, date_year,  ex_name, has_work, calendar_id)
          select active, created_by = 'System', sbu_id, time_created = getdate(), code, date_from, date_to, date_year,  ex_name, has_work, calendar_id
          FROM @calendarDetTmp
      END
  SET @Num = @Num + 1
END

select code ='success', description = 'success'
go





-- =============================================
-- Author:		CAE
-- Create date: 03262015
-- Description:	Sync IO 
-- EXEC [dbo].[ordSyncIO] 'system'
-- Select * from MfgLocs select * from SourceERP
-- =============================================
CREATE PROCEDURE [dbo].[stg_ordSyncIO]
	-- Add the parameters for the stored procedure here
--	@SrcERP		varchar(10),
--	@PlantCd	varchar(10),
	@UserId		NVARCHAR(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRY

	DECLARE @RecId AS varchar(100)
	
	Set @RecId = NEWID()


	INSERT INTO [dbo].[stg_SyncLog]([Recid],[RunTime],[CreatedBy],[Remarks])
     VALUES(@RecId, getdate(), @UserId, 'ordSynIO - Initialization.')

	--if exists(select SrcERP from SourceERP Where SrcERP = 'GO') 
	--BEGIN
	--	EXEC [dbo].[ordSyncGOProdType] @UserId
	--END

	--if exists(select SrcERP from SourceERP Where SrcERP = 'YT') 
	--BEGIN
	--	EXEC [dbo].[ordSyncYTProdType] @UserId
	--END

	--If exists(Select 'X' from ProdTypeDesc Where isnull(ProdType,'') = '')
	--	BEGIN
	--		Update dbo.SyncLog set Remarks = 'ordSynIO - New Prod Type Definition found..Please assign Prod Type first before Sync IO continue...'
	--			,TimeFinish = getdate() 
	--			Where RecId = @RecId
	--		SELECT 1 AS ERROR_CODE, 'New Prod Type Definition found from ERP. Please assign Prod Type before Sync IO...' AS ERROR_MSG
	--	END
	--else
		BEGIN
			delete from stg_SyncCMPrice
			delete from stg_SyncCustGrp
			delete from stg_SyncCustomer
			delete from stg_SyncIOSMV
			--delete from stg_SyncIO
			delete from io_sync
			delete from stg_SyncPlant
			delete from stg_SyncPOETD
			delete from stg_SyncProdOut
			delete from stg_SyncSalesGrp
			delete from stg_SyncVendor
			delete from stg_SyncCF
	
			--if exists(select SrcERP from SourceERP Where SrcERP = 'YT') 
			--	BEGIN
			--		EXECUTE [dbo].[ordSyncYTData] @UserId
			--	END
			--if exists(select SrcERP from SourceERP Where SrcERP = 'GO') 
			--	BEGIN
			--		EXECUTE [dbo].[ordSyncGOData] @UserId
			--	END
			--if exists(select SrcERP from SourceERP Where SrcERP = 'DT') 
			--	BEGIN
			--		EXECUTE [dbo].[ordSyncDTData] @UserId
			--	END

			--if exists(select SrcERP from stg_SourceERP Where SrcERP = 'DL') 
			--	BEGIN
					EXECUTE [dbo].[stg_ordSyncDLData] @UserId
			--	END

			EXECUTE [dbo].[stg_ordSyncIMAPPS] @UserId

			

			--EXECUTE [dbo].[ordSyncMO_ByIO] @UserId
			EXECUTE [dbo].[stg_ordSyncMO_ByCONo] @UserId
			--EXECUTE [dbo].[stg_ordSyncMO_ByDelDt] @UserId

			--EXECUTE [dbo].[ordSyncMO_VERTE] @UserId

			--if exists(select SrcERP from SourceERP Where SrcERP = 'YT') 
			--	BEGIN
			--		EXECUTE [dbo].ordSyncMO @UserId

			--		UPDATE dbo.StyleImage SET [Filename] = Z.Attachment
			--		FROM (select Style_id, min('AD/STYLE_BOM/'+Attachment) as Attachment from Link_YTISRV.aCT.dbo.iplexsty_style_parm  where isnull(Attachment,'') <> ''
			--				group by Style_id) AS Z INNER JOIN
			--			dbo.StyleImage ON Z.Style_Id = dbo.StyleImage.StyleNo 
			--		WHERE isnull(Z.Attachment,'') <> isnull(dbo.StyleImage.[Filename],'')

			--		--select Style_id, season_id, t0, Attachment from [Link_YTISRV].[aCT].[dbo].iplexsty_style_parm
			--	END

			--if exists(select SrcERP from SourceERP Where SrcERP = 'GO') 
			--	BEGIN
			--		UPDATE dbo.StyleImage SET [Filename] = Z.Attachment
			--		FROM Link_GOSRV.iplex_uasdb01.dbo.Style_PARM AS Z INNER JOIN
			--			dbo.StyleImage ON Z.Style_Code = dbo.StyleImage.StyleNo 
			--		WHERE isnull(Z.Attachment,'') <> isnull(dbo.StyleImage.[Filename],'')
			--	END

			Update dbo.stg_SyncLog set Remarks = 'ordSynIO - Completed.', TimeFinish = getdate() Where RecId = @RecId
			SELECT 0 AS ERROR_CODE, 'Synchronization Completed.' AS ERROR_MSG
		END

	END TRY
	
	BEGIN CATCH
		IF (@@TRANCOUNT > 0)
		--SELECT 1 AS ERROR_MSG
			--SELECT ERROR_MESSAGE() AS ERROR_MSG
			Update dbo.stg_SyncLog set Remarks = left('ordSynIO - ' + ERROR_MESSAGE(),2000) Where Recid = @RecId
			SELECT 1 AS ERROR_CODE, ERROR_MESSAGE() AS ERROR_MSG
			--ROLLBACK TRANSACTION	
	END CATCH	
	
END


go

--exec stg_ordSyncMO_ByCONo 'ab'
--select * from mo_hdr

CREATE  PROCEDURE [dbo].[stg_ordSyncMO_ByCONo]
	--[dbo].[ordSyncMO_ByCONo] 'system'
	-- Add the parameters for the stored procedure here
--	@SrcERP		varchar(10),
--	@PlantCd	varchar(10),
	@UserId		NVARCHAR(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	
	SET NOCOUNT ON;

	--Declare @UserId as nvarchar(50)
	--Set @UserId = 'conrad'

	BEGIN TRY

	DECLARE @RecId AS varchar(100)
	DECLARE @CheckpointTemplate varchar(100)
	
	Select top 1 @CheckpointTemplate = Template_ID from VAPSVAP_Template_Hdr Where isnull(Deleted,0) = 0 and Template_ID in (Select Template_ID from VAPSVAP_Template_Det)
	--and Default_CP = 1
	
	Set @RecId = NEWID()

	INSERT INTO [dbo].[stg_SyncLog]([Recid],[RunTime],[CreatedBy],[Remarks])
     VALUES(@RecId, getdate(), @UserId, 'ordSyncMO_ByCONo - Initialize.')

		--Insert StyleImage
		INSERT INTO [dbo].[Style_Image]
           ([Style_No])
		SELECT DISTINCT sIO.Style_No
		FROM (Select distinct b.IONo, b.Style_No, b.Cust_Desc from IO_Det a inner join IO_Hdr b on b.id = a.io_id ) AS sIO 
		LEFT OUTER JOIN dbo.Style_Image AS sh ON sIO.Style_No = sh.Style_No
		WHERE (sh.Style_No IS NULL)


		--For Testing
		--Select distinct top 1 iod.IONo into #IOs from IODet iod with (nolock) 
		--		Left outer join MOHdr mh with (nolock) ON iod.IONo = mh.IONo
		--	 Where 
		--	 mh.IONo is null
		--	 and iod.IONo = '11530801'
		--	 --and iod.PODDT between '5/1/2019' and '5/5/2019' 
		--	 and iod.Qty > 0

		--For Prod
		Select distinct ioh.IONo into #IOs from IO_Hdr ioh with (nolock) inner join IO_Det iod with (nolock) on ioh.IONo = iod.IONo
				Left outer join MO_Det md with (nolock) ON iod.Item_No = md.Item_No
			 Where 
			 md.Item_No is null
			 --and ioh.CreatedDt >= '5/1/2019' 
			 and iod.Qty > 0
			 and 'CONo' = (Select top 1 Split_Type from Cust_Grp_Split_Config 
									Where Mfg_Loc = ioh.Mfg_Loc
									and Cust_Grp = ioh.Cus_Grp 
									and ioh.Time_Created between Effective_Dt and dateadd(second, -1, dateadd(day, 1, isnull(To_Dt, convert(date,getdate()))))
						  ) --(Select top 1 SplitType from CustGrpSplitConfig Where MfgLoc = ioh.MfgLoc and CustGrp = ioh.CusGrp and EffectiveDt <= ioh.CreatedDt)
 

		---Insert New MOHdr for New IO or CO
		INSERT INTO [dbo].[MO_Hdr]
		([sbu_id],[plan_completed],[re_routed],[MONo],[IONo],[Split_No],[Plant],[Mfg_Loc],[Style_No],[Prod_Type],[MO_Status],[Board_Color]--,[LPDDt]
		,[PSD_Dt],[Cus_Del_Dt],[Rev_Cus_Del_Dt],[Transit_Days],[Req_Ex_Fty_Dt],[Prod_Days],[Req_Prod_Start],[Mat_Prep_Lead],[Main_Mat_Lead]
		--,[ReqMatETA]
		,[Req_Main_MatETA],[Sub_Mat_Lead],[Req_Sub_MatETA],[Eff],[Prod_Min],[MerchSMV],[TcSMV],[PlanSMV],[Pre_Sew]
		,[Post_Sew],[Remarks]--,[LevelNo],[End_State]
		,[Active],[Created_By],[Time_Created],[CONo],[Prod_Month],[Rev_Ex_Fty_Dt],[Ref_Auto_Create_MO], season)

		Select 1,0,0,x.IONo + right('00'+cast(row_number() over (partition by x.IONo order by x.IONo) + isnull(s.MaxSplitNo,0) AS varchar(3)),3) AS MONo, 
		x.IONo, row_number() over (partition by x.IONo order by x.IONo) + isnull(s.MaxSplitNo,0) AS SplitNo, ioh.Plant_id,ioh.Mfg_Loc_id, ioh.Style_No
		, (select top 1 code from m_prod_type where id = ioh.Prod_Type_id)
		, 'Created', ioh.Board_Color--, ioh.LPDDt
		,ioh.PSD_Dt,ioh.Cust_Del_Dt AS CusDelDt,ioh.Cust_Del_Dt as RevCusDelDt,ot.Transit_Days,dateadd(d,-1*ot.Transit_Days,ioh.Cust_Del_Dt) AS ReqExFtyDt, ot.Prod_Days, 
		dateadd(d,-1*(ot.Transit_Days+ot.Prod_Days),ioh.Cust_Del_Dt) AS ReqProdStart, ot.Mat_Prep_Lead, ot.Main_Mat_Lead,
		--dateadd(d,-1*(ot.Transit_Days+ot.Prod_Days+ot.Mat_Prep_Lead),ioh.Cust_Del_Dt) AS ReqMatETA,
		dateadd(d,-1*(ot.Transit_Days+ot.Prod_Days+ot.Mat_Prep_Lead+ot.Main_Mat_Lead),ioh.Cust_Del_Dt) AS ReqMainMatETA,
		ot.Sub_Mat_Lead, dateadd(d,-1*(ot.Transit_Days+ot.Prod_Days+ot.Sub_Mat_Lead),ioh.Cust_Del_Dt) AS ReqSubMatETA, 0 As Eff, 0 As ProdMin, ioh.Merch_SMV, ioh.Tc_SMV, isnull(sty.SMV,ioh.Plan_SMV) as PlanSMV, 0 AS PreSew,
		0 As PostSew, ioh.Remarks--, 1 as LevelNo, 1 AS EndState
		, 1 As Active, @UserId AS CreatedBy, getdate() As CreatedDt, x.CONo, cast(cast(month(x.PODDt) AS varchar) + '/1/' + cast(year(x.PODDt) as varchar) as datetime) AS PlanMonth
		,isnull(x.ExFtyDt, x.PODDt),x.PODDt
		,ioh.season
		From (
				SELECT /*DISTINCT*/ dbo.IO_HDR.IONo, dbo.IO_Det.CONo, min(dbo.IO_Det.POD_Dt) as PODDt, min(dbo.IO_Det.Ex_Fty_Dt) as ExFtyDt
				FROM dbo.IO_Det INNER JOIN dbo.IO_Hdr ON dbo.IO_Det.IO_id = dbo.IO_Hdr.id 
						LEFT OUTER JOIN (
										Select h.IONo, d.CONo from dbo.MO_Hdr h with (nolock) inner join dbo.MO_Det d with (nolock) on h.id = d.mo_id--on h.MONo = d.MONo 
										Where --h.LevelNo = 1 and 
										h.IONo in (Select IONo from #IOs)
										Group By h.IONo, d.CONo
										)  mhd
								ON dbo.IO_Det.IO_id = mhd.IONo and dbo.IO_Det.CONo = mhd.CONo
				WHERE (mhd.IONo IS NULL) 
				and dbo.IO_Det.Qty > 0
				--GROUP BY dbo.IO_Det.IONo, dbo.IO_Det.CONo
				GROUP BY dbo.IO_Hdr.IONo, dbo.IO_Det.CONo
			 ) x 
			 inner join IO_Hdr ioh on x.IONo = ioh.IONo 
			 inner join m_Order_Types ot on ioh.Order_Type_id = ot.id 
			 left outer join (Select IONo, Max(Split_No) as MaxSplitNo from MO_Hdr group by IONo) s on x.IONo = s.IONo
			 outer apply (Select SMV from Style_Analysis_Hdr with (nolock) Where Style = ioh.Style_No) sty 
		Where 
		--x.IONo = '10047701'	
		x.IONo in (Select IONo from #IOs)	
		
			
		--Insert MODet for No MODet yet
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByCONo - Insert MO Details to New MO.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MO_Det]
		([sbu_id],[MO_id],[mono],[Item_No],[CPO_No],[CPO_Item],[CPO_Dt],[Cust_Style],[Cust_Desc],[Cust_Color],[Cust_Size],[Cust_Dest],[Ship_To_Cust]
		,[Style_No],[Color],[Size],[Dest],[Qty],[Dlv_Dt],[PSD_Dt],[LPD_Dt],[Sold_To_Cust],[Bill_To_Cust],[Ship_Mode],[Garm_Qty],[CM_Price]
		,[Act_Qty],[Priority],[CONo],[POD_Dt],[Remarks],[Webbing],[Created_By],[Time_Created],RS_Dt,VSL_Dt
		,Ex_Fty_Dt,Sales_Ord_Type, co_status)

		SELECT io_det.sbu_id,mhd.mo_id, mhd.MONo, dbo.IO_Det.Item_No, dbo.IO_Det.CPO_No, dbo.IO_Det.CPO_Item, dbo.IO_Det.CPO_Dt, dbo.IO_Det.Cust_Style, dbo.IO_Det.Cust_Desc, dbo.IO_Det.Cust_Color, 
				dbo.IO_Det.Cust_Size, dbo.IO_Det.Cust_Dest, dbo.IO_Det.Ship_To_Cust, dbo.IO_Det.Style_No, dbo.IO_Det.Color, dbo.IO_Det.Size, dbo.IO_Det.Dest, dbo.IO_Det.Qty, 
				dbo.IO_Det.Dlv_Dt, dbo.IO_Det.PSD_Dt, dbo.IO_Det.LPD_Dt, dbo.IO_Det.Sold_To_Cust, dbo.IO_Det.Bill_To_Cust, dbo.IO_Det.Ship_Mode, isnull(dbo.IO_Det.Garm_Qty,1), dbo.IO_Det.CM_Price, 
				dbo.IO_Det.Act_Qty, 0 AS Priority, dbo.IO_Det.CONo, dbo.IO_Det.POD_Dt, dbo.IO_Det.Remarks, dbo.IO_Det.Webbing
				, @UserId AS CreatedBy, getdate() AS CreatedDt, dbo.IO_Det.RS_Dt, dbo.IO_Det.VSL_Dt,
				dbo.IO_Det.Ex_Fty_Dt, dbo.IO_Det.Sales_Ord_Type, dbo.IO_Det.co_status
		FROM dbo.IO_Det 
			INNER JOIN
				dbo.IO_Hdr ON dbo.IO_Det.IONo = dbo.IO_Hdr.IONo 
			INNER JOIN
				(
				Select min(h.MONo) as MONo, min(h.id) as mo_id, h.IONo, h.CONo from dbo.MO_Hdr h left outer join dbo.MO_Det d on h.MONo = d.MONo 
				Where d.MONo is null
				--and h.LevelNo = 1
				and h.IONo in (Select IONo from #IOs)
				Group By h.IONo, h.CONo
				) mhd ON dbo.IO_Hdr.IONo = mhd.IONo AND dbo.IO_Det.CONo = mhd.CONo 
			LEFT OUTER JOIN
				(SELECT DISTINCT Item_No FROM dbo.MO_Det) AS mod ON dbo.IO_Det.Item_No = mod.Item_No
		WHERE 
		dbo.IO_Det.IONo in (Select IONo from #IOs)
		AND (mod.Item_No IS NULL) 
		AND dbo.IO_Det.Qty > 0

/*
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByCONo - Insert MO Details to Existing MO.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MO_Det]
		([sbu_id],[MO_id],[mono],[Item_No],[CPO_No],[CPO_Item],[CPO_Dt],[Cust_Style],[Cust_Desc],[Cust_Color],[Cust_Size],[Cust_Dest],[Ship_To_Cust]
		,[Style_No],[Color],[Size],[Dest],[Qty],[Dlv_Dt],[PSD_Dt],[LPD_Dt],[Sold_To_Cust],[Bill_To_Cust],[Ship_Mode],[Garm_Qty],[CM_Price]
		,[Act_Qty],[Priority],[CONo],[POD_Dt],[Remarks],[Webbing],[Created_By],[Time_Created],RS_Dt,VSL_Dt
		,Ex_Fty_Dt,Sales_Ord_Type)
		SELECT dbo.IO_Det.sbu_id,mhd.mo_id, mhd.MONo, dbo.IO_Det.Item_No, dbo.IO_Det.CPO_No, dbo.IO_Det.CPO_Item, dbo.IO_Det.CPO_Dt, dbo.IO_Det.Cust_Style, dbo.IO_Det.Cust_Desc, dbo.IO_Det.Cust_Color, 
				dbo.IO_Det.Cust_Size, dbo.IO_Det.Cust_Dest, dbo.IO_Det.Ship_To_Cust, dbo.IO_Det.Style_No, dbo.IO_Det.Color, dbo.IO_Det.Size, dbo.IO_Det.Dest, dbo.IO_Det.Qty, 
				dbo.IO_Det.Dlv_Dt, dbo.IO_Det.PSD_Dt, dbo.IO_Det.LPD_Dt, dbo.IO_Det.Sold_To_Cust, dbo.IO_Det.Bill_To_Cust, dbo.IO_Det.Ship_Mode, isnull(dbo.IO_Det.Garm_Qty,1), dbo.IO_Det.CM_Price, 
				dbo.IO_Det.Act_Qty, 0 AS Priority, dbo.IO_Det.CONo, dbo.IO_Det.POD_Dt, dbo.IO_Det.Remarks, dbo.IO_Det.Webbing
				, @UserId AS CreatedBy, getdate() AS CreatedDt, dbo.IO_Det.RS_Dt, dbo.IO_Det.VSL_Dt,
				dbo.IO_Det.Ex_Fty_Dt, dbo.IO_Det.Sales_Ord_Type
		FROM dbo.IO_Det 
			INNER JOIN
				dbo.IO_Hdr ON dbo.IO_Det.IONo = dbo.IO_Hdr.IONo 
			INNER JOIN
				(
				Select min(h.id) as mo_id,min(h.MONo) as MONo, h.IONo, d.CONo from dbo.MO_Hdr h inner join dbo.MO_Det d on h.MONo = d.MONo 
				Where --h.LevelNo = 1
				h.IONo in (Select IONo from #IOs) 
				and d.Qty > 0
				Group By h.IONo, d.CONo) mhd 
				ON dbo.IO_Hdr.IONo = mhd.IONo AND dbo.IO_Det.CONo = mhd.CONo 
			LEFT OUTER JOIN
				(SELECT DISTINCT Item_No FROM dbo.MO_Det) AS mod ON dbo.IO_Det.Item_No = mod.Item_No
		WHERE 
		dbo.IO_Det.IONo in (Select IONo from #IOs)
		and (mod.Item_No IS NULL) 
		and dbo.IO_Det.Qty > 0
*/
		--Update MOHdr ExFtyDt
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByCONo - Update ExFtyDt.', TimeFinish = getdate() Where RecId = @RecId
		Update MO_Hdr Set Rev_Ex_Fty_Dt = isnull(d.ExFtyDt,Rev_Ex_Fty_Dt)
		from MO_Hdr h 
		Outer apply (Select min(Ex_Fty_Dt) as ExFtyDt from MO_Det with (nolock) Where MONo = h.MONo and Qty > 0) d
		Where IONo in (Select IONo from #IOs) 
/* remarks by donel table not existing
		--Insert MOColor
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByCONo - Insert MO Colors.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MOColor]
				   ([MONo]
				   ,[Color]
				   ,[ColorDesc])
		SELECT dbo.MODet.MONo, dbo.IODet.Color, max(dbo.IODet.ColorDesc) as ColorDesc
		FROM dbo.IOHdr 
			INNER JOIN
				#IOs i ON dbo.IOHdr.IONo = i.IONo
			INNER JOIN 
				dbo.IODet ON dbo.IOHdr.IONo = dbo.IODet.IONo 
			INNER JOIN
				dbo.MODet ON dbo.IODet.ItemNo = dbo.MODet.ItemNo 
			LEFT OUTER JOIN
				dbo.MOColor ON dbo.MODet.MONo = dbo.MOColor.MONo AND dbo.IODet.Color = dbo.MOColor.Color
		WHERE 
			(dbo.MOColor.Color IS NULL) 
			and dbo.IODet.Qty > 0 
		GROUP BY dbo.MODet.MONo, dbo.IODet.Color
*/
		--Delete Duplicate MODetPriority
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByCONo - Delete MO Detail Priorities with discrepancy.', TimeFinish = getdate() Where RecId = @RecId
		Delete from MO_Det_Priority Where MONo in (select distinct mp.MONo from 
													(Select MONo, CONo, min(Dlv_Dt) as Dlv_Dt from MO_Det 
														where Qty > 0 group by MONo, CONo) md 
													inner join MO_Det_Priority mp 
													on md.MONo = mp.MONo 
													and md.CONo = mp.CONo 
													and md.Dlv_Dt <> mp.Dlv_Dt)
								AND MONo in (Select MONo from MO_Hdr Where IONo in (Select IONo from #IOs))		

		--Insert MODetPriority
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByCONo - Insert MO Detail Priorities.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MO_Det_Priority]
				   ([sbu_id],[MONo],[mo_id],[active]
				   ,[CONo]
				   ,[Dlv_Dt]
				   ,[Priority]
				   ,[Created_By]
				   ,[time_Created])
		Select sbu_id,MONo,MO_id,1, CONo, Dlv_Dt, row_number() over (partition by MONo order by MONo) + isnull(MaxPriority,0) AS COPriority, @UserId, getdate()
		from 
			(
			SELECT DISTINCT dbo.MO_Det.sbu_id,dbo.MO_Det.MONo,dbo.MO_Det.MO_id, dbo.MO_Det.CONo, dbo.MO_Det.Dlv_Dt, isnull(x.MaxPriority, 0) AS MaxPriority
			FROM            dbo.MO_Det LEFT OUTER JOIN
									 dbo.MO_Det_Priority ON dbo.MO_Det.MONo = dbo.MO_Det_Priority.MONo AND dbo.MO_Det.CONo = dbo.MO_Det_Priority.CONo
									 LEFT OUTER JOIN (Select MONo, Max(Priority) as MaxPriority from MO_Det_Priority group by MONo) x on MO_Det.MONo = x.MONo
			WHERE        (dbo.MO_Det_Priority.CONo IS NULL) AND dbo.MO_Det.Dlv_Dt is not null and dbo.MO_Det.Qty > 0
			AND dbo.MO_Det.MONo in (Select MONo from MO_Hdr Where IONo in (Select IONo from #IOs))
			) modPriority


		--Insert MOEvents
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByCONo - Insert MO Events/Critical Path.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MO_Events]
				   (sbu_id,MONO, mo_id  
				   --,[Rec_Id]
				   ,[Event_Seq]
				   ,[Key_Event]
				   ,[Req_Duration]
				   ,[Responsible]
				   ,[VAP]  
				   ,[Remarks]
				   --,[Deleted]
				   ,[Predecessor]
				   ,[Successor]
				   ,[Created_By]
				   ,[Time_Created]
				   ,[Level_No]
				   ,[Pass_Type]
				   ,[Seq_No]
				   ,[Orig_Req_Duration]
				   ,[Active])
		SELECT h.sbu_id, h.MONo,h.id  --, newid()
				, e.EventSeq, e.KeyEvent, e.ReqDuration, e.Responsible, e.VAP, e.Remarks
					--,e.Deleted
					, e.Predecessor, e.Successor, @UserId as CreatedBy, getdate() as CreatedDt
					,e.LevelNo, e.PassType, e.SeqNo, e.ReqDuration, e.Active
		FROM dbo.MO_Hdr AS h CROSS JOIN dbo.[View_Event] AS e 
		WHERE (h.MONo IN (
						  SELECT distinct h.MONo 
						  FROM dbo.MO_Hdr AS h LEFT OUTER JOIN dbo.MO_Events AS e ON h.MONo = e.MONo
						  inner join IO_Hdr ih on h.Iono = ih.IONo
						  WHERE (e.MONo IS NULL)
						  and ih.IONo in (Select distinct IONo from IO_Det Where Qty > 0 and IONo in (Select IONo from #IOs))
						  )
				)
		and h.Mfg_Loc in (Select Mfg_Loc from m_Mfg_Locs Where Local = 1)

		--Insert MOSpsMachine
		--Update dbo.SyncLog set Remarks = 'ordSyncMO_ByCONo - Update MOEvents PO RS/RF.', TimeFinish = getdate() Where RecId = @RecId
		--Exec dbo.ordUpdateMOEventsPODD @Userid


		--Insert MOSpsMachine
		--Update dbo.SyncLog set Remarks = 'ordSyncMO_ByCONo - Insert MO Special Machines.', TimeFinish = getdate() Where RecId = @RecId
		--INSERT INTO [dbo].[MOSpsMachine]
		--		   ([MONo]
		--		   ,[SpsMachineCd]
		--		   ,[SMV])
		--SELECT h.MONo, m.SpsMachineCd, m.SMV
		--FROM dbo.MOHdr AS h INNER JOIN dbo.StyleMachine AS m ON h.StyleNo = m.StyleNo
		--WHERE (h.MONo IN (
		--				  SELECT distinct h.MONo 
		--				  FROM dbo.MOHdr AS h LEFT OUTER JOIN dbo.MOSpsMachine AS e ON h.MONo = e.MONo
		--				  WHERE (e.MONo IS NULL))
		--				  )
		--AND h.MONo in (Select MONo from MOHdr Where IONo in (Select IONo from IOHdr Where CusGrp = 'SKE'))
		--and h.MONo in (Select distinct MONo from MODet Where Qty > 0)


		--Insert MOVAPSVAP
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByCONo - Insert MO Checkpoints.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MO_VAP_SVAP]
				   ([sbu_id],[MONo],[mo_id]
				   ,[Seq]
				   ,[VAP]
				   ,[SVAP]
				   ,[GVAP]
				   /*,[VAP_id]
				   ,[SVAP_id]
				   ,[GVAP_id]*/
				   --,[WBT]
				   --,[Lean]
				   --,[WPT]
				   ,[Load_On]
				   ,[Load_Off]
				   ,[Reqd]
				   --,[Subcon]
				   ,[Seq2]
				   ,[Active]
				   --,[Simultaneous]
				   ,[Created_By]
				   ,[Time_Created]
				   --,[Output_VAP]
				   --,[Output_SVAP]
				   )
		--select @CheckpointTemplate	
		SELECT h.sbu_id,
		h.MONo,h.id, v.Seq, v.VAP, v.SVAP, v.GVAP--, v.WBT, v.Lean, v.WPT
		--, v.VAP_id, v.SVAP_id, v.GVAP_id
		, v.LoadOn, v.LoadOff, v.Reqd--, v.Subcon
		, v.Seq2, v.Active--, v.Simultaneous, 
				,@UserId, getdate()--, v.OutputVAP, v.OutputSVAP

		FROM dbo.MO_Hdr AS h 
		--INNER JOIN  VAPSVAPTemplateStyle AS i ON h.StyleNo = i.Style 
		--	AND EffDt  = (SELECT TOP 1 EffDt FROM  VAPSVAPTemplateStyle WHERE Style = h.StyleNo AND EffDt <= GETDATE() ORDER BY EFFDT DESC)
		INNER JOIN dbo.VAPSVAP_Template_Det AS v ON @CheckpointTemplate = v.Template_ID
		WHERE (h.MONo IN (
						  SELECT distinct h.MONo 
						  FROM dbo.MO_Hdr AS h LEFT OUTER JOIN dbo.MO_VAP_SVAP AS e ON h.MONo = e.MONo
						  WHERE (e.MONo IS NULL))
						  )
		AND h.MONo in (Select MONo from MO_Hdr Where IONo in (Select IONo from #IOs))
		and h.MONo in (Select distinct MONo from MO_Det Where Qty > 0)


		--Insert MOGVAP
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByCONo - Insert MO GVAP.', TimeFinish = getdate() Where RecId = @RecId
		DECLARE @Cnt AS int
		DECLARE @RowNo AS int
		DECLARE @MONo AS varchar(20)

		SELECT row_number() over (order by h.MONo) As RowNo, h.MONo INTO #MONo
		FROM dbo.MO_Hdr AS h LEFT OUTER JOIN dbo.MO_GVAP AS g ON h.MONo = g.MONo
		WHERE (g.MONo IS NULL)
		AND h.MONo in (Select MONo from MO_Hdr Where IONo in (Select IONo from #IOs))
		and h.MONo in (Select distinct MONo from MO_Det Where Qty > 0)


		Select @Cnt = count(1) from #MONo
		Set @RowNo = 1

		If @cnt > 0
		BEGIN
			WHILE @Cnt >= @RowNo --1 >= 2
			BEGIN
				Select @MONo = MONo from #MONo Where RowNo = @RowNo
				
				EXEC stg_ordCreateMOGVAP @MONo
				EXEC stg_ordUpdateDiffMO_CPMO @MONo, @UserId
				EXEC stg_ordUpdateMO_CP @MONo, @UserId
				
				Set @RowNo = @RowNo + 1

			END
		END
		
		drop table #IOs
	
	Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByCONo - Completed.', TimeFinish = getdate() Where RecId = @RecId
	
	END TRY
	
	BEGIN CATCH
		IF (@@TRANCOUNT > 0)
		--SELECT 1 AS ERROR_MSG
			--SELECT ERROR_MESSAGE() AS ERROR_MSG
			Update dbo.stg_SyncLog set Remarks = left('ordSyncMO_ByCONo - ' + ERROR_MESSAGE(),2000), TimeFinish = getdate() Where Recid = @RecId
			--ROLLBACK TRANSACTION	
	END CATCH	
	
END


go

CREATE procedure usp_fg_delete_po_by_id
	@poid bigint = 0,
	@createdBy varchar(30) =''
AS
	declare @timeCreated datetime2 = getdate()
	declare @pono varchar(30)
	select @pono = pono from fg_purchase_order where id = @poid
-- declare @poid bigint = 3443
-- declare @createdBy varchar(30) = 'Eduard'
-- declare @timeCreated datetime2 = getdate()

	--START HERE DELETE AN INSERT to TEMP
	INSERT INTO tmp_delete_loading_plan(loading_plan_id, purchase_order_dtl_id, purchase_order_id, created_by, time_created)
	select loading_plan_id, purchase_order_dtl_id, @poid as purchase_order_id, @createdBy, @timeCreated
	from fg_loading_plan_pl where purchase_order_dtl_id in (select id from fg_purchase_order_dtl where purchase_order_id in (select id from fg_purchase_order where id = @poid))

	-- ACTUAL DELETE LOADING
	DELETE from image_files where table_name = 'fg_loading_plan_container' and table_id in (select id FROM fg_loading_plan_container where loading_plan_id in (select loading_plan_id from tmp_delete_loading_plan  where purchase_order_id = @poid))
	DELETE FROM fg_loading_plan_container where loading_plan_id in (select loading_plan_id from tmp_delete_loading_plan  where purchase_order_id = @poid)
	DELETE FROM fg_loading_plan_pl where loading_plan_id in (select loading_plan_id from tmp_delete_loading_plan  where purchase_order_id = @poid)
	DELETE FROM fg_loading_plan where id in (select loading_plan_id from tmp_delete_loading_plan  where purchase_order_id = @poid)

	-- DELETE AND INSERT TEMP FIRST
	insert into dbo.tmp_delete_scanning_hdr(purchase_order_id, scanning_hdr_id, created_by, time_created)
	select distinct purchase_order_id, scanning_hdr_id, @createdBy, @timeCreated
	from fg_carton_scanning where purchase_order_id = @poid
	-- DELETE THE SCANNING NOW
	DELETE from fg_carton_scanning where  scanning_hdr_id in (select scanning_hdr_id from dbo.tmp_delete_scanning_hdr where purchase_order_id = @poid)
	DELETE from fg_carton_scanning_hdr where id in (select scanning_hdr_id from dbo.tmp_delete_scanning_hdr where purchase_order_id = @poid)

	--3. DELETE ORDERS
	delete from fg_carton_allocation where carton_id in (select id from fg_carton where purchase_order_dtl_id in (select id from fg_purchase_order_dtl where purchase_order_id in (select id from fg_purchase_order where id = @poid )))
	delete from fg_carton where purchase_order_dtl_id in (select id from fg_purchase_order_dtl where purchase_order_id in (select id from fg_purchase_order where id = @poid ))
	delete from fg_purchase_order_dtl where purchase_order_id in (select id from fg_purchase_order where id = @poid )
	delete from fg_purchase_order where id = @poid

	INSERT INTO m_recent_activities (sbu_id, active, code, description, created_by, time_created)
	SELECT sbuId = 1, active = 1, code = 'DELETE PO', description = 'Deleted pono ' + isnull(@pono,'') + 'by ' + @createdBy , @createdBy ,@timeCreated
 
	select 'success' as code, 'success' as description
go

CREATE FUNCTION [dbo].[prdCheckCapacityFN_v2]
(
	@LINE VARCHAR(50),
	@DATE DATETIME
)

RETURNS CHAR(1)

AS

BEGIN

	/*declare
	@LINE VARCHAR(50) = 'L01',
	@DATE DATETIME = '02/22/2023'*/

	DECLARE @MFGLOC VARCHAR(20)
	SELECT
		@MFGLOC = mfg_loc
	FROM DBO.m_line
	WHERE
		code = @LINE AND
		active = 1

-- Define a table variable called @WRK_TIME
	DECLARE @WRK_TIME TABLE
	(
		SEQ INT IDENTITY(1, 1),
		time_from TIME,
		time_to TIME
	)

	-- Check if there is a special working day instead of the regular day
	/*INSERT INTO @WRK_TIME
		(time_from, time_to)
	 */

	IF ((SELECT COUNT(1) FROM @WRK_TIME) = 0)
	BEGIN
		INSERT INTO @WRK_TIME
			(time_from, time_to)
		SELECT 
			c.date_from,
			c.date_to --, c.code
		FROM  m_calendar a
			inner join  DBO.m_calendar_week_day b
				on a.id = b.calendar_id
			inner join  DBO.m_calendar_week_day_det c
			on b.id = c.calendar_week_day_id
		where a.code = @MFGLOC
 		and c.code =  DATENAME(WEEKDAY, @DATE)
		and NOT exists(select 1 from m_calendar_exception where @DATE between date_from and date_to)
	END

	DECLARE @RESULT CHAR(1)
	IF EXISTS(SELECT 1 FROM @WRK_TIME)
	BEGIN
		SELECT @RESULT = 'T'
	END
	ELSE
	BEGIN
		SELECT @RESULT = 'F'
	END

	/*CHECK DATA HERE*/
-- 	SELECT @MFGLOC as MFGLOC , *, @RESULT
-- 	FROM @WRK_TIME
-- 	return

	RETURN @RESULT

END
go

CREATE PROCEDURE [dbo].[prdValidateTmpOB]
	@MONo varchar(20)  
AS
BEGIN

		--check if OB already exists
		declare @errormsg varchar(2000) = ''
		if(exists(select 1 from mo_hdr where mono = @MONo and mo_status in ('OB','Released')))
			BEGIN
				select code = 'failed', description = 'OB already available'
				return
			END

		--check for duplicate
		declare @dup_seq varchar(500) = ''
		set @dup_seq  = isnull((Select STUFF((SELECT ',' + cast(Operation_Seq as varchar(20)) from ob_upload WHERE MONo = @MONo
					GROUP BY Operation_Seq
					HAVING count(Operation_Seq) > 1
				FOR XML PATH('')), 1, 1, '')
				),'')

		if @dup_seq != ''
			begin
				select code = 'failed', description = 'Duplicate Operation Seq not allowed : ' + @dup_seq
				return
			end
		
		--check for skip operation_seq
		--declare @MONo varchar(20) = '13824001002'
		declare @skip_seq varchar(500) = ''
		set @skip_seq  = isnull((Select STUFF((select distinct ',' + cast(seq as varchar(20))  from (
				SELECT  (operation_seq + 1) as seq
						FROM ob_upload
						WHERE (operation_seq + 1) NOT IN ( SELECT  operation_seq FROM ob_upload where mono = @MONo)
						and mono = @MONo ) a
				left outer join   ob_upload b on b.mono = @MONo and b.operation_seq  = a.seq + 1
				where id is not null
				FOR XML PATH('')), 1, 1, '')
				),'')
		if @skip_seq != ''
			begin
				select code = 'failed', description = 'Skip Operation Seq not allowed : ' + @skip_seq
				return
			end


	--update Seq, Split No if operation exists in OBGroupOperations
	--UPDATE tmpOB 
	--	SET OperationSeq = o.Seq, split = o.Split
	--	FROM tmpob t INNER JOIN OBGroupOperations o ON o.mono = t.MONo AND o.Operation = t.Operation 
	--	WHERE t.mono = @MONo
	
		UPDATE OB_Group_Operations 
		SET Seq = t.Operation_seq, split = o.Split
		FROM ob_upload t INNER JOIN OB_Group_Operations o ON o.mono = t.MONo AND o.Operation = t.Operation_code 
		WHERE t.mono = @MONo

		UPDATE ob 
		SET Seq = t.Operation_seq, split = o.Split
		FROM ob_upload t INNER JOIN OB o ON o.mono = t.MONo AND o.Operation = t.Operation_code 
		WHERE t.mono = @MONo

		
	--validate if operation with different SMV is already approved.
	--IF EXISTS (SELECT * FROM ob_upload WHERE EXISTS (SELECT 'x' FROM prdOBSMVEffDtSortvw WHERE prdOBSMVEffDtSortvw.MONo = TmpOB.MONo AND prdOBSMVEffDtSortvw.Operation = TmpOB.Operation AND prdOBSMVEffDtSortvw.SAM <> TmpOB.SAM) AND MONo = @MONo)
	--BEGIN		
	--	SELECT DISTINCT '0', '1' as ErrCode, 'The following Operation/s have new SMV but the existing SMV are already approved' AS ErrDesc, Operation FROM tmpOB WHERE EXISTS (SELECT 'x' FROM prdOBSMVEffDtSortvw WHERE prdOBSMVEffDtSortvw.MONo = TmpOB.MONo AND prdOBSMVEffDtSortvw.Operation = TmpOB.Operation AND prdOBSMVEffDtSortvw.SAM <> TmpOB.SAM) AND MONo = @MONo
	--	RETURN
	--END

	update ob_upload set style_no = style_code FROM ob_upload WHERE MONo = @MONo 

	IF EXISTS (SELECT MONO, VAP, Operation_Seq, Split, COUNT(operation_code) FROM ob_upload WHERE MONo = @MONo GROUP BY MONo, VAP, Operation_Seq, Split HAVING COUNT(Operation_code) > 1)
	BEGIN		
		--SELECT DISTINCT '0', '5' as ErrCode, 'Duplicate Operation Seq are found on the following VAP/s' + 'Seq: ' AS ErrDesc,Operation_Seq AS Operation, MONO, VAP, COUNT(operation_code) FROM ob_upload WHERE MONo = @MONo GROUP BY MONo, VAP, Operation_Seq, Split HAVING COUNT(Operation_code) > 1
		SELECT DISTINCT 'failed' as code, 'Duplicate Operation Seq are found on the following VAP/s' + 'Seq: ' + 'MONo: ' + mono + 'VAP: ' + VAP + ' :1' AS 'description' FROM ob_upload WHERE MONo = @MONo GROUP BY MONo, VAP, Operation_Seq, Split HAVING COUNT(Operation_code) > 1
		RETURN
	END

	IF EXISTS (SELECT 'x' FROM ob_upload WHERE EXISTS (SELECT 'x' FROM OB WHERE OB.MONo = ob_upload.MONo AND OB.VAP = ob_upload.VAP AND OB.Seq = ob_upload.Operation_Seq AND OB.Split = ob_upload.Split AND OB.Operation <> ob_upload.Operation_Code) AND ob_upload.MONo = @MONo)
	BEGIN		
		--SELECT DISTINCT '0', '3' as ErrCode, 'Seq/Split Nos already exist for the following operations' AS ErrDesc, ob_upload.Operation_code FROM ob_upload WHERE EXISTS (SELECT 'x' FROM OB WHERE OB.MONo = ob_upload.MONo AND OB.VAP = ob_upload.VAP AND OB.Seq = ob_upload.Operation_Seq AND OB.Split = ob_upload.Split  AND OB.Operation <> ob_upload.Operation_Code) AND ob_upload.MONo = @MONo
		SELECT DISTINCT 'failed' as code, 'Seq/Split Nos already exist for the following operations, Operation Code: ' + ob_upload.Operation_code + ' :2' AS 'description' FROM ob_upload WHERE EXISTS (SELECT 'x' FROM OB WHERE OB.MONo = ob_upload.MONo AND OB.VAP = ob_upload.VAP AND OB.Seq = ob_upload.Operation_Seq AND OB.Split = ob_upload.Split  AND OB.Operation <> ob_upload.Operation_Code) AND ob_upload.MONo = @MONo
		RETURN
	END

	IF EXISTS (SELECT 'x' FROM ob_upload WHERE MONo = @MONo AND FLOOR(target_output) <> CEILING(target_output))
	BEGIN
		--SELECT DISTINCT '0', '4' as ErrCode, 'Decimal values exist for Target Output for the following operations' AS ErrDesc, Operation_code FROM ob_upload WHERE MONo = @MONo AND FLOOR(target_output) <> CEILING(target_output)
		SELECT DISTINCT 'failed' as code, 'Decimal values exist for Target Output for the following operations, Operation Code: ' + Operation_code + ' :3' AS 'description'   FROM ob_upload WHERE MONo = @MONo AND FLOOR(target_output) <> CEILING(target_output)

		RETURN
	END

	IF EXISTS (SELECT 'x' FROM ob_upload WHERE MONo = @MONo GROUP BY MONo,operation_code  HAVING COUNT(Operation_code) > 1)
	BEGIN
		--SELECT DISTINCT '0', '5' as ErrCode, 'Duplicate Operations are not allowed ' AS ErrDesc, MONO, Operation_code FROM ob_upload WHERE MONo = @MONo GROUP BY MONo,operation_code  HAVING COUNT(Operation_code) > 1
		SELECT DISTINCT 'failed' as code, 'Duplicate Operations are not allowed, MONo : ' + MONO + ' Operation Code: ' + Operation_code + ' :4'  AS 'description'  FROM ob_upload WHERE MONo = @MONo GROUP BY MONo,operation_code  HAVING COUNT(Operation_code) > 1

		RETURN
	END
	
	IF EXISTS (SELECT FEATURE_code FROM (SELECT DISTINCT Feature_code,Feature_Description  FROM ob_upload WHERE MONO = @MONo
											GROUP BY FEATURE_code,Feature_Description
										) FEAT
										GROUP BY FEATURE_code
									HAVING COUNT(FEATURE_code) > 1)
	BEGIN		
		--SELECT DISTINCT '0', '5' as ErrCode, 'Duplicate Feature Description' AS ErrDesc, FEATURE_code AS Operation FROM (SELECT DISTINCT Feature_code,Feature_Description  
		--																								FROM ob_upload WHERE MONO = @MONo
		--																								GROUP BY FEATURE_code,Feature_Description,MONO
		--																								) FEAT
		--																								GROUP BY FEATURE_code
		--																								HAVING COUNT(FEATURE_code) > 1
		SELECT DISTINCT 'failed' as code, 'Duplicate Feature Description, Feature/Operation : ' + FEATURE_code + ' :5'  AS 'description'   FROM (SELECT DISTINCT Feature_code,Feature_Description
																										FROM ob_upload WHERE MONO = @MONo
																										GROUP BY FEATURE_code,Feature_Description,MONO
																										) FEAT
																										GROUP BY FEATURE_code
																										HAVING COUNT(FEATURE_code) > 1
		
		
		RETURN
	END

	IF NOT EXISTS (SELECT TOP 1 * FROM ob_upload WHERE MONO = @MONo AND Style_no = (SELECT Style_No FROM MO_Hdr WHERE MONo = @MONo))
	BEGIN		
		--SELECT DISTINCT '0', '5' as ErrCode, 'Invalid style no  Excel and MO should have the same style' AS ErrDesc,'' AS Operation
		SELECT DISTINCT 'failed' as code, 'Invalid style no  Excel and MO should have the same style :6' AS 'description'

		RETURN
	END
/*
	IF EXISTS (
	SELECT Operation_Seq from ob_upload 
	WHERE MONo = @MONo
	GROUP BY Operation_Seq
	HAVING count(Operation_Seq) > 1
	)
	BEGIN
		--SELECT DISTINCT '0', '5' as ErrCode, 'Duplicate Seq are not allowed ' AS ErrDesc, Operation_Seq AS Operation FROM ob_upload WHERE MONo = @MONo GROUP BY Operation_Seq  HAVING COUNT(Operation_Seq) > 1
		SELECT DISTINCT 'failed' as code, 'Duplicate Seq are not allowed :7' + cast(Operation_Seq as varchar(100)) AS 'description'--, Operation_Seq AS Operation 
		FROM ob_upload WHERE MONo = @MONo GROUP BY Operation_Seq  HAVING COUNT(Operation_Seq) > 1

		RETURN
	END
*/
	---Added by Donel from prdValidateTmpOBBeforeUpload
	IF  EXISTS (SELECT 'x' FROM ob_upload t INNER JOIN OB_Group_Operations o ON t.MONo = o.MONo AND t.Operation_code = o.Operation WHERE t.MONo =  @MONo )
	BEGIN
		--SELECT DISTINCT '0', '99' as ErrCode, 'The following operations already exist in Work Section Set-up ' AS ErrDesc, t.MONo, t.Operation_code FROM ob_upload t INNER JOIN OB_Group_Operations o ON t.MONo = o.MONo AND t.Operation_code = o.Operation WHERE t.MONo =  @MONo 
		SELECT DISTINCT 'failed' as code, 'The following operations already exist in Work Section Set-up, MONo : ' + t.MONo + ' Operation Code: ' + t.Operation_code + ' :8' AS 'description'  FROM ob_upload t INNER JOIN OB_Group_Operations o ON t.MONo = o.MONo AND t.Operation_code = o.Operation WHERE t.MONo =  @MONo

		RETURN
	END


	--IF EXISTS(SELECT 'X' FROM OB WHERE MONo = @MONo AND Operation IN (SELECT Operation FROM TmpOB WHERE MONo = @MONo))
	--BEGIN
	--	SELECT DISTINCT '0','5' as ErrCode, 'Operation code already exists in OB' AS ErrDesc,MONo,Operation FROM OB WHERE MONo = @MONo AND Operation IN
	--	(SELECT Operation FROM TmpOB WHERE MONo = @MONo)

	--	RETURN
	--END
		

	--IF EXISTS (SELECT 'x' FROM TmpOB t INNER JOIN OBGroupOperations o ON t.MONo = o.MONo AND t.Operation = o.Operation WHERE t.MONo =  @MONo )
	--BEGIN
	--	SELECT DISTINCT '0', '99' as ErrCode, 'The following operations already exist in Work Section Set-up ' AS ErrDesc, t.MONo, t.Operation FROM TmpOB t INNER JOIN OBGroupOperations o ON t.MONo = o.MONo AND t.Operation = o.Operation WHERE t.MONo =  @MONo 







	--	RETURN
	--END

	---update and insert data to all OB related tables
	exec [prdDownloadOB] @MONO


	--SELECT 1

END
go

CREATE procedure usp_initialize_data
as
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES ( NULL, CAST(N'2022-03-25T15:19:21.830' AS DateTime), N'admin', CAST(N'2022-03-30T15:03:48.460' AS DateTime), 1, 2, N'ASM', N'Assembly Supermarket', N'Assy Supermarket', CAST(1.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES ( NULL, CAST(N'2022-03-25T15:19:21.927' AS DateTime), NULL, NULL, 1, 2, N'BPP', N'BPP', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES (  NULL, CAST(N'2022-03-25T15:19:22.023' AS DateTime), NULL, NULL, 1, 2, N'CSM', N'Cutting Supermarket', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES (  NULL, CAST(N'2022-03-25T15:19:22.120' AS DateTime), NULL, NULL, 1, 2, N'CUT', N'Cutting', N'...', CAST(3.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES (  NULL, CAST(N'2022-03-25T15:19:22.220' AS DateTime), NULL, NULL, 1, 2, N'EMB', N'Embossing', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES (  NULL, CAST(N'2022-03-25T15:19:22.317' AS DateTime), NULL, NULL, 1, 2, N'EMBR', N'Embroidery', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES (  NULL, CAST(N'2022-03-25T15:19:22.417' AS DateTime), NULL, NULL, 1, 2, N'FCUT', N'Final Cut', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES ( NULL, CAST(N'2022-03-25T15:19:22.523' AS DateTime), NULL, NULL, 1, 2, N'GLU', N'Gluing', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES (  NULL, CAST(N'2022-03-25T15:19:22.620' AS DateTime), NULL, NULL, 1, 2, N'INK1', N'Inking 1', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES (  NULL, CAST(N'2022-03-25T15:19:22.713' AS DateTime), NULL, NULL, 1, 2, N'INK2', N'Inking2', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES ( NULL, CAST(N'2022-03-25T15:19:22.810' AS DateTime), NULL, NULL, 1, 2, N'LNG', N'Lining', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES (  NULL, CAST(N'2022-03-25T15:19:22.907' AS DateTime), NULL, NULL, 1, 2, N'PPACK', N'Pre-Packing', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES (  NULL, CAST(N'2022-03-25T15:19:23.003' AS DateTime), NULL, NULL, 1, 2, N'PRT', N'Printing', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES ( NULL, CAST(N'2022-03-25T15:19:23.100' AS DateTime), NULL, NULL, 1, 2, N'SEW', N'Assembly', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES ( NULL, CAST(N'2022-03-25T15:19:23.197' AS DateTime), NULL, NULL, 1, 2, N'SKI', N'Skiving', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES ( NULL, CAST(N'2022-03-25T15:19:23.293' AS DateTime), NULL, NULL, 1, 2, N'SKIA', N'Skiving part A', N'...', CAST(0.00 AS Numeric(9, 2)))
--
-- INSERT [dbo].[m_gvap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [duration]) VALUES ( NULL, CAST(N'2022-03-25T15:19:23.390' AS DateTime), NULL, NULL, 1, 2, N'STR', N'Strap', N'...', CAST(0.00 AS Numeric(9, 2)))
--
--
--
-- INSERT [dbo].[m_svap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [load_on], [load_off], [ws_req], [vap_id], [gvap_id], [comp_bundle], [for_do]) VALUES ( NULL, CAST(N'2022-03-25T15:40:19.410' AS DateTime), NULL, NULL, 1, 2, N'ISS', N'Issuance', N'....', 0, 1, 0, 1, 3, 0, 0)
--
-- INSERT [dbo].[m_svap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [load_on], [load_off], [ws_req], [vap_id], [gvap_id], [comp_bundle], [for_do]) VALUES ( NULL, CAST(N'2022-03-25T15:40:19.510' AS DateTime), NULL, NULL, 1, 2, N'ISS', N'Issuance', N'....', 0, 1, 0, 2, 16, 0, 0)
--
-- INSERT [dbo].[m_svap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [load_on], [load_off], [ws_req], [vap_id], [gvap_id], [comp_bundle], [for_do]) VALUES (  NULL, CAST(N'2022-03-25T15:40:19.607' AS DateTime), NULL, NULL, 1, 2, N'ISS', N'Issuance', N'....', 0, 1, 1, 3, 16, 0, 0)
--
-- INSERT [dbo].[m_svap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [load_on], [load_off], [ws_req], [vap_id], [gvap_id], [comp_bundle], [for_do]) VALUES (  NULL, CAST(N'2022-03-25T15:40:19.707' AS DateTime), NULL, NULL, 1, 2, N'RCV', N'Receiving', N'....', 1, 0, 1, 1, 16, 0, 0)
--
-- INSERT [dbo].[m_svap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [load_on], [load_off], [ws_req], [vap_id], [gvap_id], [comp_bundle], [for_do]) VALUES (  NULL, CAST(N'2022-03-25T15:40:19.807' AS DateTime), NULL, NULL, 1, 2, N'RCV', N'Receiving', N'....', 1, 0, 0, 2, 12, 0, 0)
--
-- INSERT [dbo].[m_svap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [load_on], [load_off], [ws_req], [vap_id], [gvap_id], [comp_bundle], [for_do]) VALUES (  NULL, CAST(N'2022-03-25T15:40:19.903' AS DateTime), NULL, NULL, 1, 2, N'RCV', N'Receiving', N'....', 1, 0, 0, 3, 14, 0, 0)
--
-- INSERT [dbo].[m_svap] ( [created_by], [time_created], [updated_by], [time_updated], [active], [sbu_id], [code], [description], [alt_description], [load_on], [load_off], [ws_req], [vap_id], [gvap_id], [comp_bundle], [for_do]) VALUES (  N'admin', CAST(N'2022-03-27T14:05:50.463' AS DateTime), N'admin', CAST(N'2022-03-27T14:05:50.463' AS DateTime), 1, 0, N'ISS', N'Issuance', N'....', 0, 1, 1, 5, 16, 0, 0)
--
-- insert dbo.m_event (active, sbu_id, seq_no, level_no, code, description, predecessor, successor) VALUES (1, 1, 1, 1, '100', 'Leather Arrvl', null, 200)
-- insert dbo.m_event (active, sbu_id, seq_no, level_no, code, description, predecessor, successor) VALUES (1, 1, 1, 1, '105', 'Fabric/Fillers Arrvl', null, 205)

/*
    private OrderTypes orderType; -- done
    m_mfg_locs -- done
    private Season season; --done
   private Plants plant; -- done
    private Customers cusGrp; -- done
    private SalesGrp salesGrp; --done
    private CustStyle custStyle; -- done
    private OrderStatus orderStatus; -- done
    private ProdType prodType; --done
  */




   --INSERT INTO Destination
   insert into tmp.dbo.m_destination(active, created_by, sbu_id, time_created, time_updated, updated_by, code, description)
   select distinct active = 1, created_by ='Eduard', sbu_id = 1, time_created=getdate(), time_updated=getdate(), updated_by = null,
     code = dest, description = dest
   from imappsDev.imapps.dbo.iodet a

  --INSERT INTO ProdType
  insert into tmp.dbo.m_prod_type (active, created_by, sbu_id, time_created, time_updated, updated_by, code, description)
  select distinct active = 1, created_by ='Eduard', sbu_id = 1, time_created=getdate(), time_updated=getdate(), updated_by = null,
     code = ProdTyp, description = (select Desc1 from imappsDev.imapps.dbo.ProdTypes where ProdType = a.prodTyp)
   from imappsDev.imapps.dbo.iohdr a

  --INSERT INTO OrderStatus
  insert into tmp.dbo.m_order_status (active, created_by, sbu_id, time_created, time_updated, updated_by, code, description)
  select distinct active = 1, created_by ='Eduard', sbu_id = 1, time_created=getdate(), time_updated=getdate(), updated_by = null,
     code = orderStatus, description = orderStatus
   from imappsDev.imapps.dbo.iohdr a

--INSERT INTO CustomerStyle
  insert into tmp.dbo.m_cust_style(active, created_by, sbu_id, time_created, time_updated, updated_by, code, description)
  select distinct active = 1, created_by ='Eduard', sbu_id = 1, time_created=getdate(), time_updated=getdate(), updated_by = null,
     code = custStyle, description = CustDesc
   from imappsDev.imapps.dbo.iohdr a

  --INSERT INTO SalesGroup
  insert into tmp.dbo.m_sales_grp(active, created_by, sbu_id, time_created, time_updated, updated_by, code, description)
  select distinct active = 1, created_by ='Eduard', sbu_id = 1, time_created=getdate(), time_updated=getdate(), updated_by = null,
     code = salesGrp, description = salesGrp
   from imappsDev.imapps.dbo.iohdr a

  --INSERT INTO Customers
  insert into tmp.dbo.m_plants(active, created_by, sbu_id, time_created, time_updated, updated_by, code, description)
  select distinct active = 1, created_by ='Eduard', sbu_id = 1, time_created=getdate(), time_updated=getdate(), updated_by = null,
     code = plant, description = plant
   from imappsDev.imapps.dbo.iohdr a

  --INSERT INTO Customers
  insert into tmp.dbo.m_customers(active, created_by, sbu_id, time_created, time_updated, updated_by, code, description)
  select distinct active = 1, created_by ='Eduard', sbu_id = 1, time_created=getdate(), time_updated=getdate(), updated_by = null,
     code = CusGrp, description = CusGrp
   from imappsDev.imapps.dbo.iohdr a

   --INSERT INTO OrderTyp
  insert into tmp.dbo.m_order_types(active, created_by, sbu_id, time_created, time_updated, updated_by, code, default_percentage, description, erp, main_mat_lead, mat_prep_lead, no_range_cd, prod_days, sub_mat_lead, transit_days)
  select active = 1, created_by ='Eduard', sbu_id = 1, time_created=getdate(), time_updated=getdate(),
  updated_by = null, code = OrderTyp, DefaultPerc, description = ShortText, erp, mainmatlead, matpreplead,
  norangecd, proddays, submatlead, transitdays
  from imappsDev.imapps.dbo.OrderTyp a

  --INSERT INTO Season
   insert into tmp.dbo.m_season(active, created_by, sbu_id, time_created, time_updated, updated_by, code, description)
   select distinct active = 1, created_by ='Eduard', sbu_id = 1, time_created=getdate(), time_updated=getdate(), updated_by = null,
     code = season, description = season
   from imappsDev.imapps.dbo.iohdr a


  --INSERT INTO MfgLocs
  insert into tmp.dbo.m_mfg_locs(active, created_by, sbu_id, time_created, time_updated, updated_by, alt_description, code, default_loc, default_ws, description, level_no, parent_mfg_loc, seq_start, w_ticket, gvap_id, parent_rec_id)
  select active = 1, created_by='Eduard', sbu_id = 1,
    time_created=getdate(), time_updated=null , updated_by='Eduard',
    alt_description = desc2, code = MfgLoc , default_loc = isnull(DefaultLoc,0),
    DefaultWS, description = desc1, levelno, parentmfgloc, seqstart, wticket, gvap_id = null , parent_rec_id = null
  FROM  imappsDev.imapps.dbo.MfgLocs

  --INSERT INTO ShipMode
  insert into tmp.dbo.m_ship_mode(active, created_by, sbu_id, time_created, time_updated, updated_by, code, description)
  select distinct active = 1, created_by ='Eduard', sbu_id = 1, time_created=getdate(), time_updated=getdate(), updated_by = null,
   code = shipMode, description = shipMode
  from imappsDev.imapps.dbo.iodet a

--select * from  tmp.dbo.io_hdr
   -- delete from  tmp.dbo.io_hdr
  -- INSERT INTO IO_HDR
  insert into tmp.dbo.io_hdr(active, created_by, sbu_id, time_created, time_updated, updated_by,
                             board_color, code, cust_del_dt, cust_desc, description,
                             iono, merch_smv, order_qty, plan_smv, psd_dt, remarks,
                             req_ex_fty_dt, src_erp, style_no, tc_smv, uom,
                             cus_grp_id , cust_style_id, order_status_id,
                             order_type_id, plant_id, prod_type_id, sales_grp_id, season_id , mfg_loc_id
  )
  select active = 1, createdby = '', sbuid =1, timecreated= null , timeupdated= null , updatedby= null ,
    boardcolor, code = IONo, custdeldt, custdesc, description = null,
    iono, merchsmv,  orderqty, plansmv, psddt, remarks, reqexftydt, srcerp, styleno, tcsmv, uom,
    cusgrpid = 1, custstyleid= 1, orderstatusid= 1,
    OrderTyp = 1, plantid= 1, prodtypeid = 1 , salesgrpid = 1 , seasonid = 1 , mfgloc = 1
  from imappsDev.imapps.dbo.IOHdr where IONo = '11615701'

  -- INSERT INTO IO_DET
  insert into tmp.dbo.io_det(active, created_by, sbu_id, time_created, time_updated, updated_by, co_status, code, color,
                             cono, cpo_dt, cpo_item, cust_color, cust_size, description, dlv_dt, ex_fty_dt, io_ln, pod_dt,
                             cpo_no, qty, remarks, rs_dt, shipped_qty, size, vsl_dt,
                             dest_id, order_type_id, ship_mode_id, ship_to_cust_id,
                             io_id)
  select active = 1, createdby = '', sbuid =1, timecreated= null , timeupdated= null , updatedby= null ,
    costatus, code = '', color, cono, cpodt, cpoitem, custcolor, custsize, description ='', dlvdt, exftydt,
    ioln, poddt, cpono, qty, remarks, rsdt, shippedqty, size, vsldt,
    destid =1,  ordertypeid=1, shipmodeid=1, shiptocustid=1,
    ioid =1
  from  imappsDev.imapps.dbo.IODet a
  where IONo = '11615701'
go

CREATE PROCEDURE [dbo].[usp_allocate_daily_output]
(
	@transId VARCHAR(50) ='',
	@mgfLoc VARCHAR(50) ='',
	@isRecalculate BIT = '',
	@userId NVARCHAR(50)='',
	@selMono NVARCHAR(20)= ''
)
AS
--*/
---- FOR TESTING
/*
DECLARE @TRANSID VARCHAR(50) = NEWID()
DECLARE @mgfLoc VARCHAR(50) = 'TARLAC'
DECLARE @ISRECALC BIT = 0
DECLARE @USERID NVARCHAR(50) = 'system'
--*/

if(@transId = '')
		set @transId = newid()

SET NOCOUNT ON;

BEGIN TRY
--BEGIN TRAN
	INSERT INTO  DBO.bo_time_stamp(Mfg_Loc, PROCESS, user_id, time_stamp)
	VALUES(@mgfLoc, 'Updating Daily Output', @USERID, GETDATE())

	IF OBJECT_ID(N'TEMPDB..#BOOUT') IS NOT NULL DROP TABLE #BOOUT
	IF OBJECT_ID(N'TEMPDB..#TMP_OUTPUT') IS NOT NULL DROP TABLE #TMP_OUTPUT
	IF OBJECT_ID(N'TEMPDB..#BO_HDR') IS NOT NULL DROP TABLE #BO_HDR
	IF OBJECT_ID(N'TEMPDB..#PLN_DAILY_MO_BO_MULTI_LN_OUTPUT_VW') IS NOT NULL DROP TABLE #PLN_DAILY_MO_BO_MULTI_LN_OUTPUT_VW
	IF OBJECT_ID(N'TEMPDB..#PLN_DAILY_MO_BO_OUTPUT_QTY_VW') IS NOT NULL DROP TABLE #PLN_DAILY_MO_BO_OUTPUT_QTY_VW
	IF OBJECT_ID(N'TEMPDB..#BO_DAILY_OUTPUT') IS NOT NULL DROP TABLE #BO_DAILY_OUTPUT
	IF OBJECT_ID(N'TEMPDB..#OUTPUT_DIFF') IS NOT NULL DROP TABLE #OUTPUT_DIFF
	IF OBJECT_ID(N'TEMPDB..#CHECK_CAPACITY') IS NOT NULL DROP TABLE #CHECK_CAPACITY
	IF OBJECT_ID(N'TEMPDB..#MO_LIST') IS NOT NULL DROP TABLE #MO_LIST
	IF OBJECT_ID(N'TEMPDB..#PLN_BO_HDR_VW') IS NOT NULL DROP TABLE #PLN_BO_HDR_VW
  IF OBJECT_ID(N'TEMPDB..#PLN_DAILY_MO_OUTPUT_QTY_VW') IS NOT NULL DROP TABLE #PLN_DAILY_MO_OUTPUT_QTY_VW -- ADDED



	CREATE TABLE #TMP_OUTPUT
	(
		MONO VARCHAR(20),
		BONO VARCHAR(20),
		LINE VARCHAR(10),
		OUTPUTDT DATETIME,
		OUTPUTQTY NUMERIC(38, 0),
		plan_qty NUMERIC(38, 0),
		ROWID INT
	)

	CREATE TABLE #BO_HDR
	(
		BONO VARCHAR(20),
		MONO VARCHAR(20),
		LINE VARCHAR(10),
		plan_start DATETIME,
		plan_qty NUMERIC(38, 0),
		REMPLNQTY NUMERIC(38, 0) -- Balance Qty
	)

	DECLARE @BONO VARCHAR(20),
			@BOMONO	VARCHAR(20),
			@BOLINE	VARCHAR(10),
			@PLAN_START DATETIME,
			@PLAN_QTY NUMERIC(38, 0),
			@REM_PLN_QTY NUMERIC(38, 0)
	DECLARE @MONO VARCHAR(20),
			@MOLINE	VARCHAR(10),
			@OUTPUTDT DATETIME,
			@OUTPUTQTY NUMERIC(38, 0)
	DECLARE @TOTOUTQTY NUMERIC(38, 0),
			@REMOUTQTY NUMERIC(38, 0),
			@SUMMOOUT INT,
			@SUMTOTOUT INT,
			@ROWID INT,
			@RECCNT INT,
			@RECCNT2 INT,
			@BOCNT INT,
			@RECALCDAY INT,
			@PLANCOMPLETEDDAY INT,
			@PLANCOMPLETEDDAYMIN INT

	SET @TOTOUTQTY = 0
	SET @REMOUTQTY = 0
	SET @ROWID = 0
	SET @SUMMOOUT = 0
	SET @RECALCDAY = 90 --30
	SET @PLANCOMPLETEDDAY = 180
	SET @PLANCOMPLETEDDAYMIN = 365


	----1. GET distinct MO's to Compute
	SELECT DISTINCT
		MONO
	INTO #MO_LIST
	FROM
	(
		-- GET MO and LINE FROM WIPSCAN
		select distinct mono, worksection as prod_line
		from wipscan
		where vap = 'ASSY-PPCK' and svap = 'ISS'
			and scandt>= GETDATE() - 40
     	--AND MONo = '15270901001'
		UNION ALL
		-- GET MO and LINE FROM BO_HDR
		SELECT DISTINCT
			BH.MONO,
			[PRODLINE] = BH.LINE
		FROM BO_Hdr BH WITH (NOLOCK)
		WHERE
			BH.Mfg_Loc = 'TARLAC' AND
			BH.Plan_Finish >= CAST((GETDATE() -40) AS DATE) --@RECALCDAY
			--AND MONo = case when @selMono = '' then mono else @selMono end
	) MT

--GET DATA HERE
/*select * from BO_Daily_Output where MONo in (select MONO from BO_Hdr)
select * from BO_Hdr where MONo in (select MONO from BO_Hdr)
select * from #MO_LIST where MONO in (select MONO from BO_Hdr)

	select * from wip_scan where mono = '15162101001'
	select * from BO_Hdr where MONo = '15162101001'

*/
	--------------------------------------------------

	---- 2. GET  MO's Output
	SELECT
		DATETRAN, MONO, PRODLINE, [OUTPUT]
	INTO #PLN_DAILY_MO_OUTPUT_QTY_VW
	FROM
	(
		-- GET MO and LINE FROM WIPSCAN
		select
				[DATETRAN] = MIN(a.scandt),
			a.MONO,
			b.code as PRODLINE ,
			[OUTPUT] = SUM(a.QTY),
			[GROUPDT] = CAST(a.scandt AS DATE)
		from wipscan a
			inner join m_line b on a.worksection = b.code
		where vap = 'ASSY-PPCK' and svap = 'ISS'
			and b.mfg_loc = 'TARLAC'
			and exists(SELECT 1 FROM #MO_LIST c WHERE c.MONO = a.MONO)
		GROUP BY
			a.MONO, b.code, CAST(a.scandt AS DATE)
	) MT


	-- 3. GET  MO LINE and BO FROM bo_hdr>. MOS AND LINE WITH PLAN ONLY
	SELECT
		MONO, LINE, BONO,
		[MULTILINE] = COUNT(LINE) OVER (PARTITION BY MONO, LINE)
	INTO #PLN_BO_HDR_VW
	FROM BO_HDR WITH (NOLOCK)
	WHERE MFG_LOC = 'TARLAC'
  --and MONo = '15162101001'

	CREATE NONCLUSTERED INDEX IDX_PLNbo_hdrVW_MULTILINE ON #PLN_BO_HDR_VW([MULTILINE])
	INCLUDE ([MONO],[LINE],[BONO])


	--4. GET MULTI LINE PLANNED MO
	SELECT PD.MONO, PD.PRODLINE, PD.DATETRAN, PD.[OUTPUT]
	INTO #PLN_DAILY_MO_BO_MULTI_LN_OUTPUT_VW
	FROM #PLN_DAILY_MO_OUTPUT_QTY_VW PD
	WHERE EXISTS(SELECT 1 FROM #PLN_BO_HDR_VW SQ WHERE SQ.MULTILINE > 1 AND SQ.MONO = PD.MONO AND SQ.LINE = PD.PRODLINE)

--  select * from #PLN_DAILY_MO_OUTPUT_QTY_VW
--  select * from #PLN_BO_HDR_VW where MONO = '15162101001'
--  select * from BO_Hdr where MONo = '15162101001'
-- select * from bo_hdr where mono = '15162101001'

	--5. GET SINGLE LINE PLANNED MO
	SELECT PD.MONO, PD.PRODLINE, PD.DATETRAN, PD.[OUTPUT], PB.BONO
	INTO #PLN_DAILY_MO_BO_OUTPUT_QTY_VW
	FROM #PLN_DAILY_MO_OUTPUT_QTY_VW PD
	INNER JOIN #PLN_BO_HDR_VW PB ON
		PB.MONO = PD.MONO AND
		PB.LINE = PD.PRODLINE
	WHERE PB.MULTILINE = 1

/*select * from #PLN_DAILY_MO_OUTPUT_QTY_VW -- ORIGINAL
select * from  #PLN_DAILY_MO_BO_OUTPUT_QTY_VW -- SINGLE LINE
select * from #PLN_DAILY_MO_BO_MULTI_LN_OUTPUT_VW --MULTILINE*/

	--6.GET THE bo_daily_output WHERE MONO is from the MOLIST
	SELECT BDO.MONO, BDO.LINE, BDO.[DATE], BDO.QTY
	INTO #BO_DAILY_OUTPUT
	FROM bo_daily_output BDO WITH (NOLOCK)
	INNER JOIN m_line LN WITH (NOLOCK) ON
		LN.code = BDO.Line AND
		LN.mfg_loc = 'TARLAC' AND
		LN.active = 1 AND
		EXISTS(SELECT 1 FROM #MO_LIST SQ WHERE SQ.MONO = BDO.MONO)

	--7. DROP THE PLNDAILYMOOUTQTYVW
	DROP TABLE #PLN_DAILY_MO_OUTPUT_QTY_VW

  /*select * from #BO_DAILY_OUTPUT
  select * from BO_Daily_Output where MONo = '15162101001'
  select * from wip_scan where mono = '15162101001'*/


	--8 CHECK CAPACITY if have work. for all MO in SINGLE LINE, MULTIPLE LINE, DAILY OUTPUT
	SELECT
		PRODLINE, DATETRAN,
		[WITHCAP] = DBO.PRDCHECKCAPACITYFN_v2(PRODLINE, DATETRAN)
	INTO #CHECK_CAPACITY
	FROM
	(
		SELECT DISTINCT PRODLINE, [DATETRAN] = (CONVERT(VARCHAR, DATETRAN, 101)) FROM #PLN_DAILY_MO_BO_MULTI_LN_OUTPUT_VW
		UNION
		SELECT DISTINCT PRODLINE, [DATETRAN] = (CONVERT(VARCHAR, DATETRAN, 101)) FROM #PLN_DAILY_MO_BO_OUTPUT_QTY_VW
		UNION
		SELECT DISTINCT [PRODLINE] = LINE, [DATETRAN] = (CONVERT(VARCHAR, [DATE], 101)) FROM #BO_DAILY_OUTPUT
	) MT


	--9. GET THE MO WITH DISCREPANCY ON PLAN VS OUTPUT BY PRODLINE AND DATE
	SELECT DISTINCT
		MONO, PRODLINE
		INTO #OUTPUT_DIFF
	FROM
	(
		SELECT MONO, PRODLINE, PRDQTY = [OUTPUT], [PLNQTY] = 0, DATETRAN FROM #PLN_DAILY_MO_BO_MULTI_LN_OUTPUT_VW PDM
			WHERE EXISTS(SELECT 1 FROM #CHECK_CAPACITY CAP WHERE CAP.PRODLINE = PDM.PRODLINE AND
			CAP.DATETRAN = CONVERT(VARCHAR, PDM.DATETRAN, 101) AND WITHCAP = 'T')
		UNION ALL
		SELECT MONO, PRODLINE, PRDQTY = [OUTPUT], [PLNQTY] = 0, DATETRAN FROM #PLN_DAILY_MO_BO_OUTPUT_QTY_VW PDM
			WHERE EXISTS(SELECT 1 FROM #CHECK_CAPACITY CAP WHERE CAP.PRODLINE = PDM.PRODLINE AND
			CAP.DATETRAN = CONVERT(VARCHAR, PDM.DATETRAN, 101) AND WITHCAP = 'T')
		UNION ALL
		SELECT MONO, [PRODLINE] = LINE, [PRDQTY] = 0, [PLNQTY] = QTY, [DATETRAN] = [DATE] FROM #BO_DAILY_OUTPUT BDO
			WHERE EXISTS(SELECT 1 FROM #CHECK_CAPACITY CAP WHERE CAP.PRODLINE = BDO.LINE AND
			CAP.DATETRAN = CONVERT(VARCHAR, BDO.[DATE], 101) AND WITHCAP = 'T')
	) MT
	GROUP BY MONO, PRODLINE
	HAVING SUM(PRDQTY) <> SUM(PLNQTY)

	----10. ADD MO TO #OUTPUT_DIFF WHERE   BO_HDR > OUTPUT AND MONO NOT YET IN #OUTPUT_DIFF
	INSERT INTO #OUTPUT_DIFF (MONO, PRODLINE)
	SELECT DISTINCT
		A.MONO,
		[PRODLINE] = A.LINE
	FROM BO_Hdr A
	WHERE
		A.Mfg_Loc = 'TARLAC' AND
		EXISTS(SELECT 1 FROM BO_Hdr SQ WHERE SQ.MONO = A.MONO AND SQ.LINE = A.LINE AND
				SQ.PLAN_START > CAST((GETDATE() - 30 ) AS DATE)) AND --@RECALCDAY
		(
			(SELECT SUM(SQ.PLAN_QTY) FROM BO_Hdr SQ WHERE SQ.MONO = A.MONO AND SQ.LINE = A.LINE) > -- where BO_Hdr.plan_qty > BO_DAILY_OUTPUT.qty
			ISNULL((SELECT SUM(SQ.QTY) FROM BO_DAILY_OUTPUT SQ WHERE SQ.MONO = A.MONO AND SQ.LINE = A.LINE), 0)
		) AND
		EXISTS(SELECT 1 FROM m_line SQ WHERE SQ.code = A.LINE AND SQ.active = 1) AND
		ISNULL((SELECT SUM(SQ.QTY) FROM BO_DAILY_OUTPUT SQ WHERE SQ.MONO = A.MONO AND SQ.LINE = A.LINE), 0) > 0 AND --SQ is sub queries
		NOT EXISTS(SELECT 1 FROM #OUTPUT_DIFF SQ WHERE SQ.MONO = A.MONO AND SQ.PRODLINE = A.LINE)


	----11. ADD MO TO #OUTPUT_DIFF. INCLUDES ALL MO'S WITH NO BALANCE BUT NOT POPULATED CORRECTLY. bo_hdr<=bo_daily_output
	INSERT INTO #OUTPUT_DIFF (MONO, PRODLINE)
	SELECT DISTINCT
		A.MONO,
		[PRODLINE] = A.LINE
	FROM bo_hdr A
	WHERE
		A.mfg_loc = 'TARLAC' AND
		EXISTS(SELECT 1 FROM bo_hdr SQ WHERE SQ.MONO = A.MONO AND SQ.LINE = A.LINE AND
				SQ.plan_start > CAST((GETDATE() - 30) AS DATE)) AND
		(
			(SELECT SUM(SQ.plan_qty) FROM bo_hdr SQ WHERE SQ.MONO = A.MONO AND SQ.LINE = A.LINE) <= -- not sure if this is correct <= or should be less than onlu
			ISNULL((SELECT SUM(SQ.QTY) FROM bo_daily_output SQ WHERE SQ.MONO = A.MONO AND SQ.LINE = A.LINE), 0)
		) AND
		NOT EXISTS(SELECT 1 FROM bo_daily_output SQ WHERE SQ.MONO = A.MONO AND SQ.BONO = A.BONO AND SQ.LINE = A.LINE) AND
		EXISTS(SELECT 1 FROM m_line SQ WHERE SQ.code = A.LINE AND SQ.active = 1) AND
		ISNULL((SELECT SUM(SQ.QTY) FROM bo_daily_output SQ WHERE SQ.MONO = A.MONO AND SQ.LINE = A.LINE), 0) > 0 AND
		NOT EXISTS(SELECT 1 FROM #OUTPUT_DIFF SQ WHERE SQ.MONO = A.MONO AND SQ.PRODLINE = A.LINE)


	----12 ADD MO TO #OUTPUT_DIFF. INCLUDES ORPHAN OUTPUT IN bo_daily_output ----
	INSERT INTO #OUTPUT_DIFF (MONO, PRODLINE)
	SELECT DISTINCT
		A.MONO,
		[PRODLINE] = A.LINE
	FROM bo_daily_output A WITH (NOLOCK)
	INNER JOIN m_line LN WITH (NOLOCK) ON
		LN.code = A.LINE AND
		LN.mfg_loc = 'TARLAC' AND
		LN.active = 1 AND
		EXISTS(SELECT 1 FROM #MO_LIST SQ WHERE SQ.MONO = A.MONO) AND
		NOT EXISTS(SELECT 1 FROM #PLN_BO_HDR_VW SQ WHERE SQ.MONO = A.MONO AND SQ.BONO = A.BONO AND SQ.LINE = A.LINE)

	DROP TABLE #PLN_BO_HDR_VW

	--GET ALL THE MO PLANNED IN MULTI LINE OUTPUT and WITH CAPACITY and OUTPUT HAS DIFFERENCE
	DECLARE MOCUR CURSOR LOCAL FOR
 	SELECT MONO, PRODLINE, DATETRAN, [OUTPUT] FROM #PLN_DAILY_MO_BO_MULTI_LN_OUTPUT_VW PDM
	WHERE EXISTS(SELECT 1 FROM #OUTPUT_DIFF OD WHERE OD.MONO = PDM.MONO AND OD.PRODLINE = PDM.PRODLINE) AND
		  EXISTS(SELECT 1 FROM #CHECK_CAPACITY CAP WHERE CAP.PRODLINE = PDM.PRODLINE AND
			CAP.DATETRAN = CONVERT(VARCHAR, PDM.DATETRAN, 101) AND WITHCAP = 'T')
	ORDER BY MONO, PRODLINE, DATETRAN


	OPEN MOCUR
	FETCH NEXT FROM MOCUR INTO @MONO, @MOLINE, @OUTPUTDT, @OUTPUTQTY

	WHILE @@FETCH_STATUS = 0
	BEGIN

		SET @REMOUTQTY = 0

		IF NOT EXISTS (SELECT 'X' FROM #BO_HDR WHERE MONO = @MONO AND LINE = @MOLINE)
		BEGIN

			--INITIALLY WILL INSERT THE DATE TO BO_HDR. THIS IS MULTIPLE RESULT 1 MO 1 LINE MULTIPLE BO
			INSERT INTO #BO_HDR
			SELECT
				BONO, MONO, LINE, plan_start, plan_qty, plan_qty
			FROM bo_hdr WITH (NOLOCK)
			WHERE MONO = @MONO AND LINE = @MOLINE
			ORDER BY BONO, plan_start

			SET @ROWID = 0

		END

		-- SET THE BALANCE QTY.
		IF @REMOUTQTY > 0
			SET @REMOUTQTY = @REMOUTQTY + @OUTPUTQTY
		ELSE
			SET @REMOUTQTY = @OUTPUTQTY

		--GET THE COUNT WHERE BALANCE > 0
		SELECT @RECCNT = COUNT(1) FROM #BO_HDR WHERE MONO = @MONO AND LINE = @MOLINE AND REMPLNQTY > 0

		-- I DONT KNOW
		IF @RECCNT = 0 AND (SELECT COUNT(1) FROM #BO_HDR WHERE MONO = @MONO AND LINE = @MOLINE) > 0
		BEGIN
			SET @ROWID = @ROWID + 1
			INSERT INTO #TMP_OUTPUT VALUES(@MONO, @BONO, @BOLINE, @OUTPUTDT, @OUTPUTQTY, @PLAN_QTY, @ROWID)
		END

		SELECT @BOCNT = COUNT(1) FROM #BO_HDR WHERE MONO = @MONO AND LINE = @MOLINE AND REMPLNQTY > 0

		SET @RECCNT2 = 0

				-- LOOP THE DETAILS 1 MONO and MULTIPLE BO
				DECLARE BOCUR CURSOR LOCAL FOR
				SELECT BONO, MONO, LINE, plan_start, plan_qty, REMPLNQTY FROM #BO_HDR
				WHERE MONO = @MONO AND LINE = @MOLINE AND REMPLNQTY > 0 ORDER BY plan_start

				OPEN BOCUR
				FETCH NEXT FROM BOCUR INTO @BONO, @BOMONO, @BOLINE, @PLAN_START, @PLAN_QTY, @REM_PLN_QTY

				WHILE @@FETCH_STATUS = 0
				BEGIN
					SET @RECCNT2 = @RECCNT2 + 1

					-- CHECK DATA HERE
					--select @BONO BONO, @BOMONO BOMONO, @BOLINE BOLINE, @PLAN_START PLAN_START, @PLAN_QTY PLAN_QTY, @OUTPUTQTY OUTPUTQTY, @REM_PLN_QTY REM_PLN_QTY, @RECCNT2 as RECCNT2, @REMOUTQTY as REMOUTQTY

					SET @ROWID = @ROWID + 1
					IF @REMOUTQTY <= 0
						GOTO NEXTLINE

					IF @REMOUTQTY >= @REM_PLN_QTY
					BEGIN
						SET @TOTOUTQTY = @REM_PLN_QTY
						UPDATE #BO_HDR SET REMPLNQTY = 0 WHERE BONO = @BONO AND MONO = @MONO AND LINE = @BOLINE
					END
					ELSE IF @REMOUTQTY < @REM_PLN_QTY
					BEGIN
						SET @TOTOUTQTY = @REMOUTQTY
						UPDATE #BO_HDR SET REMPLNQTY = @REM_PLN_QTY - @TOTOUTQTY WHERE BONO = @BONO AND MONO = @MONO AND LINE = @BOLINE
					END


					IF @RECCNT = 1 OR @RECCNT2 = @BOCNT
					BEGIN
						SET @TOTOUTQTY = @REMOUTQTY
					END

					SET @REMOUTQTY = @REMOUTQTY - @TOTOUTQTY

					IF @TOTOUTQTY > 0
						INSERT INTO #TMP_OUTPUT VALUES(@MONO, @BONO, @BOLINE, DATEADD(SECOND,@ROWID,@OUTPUTDT), @TOTOUTQTY, @PLAN_QTY, @ROWID)

					NEXTLINE:
					FETCH NEXT FROM BOCUR INTO @BONO, @BOMONO, @BOLINE, @PLAN_START, @PLAN_QTY, @REM_PLN_QTY
				END

		CLOSE BOCUR
		DEALLOCATE BOCUR

 	FETCH NEXT FROM MOCUR INTO @MONO, @MOLINE, @OUTPUTDT, @OUTPUTQTY
	END

	CLOSE MOCUR
	DEALLOCATE MOCUR

	--select * from #BO_HDR

	SELECT O.* INTO #BOOUT FROM
	(SELECT OUTPUTDT AS DATETRAN, MONO, BONO, LINE AS PRODLINE, OUTPUTQTY AS [OUTPUT] FROM #TMP_OUTPUT
	UNION ALL
	SELECT DATETRAN, MONO, BONO, PRODLINE, [OUTPUT] FROM #PLN_DAILY_MO_BO_OUTPUT_QTY_VW PD
	WHERE EXISTS(SELECT 1 FROM #OUTPUT_DIFF OD WHERE OD.MONO = PD.MONO AND OD.PRODLINE = PD.PRODLINE) AND
		  EXISTS(SELECT 1 FROM #CHECK_CAPACITY CAP WHERE CAP.PRODLINE = PD.PRODLINE AND
			CAP.DATETRAN = CONVERT(VARCHAR, PD.DATETRAN, 101) AND WITHCAP = 'T')
		  --DBO.PRDCHECKCAPACITYFN(PRODLINE, DATETRAN) = 'T'
	) AS O

	DELETE BDO
	FROM bo_daily_output BDO
	WHERE
		EXISTS(SELECT 1 FROM #OUTPUT_DIFF OD WHERE OD.MONO = BDO.MONO AND OD.PRODLINE = BDO.LINE) --AND
		--BDO.[DATE] >= CAST((GETDATE() - @RECALCDAY) AS DATE)

	declare @retCount int
	SELECT @retCount  = count(MONO) from #BOOUT

	INSERT INTO bo_daily_output
		([MONO],[BONO],[LINE],[DATE],[QTY],[TARGET_QTY],[CREATED_BY],[TIME_CREATED], SBU_ID)
	SELECT MO.MONO, MO.BONO, MO.PRODLINE, MO.DATETRAN, MO.OUTPUT, 0, @USERID, GETDATE(), 1
	FROM #BOOUT AS MO

	--update the bo_hdr output here
	update bb set total_output_qty =  aa.output_qty, Trans_Id = @transId
 	from (
				select a.MONo, a.BONo, a.line, sum(Qty) as output_qty
				from bo_daily_output a
				where exists(select 1 from #BOOUT sq where sq.mono = a.MONo and sq.prodline = a.line and a.BONo = sq.bono )
				group by a.MONo, a.BONo, a.line
 	) aa
	inner join BO_Hdr bb on aa.MONO = bb.MONo and aa.BONO = bb.BONo and aa.Line = bb.Line

/*
	UPDATE MH
	SET MH.PLANCOMPLETED = CASE
								WHEN MH2.MOQTY > 0 AND MH2.MOQTY <= MH2.OUTQTY AND MH2.MOQTY <= MH2.PLNQTY THEN 1
								ELSE 0
						   END
	FROM MOHDR MH
	INNER JOIN
	(
		SELECT
			MH.MONO,
			[MOQTY] = SUM(MD.QTY),
			[PLNQTY] = ISNULL((SELECT SUM(BH.plan_qty) FROM bo_hdr BH WITH (NOLOCK) WHERE BH.MONO = MH.MONO), 0),
			[OUTQTY] = ISNULL((SELECT SUM(BD.QTY) FROM bo_daily_output BD WITH (NOLOCK) WHERE BD.MONO = MH.MONO), 0)
		FROM MOHDR MH WITH (NOLOCK)
		INNER JOIN MODET MD WITH (NOLOCK) ON
			MD.MONO = MH.MONO
		WHERE
			MH.mfg_loc = 'TARLAC' AND
			MH.MOSTATUS NOT IN ('CANCELLED', 'COMPLETE')
		GROUP BY MH.MONO
		HAVING
			MAX(MD.PODDT) > (DATEADD(DD, DATEDIFF(DD, 0, GETDATE()), -@PLANCOMPLETEDDAYMIN))
	) MH2 ON
		MH2.MONO = MH.MONO
	WHERE
		@PLANCOMPLETEDDAY = 0 OR
		(SELECT MAX(SQ.PLANFINISH) FROM bo_hdr SQ WHERE SQ.MONO = MH.MONO) <= ((DATEADD(DD, DATEDIFF(DD, 0, GETDATE()), 0)) - @PLANCOMPLETEDDAY)*/

	DROP TABLE #BOOUT
	DROP TABLE #TMP_OUTPUT
	DROP TABLE #BO_HDR
	DROP TABLE #PLN_DAILY_MO_BO_MULTI_LN_OUTPUT_VW
	DROP TABLE #PLN_DAILY_MO_BO_OUTPUT_QTY_VW
	DROP TABLE #BO_DAILY_OUTPUT
	DROP TABLE #OUTPUT_DIFF
	DROP TABLE #CHECK_CAPACITY
	DROP TABLE #MO_LIST


	--SELECT @retCount AS code, 'UPDATE COMPLETE' AS description
--ROLLBACK TRAN
END TRY
BEGIN CATCH
	SELECT 1 AS ERROR_FLAG, ERROR_MESSAGE() AS ERROR_MSG
	--ROLLBACK TRAN
END CATCH
go

CREATE FUNCTION dbo.AllocateTarget (@TotalTarget DECIMAL(18, 2), @DailyTarget DECIMAL(18, 2))
RETURNS @BalanceTable TABLE (
	id INT,
	total_target INT,
	daily_target INT,
	running_value INT,
 	balance INT
)
AS
BEGIN
	DECLARE @Remaining INT;
	DECLARE @RunningValue INT = 0;
  DECLARE @Counter int = 1;

	-- Set the remaining amount to the total target
	SET @Remaining = @TotalTarget;

	-- Loop through the table and deduct daily targets until there is no remaining balance
	WHILE @Remaining > 0
	BEGIN

		-- Deduct the daily target from the remaining amount
		SET @Remaining = @Remaining - @DailyTarget;
		SET @RunningValue = @RunningValue + @DailyTarget;

		-- Check if the remaining amount is less than the daily target
		IF @Remaining <= 0
		BEGIN
			-- Set the daily target to the remaining amount
			SET @DailyTarget = @DailyTarget + @Remaining;

			SET @RunningValue = @RunningValue + @Remaining;
		END

		-- Insert the balance into the temp table
		INSERT INTO @BalanceTable (id, total_target, daily_target, running_value,  balance)
		SELECT @Counter, @TotalTarget, @DailyTarget, @RunningValue, @Remaining;

		-- Delete the row if the balance is zero
		/*DELETE FROM YourTable
		WHERE Balance = 0;*/
    set @Counter +=1; 
	END

	-- Return the temp table
	RETURN;
END
go






-- =============================================
-- Author:		CAE
-- Create date: 03252018
-- Description:	Sync from Deluxe by Mfg Loc
-- =============================================
CREATE PROCEDURE [dbo].[stg_ordSyncDLData]
	-- Add the parameters for the stored procedure here
	--@Server		varchar(20),
	@UserId		NVARCHAR(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	BEGIN TRY
	
	--BEGIN TRANSACTION

	DECLARE @LastRunTime AS Datetime
	DECLARE @CurrRunTime AS Datetime
	DECLARE @SrcERP AS VARCHAR(20)

	DECLARE @RecId AS varchar(100)

	Set @RecId = NEWID()

	INSERT INTO [dbo].[stg_SyncLog]([Recid],[RunTime],[CreatedBy],[Remarks])
     VALUES(@RecId, getdate(), @UserId, 'DL-Init.')

	Set @SrcERP = 'DL'

	Select @CurrRunTime = SrvDt from [Link_DLXSRV].[XDB].[dbo].[iMAPPSInterface_GetDate_vw]

	BEGIN		
/* remarks by donel
		--UPDATE dbo.stg_InterfaceMfgLocRT SET PrevRuntime = LastRunTime where ServerName = @SrcERP  --remarks by donel
		
		SELECT top 1 @LastRunTime = isnull(LastRunTime,getdate()) From dbo.stg_InterfaceMfgLocRT where ServerName = @SrcERP
		--Select * from InterfaceMfgLocRT
		UPDATE dbo.stg_InterfaceMfgLocRT SET LastRunTime = @CurrRunTime where ServerName = @SrcERP
*/
		UPDATE dbo.app_config SET prev_run_dt = last_run_dt where Server_Name = @SrcERP 
		SELECT top 1 @LastRunTime = isnull(last_run_dt,getdate()) From dbo.app_config where server_name = @SrcERP
		--Select * from InterfaceMfgLocRT
		UPDATE dbo.app_config SET last_run_dt = @CurrRunTime where server_name = @SrcERP

		--Insert CustGrp
		SELECT distinct [MfgLoc],[CustGrp] into #CustGrp
			FROM [Link_DLXSRV].[XDB].[dbo].[iMAPPSInterface_IODet_vw] 

		insert into stg_CustGrpSplitHdr(MfgLoc, CustGrp)
		Select cg.MfgLoc, cg.CustGrp from #CustGrp cg left outer join stg_CustGrpSplitHdr h on cg.MfgLoc = h.MfgLoc and cg.CustGrp = h.CustGrp
		Where h.MfgLoc is null

		drop table #CustGrp

/*	
		--create Customer Group
		--select * from [Link_DLXSRV].[XDB].[dbo].CustGrpByPlant
		INSERT INTO [dbo].[SyncCustGrp]
			([CustGrp]
			,[Description]
			,[CreatedDt]
			,[SrcERP])
		select CustGrp, LongText AS [Description], getdate() AS CreatedDt, @SrcERP AS SrcERP 
			from [Link_DLXSRV].[XDB].[dbo].iMAPPSInterface_CustGrp_vw 
			Where MfgLoc in (Select MfgLoc from dbo.InterfaceMfgLocRT)-- where ServerName = @Server) 
			AND CreatedDt >= @LastRunTime
		
		--create Customer
		--select * from [Link_DLXSRV].[XDB].[dbo].CustomerACTRefByPlant_vw
		INSERT INTO [dbo].[SyncCustomer]
			([CustomerCd]
			,[CustAcctGrp]
			,[CustGrp]
			,[Name]
			,[CreatedDt]
			,[SrcERP])
		select CustomerCd, CustAcctGrp, CustGrp, Name1 AS [Name], getdate() AS CreatedDt, @SrcERP AS SrcERP
			from [Link_DLXSRV].[XDB].[dbo].iMAPPSInterface_Customer_vw 
			Where MfgLoc in (Select MfgLoc from dbo.InterfaceMfgLocRT)-- where ServerName = @Server) 
			AND Create_Dt >= @LastRunTime

		--create Sales Group
		--select * from [Link_DLXSRV].[XDB].[dbo].SalesGrpByPlant 
		INSERT INTO [dbo].[SyncSalesGrp]
			([SalesGrp]
			,[Description]
			,[CreatedDt]
			,[SrcERP])
		select SalesGrp, LongText AS [Description], getdate() AS CreatedDt, @SrcERP AS SrcERP
			from [Link_DLXSRV].[XDB].[dbo].iMAPPSInterface_SalesGrp_vw  
			Where MfgLoc in (Select MfgLoc from dbo.InterfaceMfgLocRT)-- where ServerName = @Server) 
			AND CreatedDt >= @LastRunTime
		
		--create Plant
		--select * from [Link_YTISRV].YTI_ERP.dbo.Plant
		INSERT INTO [dbo].[SyncPlant]
			([PlantCd]
			,[Description]
			,[CreatedDt]
			,[SrcERP])
		select PlantCd, [ShortText] AS [Description], getdate() AS CreatedDt, @SrcERP AS SrcERP
			from [Link_YTISRV].YTI_ERP.dbo.iMAPPSInterface_Plant_vw 
			Where MfgLoc in (Select MfgLoc from dbo.InterfaceMfgLocRT)-- where ServerName = @Server) 
			AND CreatedDt >= @LastRunTime
*/		
		--create IODetail
		--Zero out all transffered MfgLoc
		DECLARE @iCnt AS int
		Update dbo.stg_SyncLog set Remarks = 'DL-Change MfgLoc Count.' Where RecId = @RecId
		/*remarks by donel
			Select @iCnt = count(1)
			FROM [Link_DLXSRV].[XDB].[dbo].[iMAPPSInterface_IODet_vw] AS iIO inner join IO_Det iod 
				ON iIO.IONo = iod.IO_No AND iIO.CONo = iod.CONo AND iIO.Color = iod.Color AND iIO.Size = iod.Size
			Where [PrevMfgLoc] in (Select Mfg_Loc from dbo.app_config Where Server_Name = @SrcERP) 
			AND [MfgLoc] not in (Select Mfg_Loc from dbo.app_config Where Server_Name = @SrcERP)
			AND iod.Qty <> 0
			AND iIO.[UpdatedDt] >= @LastRunTime
*/
		set @iCnt = 0
		if @iCnt > 0
		BEGIN
			Update dbo.stg_SyncLog set Remarks = 'DL-Change MfgLoc.' Where RecId = @RecId

			INSERT INTO [dbo].[IO_Sync]
				([sbu_id],[IONo],[Cust_PONo],[Cust_PO_Dt],[Cust_PO_Item],[Order_Type],[Order_Status],[Cust_Style],[Cust_Style_Desc],[Cust_Color]
				,[Cust_Size],[Ship_To_Cust],[Style_No],[Color],[Color_Desc],[Size],[Dest],[Req_Qty],[UOM],[Delivery_Dt],[Cust_Del_Dt],[Plant]
				,[Season],[Sales_Grp],[Cust_Grp],[Sold_To_Cust],[Bill_To_Cust],[Ship_Mode],[No_Of_Pcs],[CONo],[SO_Remarks]
				,[Updated_By],[Time_Updated],[Time_Created],[Src_ERP],[Mfg_Loc],[Prod_Type],[Prod_Type_Desc],[Merch_SMV],[Tc_SMV],[LPD_Dt],[Webbing],Plan_Dt,Fty_Del_Dt,Shipped_Qty
				,RS_Dt,VSL_Dt,Ex_Fty_Dt,Sales_Ord_Type,IO_Ln)

			SELECT b.sbu_id,[IONo],[CustPONo],[CustPODt],[CustPOItem],[OrderType],[OrderStatus],[CustStyle],[CustStyleDesc],Left([CustColor],20)
				,[CustSize],[ShipToCust],[StyleNo],left([Color],20),[ColorDesc],[Size],[Dest],0,[UOM],[DeliveryDt],[CustDelDt],[Plant]
				,[Season],[SalesGrp],[CustGrp],[SoldToCust],[BillToCust],[ShipMode],[NoOfPcs],[CONo],left([Remarks],50)
				,[UpdatedBy],[UpdatedDt],getdate() AS CreatedDt,@SrcERP AS SrcERP, [PrevMfgLoc],[ProdTyp],[ProdTypDesc],[MerchSMV],[TcSMV],[LPDDt],[Webbing],Parse([PlanMonth] as Date),[CustDelDt],ShippedQty
				,ReqShipDt,ConShipDt,RevShipDt,SalesOrdTyp,MOLn
				FROM [Link_DLXSRV].[XDB].[dbo].[iMAPPSInterface_IODet_vw] a
				inner join app_config b on b.mfg_loc = a.mfgloc
				Where [PrevMfgLoc] in (Select Mfg_Loc from dbo.app_config Where Server_Name = @SrcERP) 
				AND [MfgLoc] not in (Select Mfg_Loc from dbo.app_config Where Server_Name = @SrcERP)
				AND [UpdatedDt] >= @LastRunTime
		END

		--select distinct IONo into #IO from [Link_DLXSRV].[XDB].[dbo].[iMAPPSInterface_IODet_vw] Where 
		--UpdatedDt = '2019-10-22 05:00:00' and MfgLoc= 'CDLX1'

		--create IODetail
		Update dbo.stg_SyncLog set Remarks = 'DL-Insert SyncIO.' Where RecId = @RecId

		INSERT INTO [dbo].[IO_Sync]
			([sbu_id],[IONo],[Cust_PONo],[Cust_PO_Dt],[Cust_PO_Item],[Order_Type],[Order_Status],[Cust_Style],[Cust_Style_Desc],[Cust_Color]
			,[Cust_Size],[Ship_To_Cust],[Style_No],[Color],[Color_Desc],[Size],[Dest],[Req_Qty],[UOM],[Delivery_Dt],[Cust_Del_Dt],[Plant]
			,[Season],[Sales_Grp],[Cust_Grp],[Sold_To_Cust],[Bill_To_Cust],[Ship_Mode],[No_Of_Pcs],[CONo],[SO_Remarks]
			,[Updated_By],[Time_Updated],[Time_Created],[Src_ERP],[Mfg_Loc],[Prod_Type],[Prod_Type_Desc],[Merch_SMV],[Tc_SMV],[LPD_Dt],AS400_IO_No,[Webbing],Plan_Dt,Fty_Del_Dt,Shipped_Qty
			,RS_Dt,VSL_Dt,Ex_Fty_Dt,Sales_Ord_Type,IO_Ln)

		SELECT b.sbu_id,[IONo],[CustPONo],[CustPODt],[CustPOItem],[OrderType],[OrderStatus],[CustStyle],[CustStyleDesc],left([CustColor],20)
			,[CustSize],[ShipToCust],[StyleNo],left([Color],20),[ColorDesc],[Size],[Dest],[ReqQty],[UOM],[DeliveryDt],[CustDelDt],[Plant]
			,[Season],[SalesGrp],[CustGrp],[SoldToCust],[BillToCust],[ShipMode],[NoOfPcs],[CONo],left([Remarks],50)
			,[UpdatedBy],[UpdatedDt],getdate() AS CreatedDt,@SrcERP AS SrcERP, [MfgLoc],[ProdTyp],[ProdTypDesc],[MerchSMV],[TcSMV],[LPDDt],[AS400IONo],[Webbing],Parse([PlanMonth] as Date),[CustDelDt],ShippedQty
			,ReqShipDt,ConShipDt,RevShipDt,SalesOrdTyp,MOLn
			FROM [Link_DLXSRV].[XDB].[dbo].[iMAPPSInterface_IODet_vw] a
			inner join app_config b on b.mfg_loc = a.mfgloc
			Where [MfgLoc] in (Select Mfg_Loc from dbo.app_config Where Server_Name = @SrcERP)-- where ServerName = @Server) 
			AND [UpdatedDt] >= @LastRunTime
			--or IONo in (Select IONo from #IO)
			--or IONo 
			--in
			--('12195602',
			--'12195602',
			--'12195701',
			--'12195901',
			--'12195901',
			--'12195901',
			--'12196001',
			--'12196001',
			--'12196001')

		--create CMPrice
		--SELECT * FROM [Link_YTISRV].YTI_ERP.dbo.PMSInterface_CMPrice_ByPlant_vw
		/*
		INSERT INTO [dbo].[SyncCMPrice]
			([IONo]
			,[CostCat]
			,[UnitPrice]
			,[UpdatedBy]
			,[UpdatedDt]
			,[CreatedDt]
			,[SrcERP])
		select IONo, CostCat, UnitPrice, UpdatedBy, UpdatedDt, getdate() AS CreatedDt,@SrcERP AS SrcERP 
			from [Link_YTISRV].YTI_ERP.dbo.iMAPPSInterface_CMPrice_vw 
			Where [MfgLoc] in (Select MfgLoc from dbo.InterfaceMfgLocRT)-- where ServerName = @Server) 
			AND [UpdatedDt] >= @LastRunTime
		*/

		Update io_sync Set Order_Type = 'IO' Where Order_Type = 'Regular'
	--COMMIT TRANSACTION
		Update dbo.stg_SyncLog set Remarks = 'create maintenance' Where RecId = @RecId

		-----Create File Maintenance
		--- insert m_cust_style
		insert into m_cust_style (active, created_by, sbu_id, time_created, time_updated, updated_by, code, description )
		select distinct 1,@UserId,a.sbu_id, getdate(), NULL,NULL, a.cust_style, a.cust_style 
		from io_sync a
		where cast(a.sbu_id as varchar(10)) + a.cust_Style not in (select cast(sbu_id as varchar(10)) + code from m_cust_style )

		--update cust_style_id 
		update io_sync set cust_style_id = b.id 
		from io_sync a
		inner join m_cust_style b on b.sbu_id = a.sbu_id and b.code = a.cust_style
		where a.cust_style_id is null

		--update mfg_loc_id
		update io_sync set mfg_loc_id = b.id 
		from io_sync a
		inner join m_mfg_locs b on b.code = a.mfg_loc
		where a.mfg_loc_id is null

		--insert m_order_status
		insert into m_order_status (active, created_by, sbu_id, time_created, time_updated, updated_by, code, description )
		select distinct 1,@UserId,a.sbu_id, getdate(), NULL,NULL, a.order_status, a.order_status 
		from io_sync a
		where cast(a.sbu_id as varchar(10)) + a.order_status not in (select cast(sbu_id as varchar(10)) + code from m_order_status )

		--update order_status_id 
		update io_sync set order_status_id = b.id 
		from io_sync a
		inner join m_order_status b on b.sbu_id = a.sbu_id and b.code = a.order_status
		where a.order_status_id is null

		--insert m_prod_type
		insert into m_prod_type (active, created_by, sbu_id, time_created, time_updated, updated_by, code, description )
		select distinct 1,@UserId,a.sbu_id, getdate(), NULL,NULL, a.prod_type, a.prod_type_desc 
		from io_sync a
		where cast(a.sbu_id as varchar(10)) + a.prod_type not in (select cast(sbu_id as varchar(10)) + code from m_prod_type )

		--update prod_type_id 
		update io_sync set prod_type_id = b.id 
		from io_sync a
		inner join m_prod_type b on b.sbu_id = a.sbu_id and b.code = a.prod_type
		where a.prod_type_id is null

		--insert m_sales_grp
		insert into m_sales_grp (active, created_by, sbu_id, time_created, time_updated, updated_by, code, description )
		select distinct 1,@UserId,a.sbu_id, getdate(), NULL,NULL, a.sales_grp, a.sales_grp 
		from io_sync a
		where cast(a.sbu_id as varchar(10)) + a.sales_grp not in (select cast(sbu_id as varchar(10)) + code from m_sales_grp )

		--update sales_grp_id 
		update io_sync set sales_grp_id = b.id 
		from io_sync a
		inner join m_sales_grp b on b.sbu_id = a.sbu_id and b.code = a.sales_grp
		where a.sales_grp_id is null

		--insert m_season
		insert into m_season (active, created_by, sbu_id, time_created, time_updated, updated_by, code, description )
		select distinct 1,@UserId,a.sbu_id, getdate(), NULL,NULL, a.season, a.season 
		from io_sync a
		where cast(a.sbu_id as varchar(10)) + a.season not in (select cast(sbu_id as varchar(10)) + code from m_season )

		--update season_id 
		update io_sync set season_id = b.id 
		from io_sync a
		inner join m_season b on b.sbu_id = a.sbu_id and b.code = a.season
		where a.season_id is null

		--update ship_mode
		update io_sync set ship_mode_id = b.id 
		from io_sync a
		inner join m_ship_mode b on  b.code = a.ship_mode
		where a.ship_mode_id is null

		--insert m_season
		insert into m_destination (active, created_by, sbu_id, time_created, time_updated, updated_by, code, description )
		select distinct 1,@UserId,a.sbu_id, getdate(), NULL,NULL, a.dest, a.dest 
		from io_sync a
		where cast(a.sbu_id as varchar(10)) + a.dest not in (select cast(sbu_id as varchar(10)) + code from m_destination )

		--update dest_id
		update io_sync set dest_id = b.id 
		from io_sync a
		inner join m_destination b on  b.code = a.dest
		where a.dest_id is null

		--update order_type_id
		update io_sync set order_type_id = b.id 
		from io_sync a
		inner join m_order_types b on  b.code = a.order_type
		--where a.dest_id is null

		Update dbo.stg_SyncLog set Remarks = 'DL-Completed.' Where RecId = @RecId



	END
/*
	Update io_sync Set Order_Type = 'IO' Where Order_Type = 'Regular'
	--COMMIT TRANSACTION
	Update dbo.stg_SyncLog set Remarks = 'DL-Completed.' Where RecId = @RecId
*/	
	END TRY
	
	BEGIN CATCH
		IF (@@TRANCOUNT > 0)
		--SELECT 1 AS ERROR_MSG
			--SELECT ERROR_MESSAGE() AS ERROR_MSG
			Update dbo.stg_SyncLog set Remarks = left('DL-' + ERROR_MESSAGE(),2000) Where Recid = @RecId
			--ROLLBACK TRANSACTION	
	END CATCH	
END


go

CREATE procedure bo_hdr_recalculate_confirm
	@recId VARCHAR(50) =''
AS

-- 	begin transaction
-- 	rollback transaction
-- 	declare @recId VARCHAR(50) =''
-- 	set @recId = '65451468-3bbf-4f40-8180-ec0ba6bc7f7f'

	delete from bo_hdr_deleted where rec_id = @recId
	--1. BACKUP FIRST THE FOR DELETE
	INSERT INTO bo_hdr_deleted (id, mono, bono, mfg_loc, Line, MO_Qty, cp_no, plan_qty, smv, eff, plan_start, plan_finish,
							actual_start, actual_finish, plant_color, Prd_Typ, Prd_Typ2 , total_output_qty,
							prod_month, completed, created_by, time_created, time_updated, MO_Cus_Del_Dt  , Trans_Id, Updated_By, rec_id,active, sbu_id)
	select b.id, a.mono, a.bono, a.mfg_loc, a.Line, a.MO_Qty, a.cp_no, a.plan_qty, a.smv, a.eff, a.plan_start, a.plan_finish,
							a.actual_start, a.actual_finish, a.plant_color, a.Prd_Typ, a.Prd_Typ2 , a.total_output_qty,
							a.prod_month, a.completed, a.created_by, a.time_created, a.time_updated, a.MO_Cus_Del_Dt  , a.Trans_Id, a.Updated_By,
							a.rec_id, a.active, a.sbu_id
	from bo_hdr_recalculate a
		inner join bo_hdr b on a.MONo = b.MONo and a.Line = b.Line and a.BONo = b.BONo
	where  rec_id = @recId and a.active = 1

	--2. DELETE ALL THE DATA IN BO_HDR where tmp and bo_hdr is the same
	DELETE b
	from bo_hdr_recalculate a
		inner join bo_hdr b on a.MONo = b.MONo and a.Line = b.Line and a.BONo = b.BONo
	where  a.rec_id = @recId and a.active = 1

	--3 INSERT THE DATA NOW FROM TMP TO BO_HDR
	INSERT INTO BO_Hdr(mono, bono, mfg_loc, Line, MO_Qty, cp_no, plan_qty, smv, eff, plan_start, plan_finish,
							actual_start, actual_finish, plant_color, Prd_Typ, Prd_Typ2 , total_output_qty,
							prod_month, completed, created_by, time_created, time_updated, MO_Cus_Del_Dt  , Trans_Id, Updated_By, active, sbu_id, step_no, re_order_seq)
	select a.mono, a.bono, a.mfg_loc, a.Line, MO_Qty, a.cp_no, a.plan_qty, a.smv, a.eff, a.plan_start, plan_finish,
							a.actual_start, a.actual_finish, a.plant_color, a.Prd_Typ, a.Prd_Typ2 , a.total_output_qty,
							a.prod_month, a.completed, a.created_by, a.time_created, a.time_updated, a.MO_Cus_Del_Dt, a.rec_id, a.Updated_By, active, sbu_id, step_no, a.re_order_seq
	from bo_hdr_recalculate a
	where  rec_id =   @recId
				 and a.active = 1

	declare @date date = getdate()
	declare @line varchar(10) = ''

	--RE ARRANGE ORDER SEQ TO RE PROPROCESS
		--SELECt b.*
	if exists(
		SELECT 'x' from bo_hdr_recalculate a
		inner join BO_Hdr b on a.MONo = b.MONo and a.BONo = b.BONo and a.rec_id = b.Trans_Id
		where  rec_id =  @recId
		and a.active = 1 and a.step_no = '5'
	)
	BEGIN
			update b set re_order_seq = a.re_order_seq, step_no = a.step_no
			from bo_hdr_recalculate a
			inner join BO_Hdr b on a.MONo = b.MONo and a.BONo = b.BONo and a.rec_id = b.Trans_Id
			where  rec_id =  @recId
						 and a.active = 1 and a.step_no = '5'
			--RE ARRANGE PLANNING. CALCULATE PLAN FINISH
			exec usp_rearrange_planning_while_loop @recId =@recId, @createdBy ='System', @dateFrom=@date, @dateTo=@date
	END

	select top 1 @line = line  from bo_hdr_recalculate where rec_id = @recId and active = 1
go


--exec usp_execute_report_wip   @reportName = 'GetProcessHdr',  @start= 0, @length = 100, @overall = 1,  @mono = '10519101001'
CREATE procedure [dbo].[usp_execute_report_wip]
--declare
	@reportName  varchar(50) = 'GetDashboardBySetAndDateRange',
	@mono varchar(8000) ='',
	@svap varchar(10) ='',
	@start int  = 0,
	@length int = 15,
	@dateFrom datetime = '1/1/1900',
	@dateTo datetime = '1/1/1900',
	@overall bit = 0,
	@status varchar(50) = '',
	@material varchar(50) = '',
	@id varchar(100) = '',
	@bundleNo int = 0,
	@origin varchar(10) = '',
	@destination varchar(10) = '',
 	@season varchar(10) = '',
	@prodLine varchar(MAX) = '',
	@workSection varchar(20) = '',
	@type varchar(20) = 'output',
	@style varchar(30) ='',
	@color varchar(30) ='',
	@deliveryYearMonth varchar(6) ='',
	@search varchar(100) = '%',
	@process varchar(100) = '%',
	@bundleList varchar(100) = '%',
	@year varchar(100) = '',
	@week varchar(100) = '',
	@dateCategory varchar(100) = '',
	@summaryBy varchar(100) = ''
AS

------GET SETTINGS IN WIP_SETTINGS ------
declare @company varchar(10) = (select settings from wip_settings (nolock) where code = '@company')
declare @AssyPack varchar(15) = (select settings from wip_settings (nolock) where code = '@AssyPack')
declare @ProductionHeadcount int = (select settings from wip_settings (nolock) where code = '@ProductionHeadcount')
declare @ProductionWorkingMinutes int  = (select settings from wip_settings (nolock) where code = '@ProductionWorkingMinutes')
declare @TargetPercentage numeric(12,2) = (select settings from wip_settings (nolock) where code = '@TargetPercentage')
declare @csm varchar(20) = (select settings from wip_settings (nolock) where code = '@csm')
declare @str varchar(20) = (select settings from wip_settings (nolock) where code = '@str')
declare @bpp varchar(20) = (select settings from wip_settings (nolock) where code = '@bpp')
declare @cut varchar(20) = (select settings from wip_settings (nolock) where code = '@cut')

--------------------------------------------------------------------------------------------------
declare @nodates bit = (case when @dateFrom = '1/1/1900' or @dateTo = '1/1/1900' then 1 else 0 end)
--SET @dateFrom = (case when @dateFrom = '1/1/1900' then convert(date,GETDATE()) else @dateFrom end)
SET @dateTo = (case when @dateTo = '1/1/1900' then convert(date,GETDATE()) else @dateTo end)

IF @overall = 1
	BEGIN
		SET @dateFrom = '1/1/1900'
		SET @dateTo = (case when @dateTo = '1/1/1900' then convert(date,GETDATE()) else @dateTo end)
	END
 -----------------------------------------------------------------------------------------
	declare @rtnTable TABLE
	(
		moNo nvarchar(20) NOT NULL,
		Style nvarchar(30),
		Color  nvarchar(30),
		OrderQty int NOT NULL,
		CusDelDt date,
		Season varchar(10),
		CUT int NOT NULL,
		SKI int NOT NULL,
		GLU int NOT NULL,
		FCUT int NOT NULL,
		CUTCONS int NOT NULL,
		BPP int NOT NULL,
		BPPEMB int NOT NULL,
		BPPINK1 int NOT NULL,
		BPPLNG int NOT NULL,
		BPPSTR int NOT NULL,
		INK2 int NOT NULL,
		ASS int NOT NULL,
		id int NOT NULL,
		CCON int,
	  CEN int,
		HDL int,
		COM int
	)

	set @start = @start + 1
	declare @totalRecords int

--exec usp_execute_report_wip   @reportName = 'GetDashboardBySetAndDateRange', @start=0, @length = 100,  @overall = 1,   @mono = '10592201001'
IF  @reportName = 'GetDashboardBySetAndDateRange'
BEGIN
select 'GetDashboardBySetAndDateRange' as reportname
/* remarks by Donel 
	declare @dateTox2  date
	declare @dateFromx2  date

	set @dateFromx2 = convert(date,@dateFrom)
	set @dateTox2 = convert(date,@dateTo)

  INSERT INTO @rtnTable
  SELECT * FROM
    (SELECT
      MoNo, Style = (select top 1  StyleNo From modet (nolock) where mono = PivotTable.mono),
      Color = (select top 1 Color From modet (nolock) where mono = PivotTable.mono),
      OrderQty = isnull ( ( SELECT sum(qty) from modet (nolock)  where mono = PivotTable.mono ),0),
      CusDelDt = isnull ( ( SELECT convert(date,RevCusDelDt) from mohdr (nolock) where mono = PivotTable.mono ),'01/01/1900'),
      Season  = isnull ( ( SELECT Season from view_mo (nolock) where mono = PivotTable.mono ), ''),
      Cutting = isnull([ICUT],0),
      Skiving = isnull([SKI],0),
      Gluing = isnull([GLU],0),
      FinalCut = isnull([FCUT],0),
      CutCons = isnull([CSM],0),
      [BPP] = isnull([BPP],0),
      [EMB] = isnull([EMB],0),
      [INK1] = isnull([INK1],0),
      [LNG] = isnull([LNG],0),
      [STR] = isnull([STR],0),
      [INK2] = isnull([INK2],0),
      [ASSY] = isnull([ASSY],0),
      id = ROW_NUMBER() over (order by moNo),
			CCON = isnull([CCON],0),
			CEN = isnull([CEN],0),
			HDL = isnull([HDL],0),
			COM = isnull([COM],0)
    FROM
      (
        SELECT a.mono, a.SVAP, qty = min(QTY) FROM (
          SELECT MONo, Feature, SVAP,
            Qty = ISNULL(
              case when SVAP = 'ASSY' then
                (	select sum(qty)
                  from wip_consolidation (nolock)
                  where MONo = a.MONo and Feature = a.Feature
                    and convert(date, ScanDt) between @dateFromx2 and @dateTox2
                    and SVAP = a.SVAP )
              else
                (	select sum(qty)
                  from wip_workers_output (nolock)
                  where MONo = a.MONo and Feature = a.Feature
                    and convert(date, OutputDt) between @dateFromx2 and @dateTox2
                    and SVAP = a.SVAP )
              end
            , 0)
          FROM OB a
          WHERE Mono = @mono
					--WHERE Mono in (select distinct mono from wip_workers_output)
					and Feature not in ('E5003', 'R14001', 'S15004', 'S15006', 'S15008', 'S15013')
					and Feature not in ('E5004', 'R14002', 'S15005', 'S15007', 'S15009','S15014')
						/*
						mono in    ( select * from dbo.fnSplitString (@mono,',') )  or mono = case when @mono = '' then mono   end
						and mono in (select distinct mono from wip_consolidation where svap = 'ASSY')
						*/
        ) A Group by MONo, SVAP
     ) a PIVOT (
      sum(qty) FOR svap in ([ICUT],[SKI],[GLU],[FCUT],[CSM],[BPP],[EMB],[INK1],[LNG],[STR],[INK2],[ASSY],[CCON],[CEN],[HDL],[COM])
    ) as PivotTable) a
  WHERE season = (case when @season = '' then season else @season end)

	 SET @totalRecords = @@ROWCOUNT
		 select *, TotalRecords = @totalRecords
		 from @rtnTable
		 where id between @start and (@start + @length - (case when @start = 0 then  0 else 1 end)  )
*/
END
--exec usp_execute_report_wip @reportName ='bundleShading',@mono ='11993901001', @svap = 'ASSY', @type = 'receive'
--exec usp_execute_report_wip @reportName ='bundleShading',@mono ='11174201001', @svap = 'ICUT', @type = 'issue'
--exec usp_execute_report_wip @reportName ='bundleShading',@mono ='10554601001', @svap = 'ICUT', @type = 'output'
ELSE IF @reportName = 'bundleShading'
BEGIN
select 'bundleShading' as reportname
/* remarks by Donel
  IF   @type = 'output' and @svap = 'ICUT'
	BEGIN
			--select 1 as bundleNo, 'False' as Shading
			SELECT distinct
				bundleNo,
				Outputed = 'False'
			FROM (
						   SELECT A.*, FeatureDesc = e.Desc1, c.Seq, Operation = c.Operation, Smv = c.SAM, f.Seq as PartSeq,  G.next_svap,
								 totaloutputqty =
										isnull((select sum(qty)
										from wip_workers_output (nolock) where MONo = a.MONo and Feature = a.feature and SVAP = a.SVAP and
										bundleNo = a.bundleNo), 0)
						   FROM (
										SELECT
												MoNo,
												BundleNo = (select BundleNo from dbo.layingPT (nolock) where PTNo = a.PTNO),
												Vap = 'CUT', Svap = 'ICUT', Feature = PartCd, Qty, LayNo
										FROM dbo.WIPScanPart a (nolock)
										WHERE SVAP = 'BIN-INIT'
													and MoNo = @mono
							 ) a
							 INNER JOIN iMAPPS.dbo.MOHdr b (nolock) on a.MONo = b.MONo
							 INNER JOIN (select * from OB (nolock) WHERE svap = 'ICUT' and MONo = @mono) c on c.MONo = a.MONo and a.Feature = c.Feature
							 inner join iMAPPS.dbo.LayingHdr d (nolock) on d.MONo = a.MONo and d.LayNo = a.LayNo
							 inner join iMAPPS.dbo.StyleAnalysisDet e (nolock) on e.Style = c.StyleNo and e.Feature = a.feature
							 INNER JOIN (
										SELECT mvp.MONo, Seq = mv.Seq2, mvp.PartCd, mvp.VAP, mvp.SVAP, mvp.Deleted
										FROM dbo.MOSVAPPart AS mvp (nolock) INNER JOIN
											dbo.MOVAPSVAP AS mv (nolock) ON mvp.MONo = mv.MONo AND mvp.Seq = mv.Seq
										WHERE (mv.Seq2 = 1) and mvp.SVAP = 'BIN-INIT'
									  	and mv.MONo =  @mono
							 ) f on f.MONo = a.MONo and f.PartCd = a.Feature
							 INNER JOIN (
										select a.*
										from (
													 select Mono, Seq, Feature,  vap, svap, styleNo,
															 next_svap = isnuLl((select top 1 SVAP  from OB where mono = a.MONo and Feature = a.Feature and Seq > a.Seq order by seq), 'N/A'),
															 nextVap = isnuLl((select top 1 VAP from OB where mono = a.MONo and Feature = a.Feature and Seq > a.Seq order by seq), 'N/A')
													 from OB a (nolock)
													 where mono =  @mono
										) a
								) G on a.mono = G.mono and a.feature = G.Feature and a.VAP = g.VAP and a.SVAP = g.SVAP
						 WHERE d.Status = 'G' and nextVap is not null
					 ) A
			where (qty - totaloutputqty) > 0
			order by 1
  END
  ELSE IF   @type = 'output' and @svap != 'ICUT'
	BEGIN
			SELECT distinct bundleNo, Outputed = 'False'
			FROM (
				 SELECT  A.*,
						 balanceOutput = (ReceivedQty -OutputQty )
				 FROM (
						select MONo, bundleNo, VAP, SVAP, feature,
								receivedQty = sum(Qty)over(partition by MONo, feature, bundleNo, SVAP ),
								outputQty = (select isnull(sum(qty),0) from wip_workers_output (nolock) where mono = a.mono and feature = A.feature AND bundleNo = A.bundleNo and SVAP = a.SVAP)
						from [view_wip_consolidation] a (nolock)
						WHERE 	 MONo = @mono
								 and svap = @svap
								 and status = 'COMPLETE'
				 ) A
			) A WHERE balanceOutput > 0
	END
	ELSE IF @type = 'issue'
	BEGIN
		SELECT  distinct BundleNo, Shading = 'For Issuance'
		FROM (

				SELECT
					 a.*
					,for_issuance_qty = (output_qty -next_svap_issued_qty )

				FROM (
					SELECT A.MONo, a.Style, a.Color, a.Feature, a.FeatureDesc, a.BundleNo, a.Operation
							, smv = (select top 1 smv from wip_workers_output (nolock) where MONo = a.MONo  and VAP =a.VAP and svap=a.svap and bundleNo = a.BundleNo and feature = a.feature)
							, a.Seq, a.VAP, a.SVAP,
							BTNo = (select top 1 createdBy from wip_workers_output (nolock) where MONo = a.MONo  and VAP =a.VAP and svap=a.svap and bundleNo = a.BundleNo and feature = a.feature)
							, a.output_qty,
							b.nextVap, b.nextSvap,
							next_svap_issued_qty =
								isnull(  ( select sum(qty) from wip_consolidation (nolock) where mono = a.MONo
														and  svap = b.nextSvap and bundleNo = a.bundleNo and feature = a.Feature ) ,0 )
					FROM (
							SELECT  a.mono, a.style, a.color, a.feature, a.featureDesc, a.bundleNo, a.operation, a.seq, a.vap, a.svap, output_qty = sum(Qty)
							FROM wip_workers_output a (nolock)
							WHERE MONo = @mono  and svap = @svap
							group by mono, feature, vap, svap, featureDesc, style,BundleNo,operation,Seq,color
					) A
					INNER JOIN (
							select a.*
							from (
									select Mono, Seq, Feature, vap, svap, styleNo,
										nextSvap = isnuLl((select top 1 SVAP from OB  (nolock) where mono = a.MONo and Feature = a.Feature and Seq > a.Seq order by seq ),'N/A'),
										nextVap = isnuLl((select top 1 VAP from OB (nolock) where mono = a.MONo and Feature = a.Feature and Seq > a.Seq order by seq ),'N/A')
									from OB a (nolock)
									where mono = @mono
							) a
					) B on a.mono = b.mono and a.feature = b.Feature and a.VAP = b.VAP and a.SVAP = b.SVAP and Style = b.StyleNo

				) A

		) A
		WHERE for_issuance_qty > 0 and nextSvap != 'N/A'
		order by BundleNo
	END
	ELSE IF   @type = 'receive'
	BEGIN
			SELECT distinct  bundleNo, Received = 'False'  from wip_consolidation (nolock)
			where mono = @mono and status = 'PENDING'
			and svap = @svap
			order by BundleNo
	END
*/
END
--exec usp_execute_report_wip   @reportName = 'GetDashboardByPartsAndDateRange', @overall = 1, @dateFrom = '01/06/2018', @dateTo = '12/06/2018',  @start= 0, @length = 100, @mono = '10541701001' @id = '31,35,36,37,38,39'  @mono = '10518501001,10507401001,10507601001,10507801001', --, , @id = '1,2,3,4,5,6'
ELSE IF  @reportName = 'GetDashboardByPartsAndDateRange'
BEGIN
select 'GetDashboardByPartsAndDateRange' as reportname
/* remarks by Donel
	 declare @dateTox  date
	 declare @dateFromx  date

	 set @dateFromx = convert(date,@dateFrom)
	 set @dateTox = convert(date,@dateTo)

	INSERT INTO @rtnTable
  SELECT * FROM
    (SELECT
      MoNo, Style = (select top 1  StyleNo From modet  (nolock)  where mono = PivotTable.mono),
      Color = (select top 1 Color From modet (nolock) where mono = PivotTable.mono),
      OrderQty = isnull ( ( SELECT sum(qty) from modet (nolock)  where mono = PivotTable.mono ),0),
      CusDelDt = isnull ( ( SELECT convert(date,RevCusDelDt) from mohdr (nolock) where mono = PivotTable.mono ),'01/01/1900'),
      Season =  isnull ( ( SELECT Season from view_mo  (nolock) where mono = PivotTable.mono ), ''),
      Cutting = isnull([ICUT],0),
      Skiving = isnull([SKI],0),
      Gluing = isnull([GLU],0),
      FinalCut = isnull([FCUT],0),
      CutCons = isnull([CSM],0),
      [BPP] = isnull([BPP],0),
      [EMB] = isnull([EMB],0),
      [INK1] = isnull([INK1],0),
      [LNG] = isnull([LNG],0),
      [STR] = isnull([STR],0),
      [INK2] = isnull([INK2],0),
      [ASSY] = isnull([ASSY],0),
      id = ROW_NUMBER()over(order by moNo),
			CCON = 0,
			CEN =0,
			HDL = 0,
			COM = 0
    FROM
      (
        SELECT a.mono,  a.SVAP, qty = min(QTY)  FROM (
          SELECT MONo,  Feature,  SVAP,
            Qty = ISNULL(
              case when SVAP = 'ASSY' then
                (	select sum(qty)
                  from wip_consolidation (nolock)
                  where MONo = a.MONo --and Feature = a.Feature
                    and convert(date, ScanDt) between @dateFromx and @dateTox
                    and SVAP = a.SVAP )
              else
                  (	select sum(qty)
                    from wip_workers_output (nolock)
                    where MONo = a.MONo --and Feature = a.Feature
                    and convert(date,OutputDt) between   @dateFromx and @dateTox
                    and SVAP = a.SVAP)
              end
              , 0)
          FROM OB a
          WHERE
          MONO in (select distinct mono from wip_workers_output (nolock)
              where convert(date,OutputDt) between   @dateFromx and @dateTox
          )
        ) A Group by MONo, SVAP

     ) a PIVOT (
      sum(qty) FOR svap in ([ICUT],[SKI],[GLU],[FCUT],[CSM],[BPP],[EMB],[INK1],[LNG],[STR],[INK2],[ASSY])
    ) as PivotTable) a
	WHERE season = (case when @season = '' then season else @season end)

	 SET @totalRecords = @@ROWCOUNT
		 select *, TotalRecords = @totalRecords
		 from @rtnTable
		 where id between @start and (@start + @length - (case when @start = 0 then  0 else 1 end)  )
*/
END
--exec usp_execute_report_wip @reportName = 'GetProcessHdr'
ELSE if  @reportName = 'GetProcessHdr'
BEGIN
	select 'GetProcessHdr' as reportname
/* remarks by Donel
	if @company = 'cambodia'
	begin
		SELECT a.vap, a.svap, description = desc1
		FROM (
			select vap,svap,desc1, seq = (case when svap = 'ICUT' then 1  when svap = 'SKI' then 2 when svap = 'GLU' then 3 when svap = 'FCUT' then 4 when svap = 'CSM' then 5 else 0  end )   from SVAP (nolock) where vap in ('CUT')
			UNION
			select vap,svap,desc1, seq = (case when svap = 'EMB' then 11  when svap = 'INK1' then 12 when svap = 'INK2' then 13 when svap = 'LNG' then 14 when svap = 'STR' then 15 when svap = 'BPP' then 16 else 0  end ) from SVAP (nolock) where vap in ('BPP')
			UNION
			select vap,svap,desc1,  seq = (case when svap = 'INK2' then 21  when svap = 'ASSY' then 22 else 0 end) from SVAP  (nolock) where vap in ('SEW')
		) A
		--where svap = 'ICUT'
		order by seq
	end
	else
	begin
		SELECT a.vap, a.svap, description = desc1
		FROM (
			select vap, svap, desc1, seq = (case when svap = 'ICUT' then 1 when svap = 'SKI' then 2 when svap = 'GLU' then 3 when svap = 'FCUT' then 4 when svap = 'CCON' then 5 when svap = 'EMB' then 6 else 0 end) from SVAP (nolock) where vap = 'CUT' and svap <> 'CUT'
			UNION
			select vap, svap, desc1, seq = (case when svap = 'HDL' then 11 when svap = 'LNG' then 12 when svap = 'COM' then 13 when svap = 'INK1' then 14 when svap = 'CEN' then 15 when svap = 'INK2' then 16 else 0 end) from SVAP (nolock) where vap = 'CEN' and svap <> 'EMB'
			UNION
			select vap, svap, desc1, seq = (case when svap = 'ASSY' then 21 when svap = 'INK2' then 22 else 0 end) from SVAP (nolock) where vap in ('SEW')
		) A
		--where svap = 'ICUT'
		order by seq
	end
*/
END
--exec usp_execute_report_wip   @reportName = 'GetProcessDtlByMOAndBySetOrParts', @svap = 'CSM', @dateFrom = '08/24/2018', @dateTo = '08/25/2018',  @moNo='10710201001'
/*  1 remarks by Donel
ELSE if  @reportName = 'GetProcessDtlByMOAndBySetOrParts'
BEGIN
	SELECT A.* FROM
	(
		select Svap, MoNo,
			SetQty =  0, -- (select dbo.fnGetOutputByCheckpointBySetByDateRange(a.svap, a.mono, '1/1/2018', '12/31/2018' ) ),
			PartsQty = (select dbo.fnGetOutputByCheckpointPartsByDateRange(a.svap, a.mono, @dateFrom, @dateTo ) )
		from wip_workers_output (nolock) a
		where convert(date,outputDt) between @dateFrom and @dateTo -- '05/24/2018'
		and MONo = case when @mono = '' then MONo else @mono end
			and svap  = @svap
		group by SVAP, mono
	) A
END
--exec usp_execute_report_wip  @reportName = 'GetPartsByMoAndProcess', @mono = '10945001002', @svap ='HDL', @dateFrom='01/01/2018'  ,@dateTo='12/28/2018', @status= ''
--exec usp_execute_report_wip  @reportName = 'GetPartsByMoAndProcess', @mono = '12333801001', @svap ='ICUT'
ELSE IF @reportName = 'GetPartsByMoAndProcess'
BEGIN
	IF @svap != 'ASSY'
	BEGIN
		SELECT a.FeatureDesc,	a.Material,	a.TotalQty,	a.Svap,	a.DateRange,	a.MinOutPutDate,	a.MaxOutPutDate, a.Status, a.TargetQty
		FROM
		(
			SELECT A.*, Status = case when TotalQty = 0 then 'No Output Last' else '' end
			FROM
			(
				SELECT FeatureDesc =  (select top 1 featureDesc from wip_workers_output (nolock) where  Feature = a.Feature ) +' (' + a.Feature +')',
					 Material = (case when Feature like 'AM%' then 'Leather'  when Feature like 'BM%' then 'Lining' when Feature like 'BL%' then 'Lining' else 'Filler' end ),
					 TotalQty = case when @nodates = 1 then
				  isnull ((select sum(qty) from wip_workers_output (nolock) where SVAP = a.SVAP and Feature = a.Feature and MONo = a.MONo), 0)
				else
				  isnull ((select sum(qty) from wip_workers_output (nolock) where SVAP = a.SVAP and Feature = a.Feature and MONo = a.MONo and
							convert(date,OutputDt) between @dateFrom and @dateTo), 0)
				end,
					 Svap,
					 DateRange = (case when @nodates = 1 then
								(select isnull(convert(varchar(12), convert(date, min(OutputDt))), '') + ' - ' + isnull(convert(varchar(12), convert(date, max(OutputDt))), '')
								from wip_workers_output (nolock)
								where SVAP = a.SVAP and Feature = a.Feature and MONo = a.MONo)
							else
								(convert(varchar(12), @dateFrom, 101) + ' - ' + convert(varchar(12), @dateTo, 101))
							end),
					 MinOutPutDate  = isnull ( (select min(convert(date,OutputDt)) from wip_workers_output (nolock) where SVAP = a.SVAP and Feature = a.Feature  and MONo = a.MONo ),''),
					 MaxOutPutDate  = isnull ( (select max(convert(date,OutputDt)) from wip_workers_output (nolock) where SVAP = a.SVAP and Feature = a.Feature  and MONo = a.MONo ),''),
					 TargetQty = convert(int,( select count(*) from OB where mono = @mono and svap = a.SVAP and Feature = a.Feature ) * (select sum(qty) from moDet (nolock) where mono = @mono ))
				 FROM OB  a
				  INNER JOIN (select distinct mono ,StyleNo, color from MODet (nolock) ) b
					on a.MONo = b.MONo
				WHERE a.mono = @mono
					and svap = @svap
			) A
		) A
		where Status = (case when @status = '' then Status else @status end )
		and Material = (case when @material = '' then Material else @material end )
/*
		select * from wip_workers_output where MONo = '12333801001'
		update wip_workers_output set Style = '91145' where MONo = '12333801001'
		select * from StyleAnalysisDet where Style = '91145' and Feature = 'FBL001'
		select * from OB where MONo = '12333801001' and styleNo = '91145' and feature = 'FBL001'
		select distinct mono ,StyleNo, color from MODet where MONo = '12333801001'
*/
	END
	ELSE
	BEGIN
		SELECT a.FeatureDesc,	a.Material,	a.TotalQty,	a.Svap,	a.DateRange,	a.MinOutPutDate,	a.MaxOutPutDate, a.Status, a.TargetQty
		FROM
		(
			SELECT A.*, Status = case when TotalQty = 0 then 'No Output Last' else '' end
			FROM
			(
				SELECT FeatureDesc = (select Desc1 from StyleAnalysisDet (nolock) where Style = b.StyleNo and Feature = a.Feature ) +' (' + a.Feature +')',
					 Material = (case when Feature like 'AM%' then 'Leather'  when Feature like 'BM%' then 'Lining' when Feature like 'BL%' then 'Lining' else 'Filler' end ),
					 TotalQty = case when @nodates = 1 then
				  isnull ((select sum(qty) from wip_consolidation (nolock) where SVAP = a.SVAP and Feature = a.Feature and MONo = a.MONo), 0)
				else
				  isnull ((select sum(qty) from wip_consolidation (nolock) where SVAP = a.SVAP and Feature = a.Feature and MONo = a.MONo and
							convert(date,ScanDt) between @dateFrom and @dateTo), 0)
				end,
					 Svap,
					 DateRange = (case when @nodates = 1 then
								(select isnull(convert(varchar(12), convert(date, min(ScanDt))), '') + ' - ' + isnull(convert(varchar(12), convert(date, max(ScanDt))), '')
								from wip_consolidation (nolock)
								where SVAP = a.SVAP and Feature = a.Feature and MONo = a.MONo)
							else
								(convert(varchar(12), @dateFrom, 101) + ' - ' + convert(varchar(12), @dateTo, 101))
							end),
					 MinOutPutDate  = isnull ( (select min(convert(date,ScanDt)) from wip_consolidation (nolock) where SVAP = a.SVAP and Feature = a.Feature  and MONo = a.MONo ),''),
					 MaxOutPutDate  = isnull ( (select max(convert(date,ScanDt)) from wip_consolidation (nolock) where SVAP = a.SVAP and Feature = a.Feature  and MONo = a.MONo ),''),
					 TargetQty = convert(int,( select count(*) from OB (nolock) where mono = @mono and svap = a.SVAP and Feature = a.Feature ) * (select sum(qty) from moDet (nolock) where mono = @mono ))
				 FROM OB  a
				  INNER JOIN (select distinct mono ,StyleNo, color from MODet (nolock) ) b
					on a.MONo = b.MONo
				WHERE a.mono = @mono
					and svap = @svap
			) A
		) A
		where Status = (case when @status = '' then Status else @status end )
		and Material = (case when @material = '' then Material else @material end )
	END


END
--exec usp_execute_report_wip  @reportName = 'GetMosWithOutput'
ELSE IF @reportName = 'GetMosWithOutput'
BEGIN
  select * from
    (select row_number() over (order by a.mono) as id, a.mono, a.iono, a.StyleNo, a.Eff, a.PlanSMV as smv,
      ProdMonth = convert(date,a.ProdMonth), sum(b.qty) as qty, RevCusDelDt = convert(date,a.RevCusDelDt),
      Color = b.CustColor, Season =  isnull ( ( SELECT Season from view_mo where mono = a.mono ), '')
    from imapps.dbo.mohdr (nolock) a inner join imapps.dbo.modet (nolock) b on a.mono = b.MONo
    WHERE a.mono in (select distinct  mono from wip_workers_output (nolock) )
    group by a.mono, a.iono, a.StyleNo, a.Eff, a.PlanSMV, a.ProdMonth, a.RevCusDelDt, b.CustColor) a
  where season = (case when @season = '' then season else @season end)
END
--exec usp_execute_report_wip  @reportName = 'GetMoldsByMono', @mono = '10592801001', @material = 'Leather'
ELSE IF @reportName = 'GetMoldsByMono'
BEGIN
	SELECT id, moldNo, material from (
		 SELECT id = ROW_NUMBER()over(order by material, moldNo ), *
		 FROM
		 (
			 select distinct
				--PartCd,
				Material = (case when PartCd like 'AM%' then 'Leather'  when PartCd like 'BM%' then 'Lining' else 'Filler' end ),
				moldNo = (select LEFT( convert(varchar(5),Desc1),5) from StyleAnalysisDet where Style = b.StyleNo and Feature = a.PartCd)
			 FROM dbo.WIPScanPart (nolock) a
			 inner join OB (nolock) b
					on a.MONo = b.MONo and a.PartCd = b.Feature
			 WHERE a.SVAP ='BIN-INIT'  and a.mono = @mono
		) A
	) a
	WHERE Material =(case when @material ='' then material else @material end)
END
--exec usp_execute_report_wip  @reportName = 'GetBundleTracking', @mono = '11563601006', @svap = 'GLU', @bundleNo = 1, @material = 'Leather',  @destination= 'SKI', @status='OUTPUT'
--exec usp_execute_report_wip  @reportName = 'GetBundleTracking', @mono = '11563601006', @svap = 'SKI', @bundleNo = 1
--exec usp_execute_report_wip  @reportName = 'GetBundleTracking', @mono = '11563601006', @svap = 'GLU', @bundleNo = 1
--exec usp_execute_report_wip  @reportName = 'GetBundleTracking', @mono = '11563601006', @svap = 'SKI', @bundleNo = 1
--exec usp_execute_report_wip  @reportName = 'GetBundleTracking', @mono = '11563601006', @svap = 'ICUT', @bundleNo = 1
ELSE IF @reportName = 'GetBundleTracking'
BEGIN
		SELECT A.*
		FROM (
					SELECT  A.MONo, b.StyleNo, b.Color, Material,
									FeatureDesc = (select Desc1 from StyleAnalysisDet (nolock) where Style = b.StyleNo and Feature = a.PartCd ) +' (' + a.PartCd +')',
									BundleNo,
									LayQty, Process, Destination,
									Status = (case
														 when Received != LayQty and Issued !=LayQty and OUTPUT > 0  then 'OUTPUT'
														 when Received != LayQty and Issued > 0 then 'ISSUED'
														 when Received =LayQty then 'COMPLETE'
														else 'NO RECEIVING' end ),
									ReceivedBy ='', ReceivedDate = getdate(),
									Output, Issued, Received,
									Origin,
									ReceivedFromOrigin
					FROM (
									SELECT A.MONo, PartCd,
											Material = (case when PartCd like 'AM%' then 'Leather'  when PartCd like 'BM%' then 'Lining' when PartCd like 'BL%' then 'Lining' else 'Filler' end ),
											BundleNo, LayQty,
											Issued = isnull((select sum(qty) from wip_consolidation (nolock) where MONo = A.MONo and SVAP = A.destination and BundleNo = A.BundleNo and feature = A.PartCd ),0),
                      OUTPUT = isnull(( select sum(qty) from wip_workers_output (nolock) where mono=a.MONo and svap = @svap and Feature = a.PartCd and BundleNo = a.BundleNo ),0),
                    Process, Destination, Origin,
                    Received = isnull((select sum(qty) from wip_consolidation (nolock) where MONo = A.MONo and SVAP = A.destination and BundleNo = A.BundleNo and feature = A.PartCd and status = 'COMPLETE' ),0),
											RECEIVEDFromOrigin =
												case when Process = 'ICUT' then LayQty else
														 isnull((select sum(qty) from wip_consolidation (nolock) where MONo = A.MONo and SVAP = A.destination and BundleNo = A.BundleNo and feature = A.PartCd and status = 'COMPLETE' ),0)
												end
									FROM (
											SELECT A.*, BundleNo, LayQty
											FROM (
													select MONo, PartCd,
															Process = case when ( VAP like 'ICUT'+'%' or VAP like 'CUT'+'%')  and SVAP = 'ISS' then 'ICUT' ELSE (select value From dbo.fnSplitStringWithRow(a.VAP,'-') where id = 1) end,
															destination = (select value From dbo.fnSplitStringWithRow(a.VAP,'-') where id = 2) ,
															Origin = case when ( VAP like 'ICUT'+'%' or VAP like 'CUT'+'%') and SVAP = 'ISS' then 'BIN-INIT'   else isnull((select top 1 replace( LEFT(VAP,4),'-','') from MOSVAPPart (nolock) where MONo = a.MONo and PartCd =  a.PartCd and SVAP = 'RCV' and VAP like '%'+@svap),'N/A') end
													from MOSVAPPart (nolock) a
													where MONo = @mono and VAP like @svap+'%' and SVAP = 'ISS'
													--where MONo = @mono and VAP like '%'+@svap and SVAP = 'RCV'

											) a CROSS JOIN (
													select distinct bundleNo, LayQty = Qty from LayingPT (nolock) where MONo =  @mono
											) b
									) A
									WHERE BundleNo = @bundleNo
					) A
					INNER JOIN (
									SELECT * FROM view_mo_all (nolock)
					) b on a.MONo = b.mono
		) A
		WHERE Material = (case when @material = '' then Material else @material end)
					and Origin	= (case when @origin = '' then Origin else @origin end)
					and Destination	= (case when @destination = '' then Destination else @destination end)
					and status= (case when @status = '' then status else @status end)
		ORDER BY bundleNo, destination
END
--exec usp_execute_report_wip @reportName ='GetMOStartandFinishByProcess', @mono= '11498401002'
ELSE IF @reportName = 'GetMOStartandFinishByProcess'
	BEGIN
		SELECT Mono, Svap ,
			StartDate =  case when convert(int,AVG(TotalQty)) > 0  then min(MinOutPutDate) else '' end ,
			FinishDate =  case when AVG(TotalQty) =  AVG(TargetQty) then convert(date, max(MaxOutPutDate) ) else '' end,
			TotalQty = convert(int,AVG(TotalQty)), TargetQty = AVG(TargetQty)
		FROM (
			SELECT
				a.Mono,
				FeatureDesc = (select Desc1 from StyleAnalysisDet (nolock) where Style = b.StyleNo and Feature = a.Feature ) +' (' + a.Feature +')',
				Material = (case when Feature like 'AM%' then 'Leather'  when Feature like 'BM%' then 'Lining' else 'Filler' end ),
				TotalQty =  isnull ((select sum(qty) from wip_workers_output where SVAP = a.SVAP and Feature = a.Feature and MONo = a.MONo), 0),
				Svap,
				MinOutPutDate  =  convert(varchar(12),(select min(convert(date,OutputDt)) from wip_workers_output (nolock) where SVAP = a.SVAP and Feature = a.Feature  and MONo = a.MONo ) ),
				MaxOutPutDate  = isnull ( convert(varchar(12),(select max(convert(date,OutputDt)) from wip_workers_output (nolock) where SVAP = a.SVAP and Feature = a.Feature  and MONo = a.MONo )),''),
				TargetQty = convert(int,( select count(*) from OB (nolock) where mono = a.MONo and svap = a.SVAP and Feature = a.Feature ) * (select sum(qty) from moDet (nolock) where mono = a.MONo ))
			FROM OB  a
			INNER JOIN (select distinct mono ,StyleNo, color from MODet (nolock) ) b on a.MONo = b.MONo

			--and a.MONo in (select distinct MONo from wip_workers_output)
			where a.mono = @mono
		) A
		where svap != 'ASSY'
		group by Mono,svap

		UNION
		SELECT MONo = @mono, Svap ='ASSY',
				StartDate = isnull((select convert(date,min(ScanDt)) from WIPScan (nolock) where MONo = @mono and vap = @AssyPack ),'')
			, FinishDate = isnull(convert(date,max(ActualFinish)),'')
			, TotalQty = isnull((select sum(Qty) from WIPScan (nolock) where MONo = @mono and vap = @AssyPack),0)
			, TargetQty = (select convert(int,sum(Qty)) from MODet (nolock) where MONo = @mono )
		FROM BOHdr a where MONo = @mono


END
--exec usp_execute_report_wip @reportName ='ReceivedSetHdr', @Season= 'Fall18'
ELSE IF @reportName = 'ReceivedSetHdr'
BEGIN
	select count(MONo) TotalMoCount,
			TotalMoWithSet= isnull(SUM(case when SetReceived >0 then 1 else 0 end),0),
			SetTotal= isnull(SUM( SetReceived),0),
			Good =  isnull(SUM( Good),0),
			Reject = isnull(SUM( Reject),0)
	FROM (
		SELECT a.*,  Svap = 'ASSY',
			SetReceived = (select dbo.fnGetReceivedByCheckpointBySetByDateRange('ASSY',a.MONo,'01/01/1900',getdate() + 1) )
		FROM (

			SELECT A.*, Good = isnull(b.Good,0), Reject= isnull(b.Reject,0)  FROM (
				select  distinct Season = (select season from view_mo where mono = a.MONo),
				MONo
				from wip_consolidation (nolock) a where SVAP = 'ASSY'
			) A
			LEFT OUTER JOIN (

				SELECT a.MONo, Good  = sum(GoodOutput+ RejectToGood),
					Reject = sum(case when (GoodOutput+ RejectToGood) = 0 then 1 else 0 end)
				FROM (
					select MONo, a.PTNO, a.Seq, ProdLine,
							sum(case when reject = 1 then 0 else 1 end) GoodOutput,
							sum(case when reject = 1 then 1 else 0 end) RejectOutput,
							RejectToGood = isnull( (select top 1  1   from EndLineQCRFID (nolock) where PTNO = a.PTNo and seq = a.Seq and ProdLine = a.ProdLine  and status = 'PASSED'),0) --501200151310
					from EndLineQCHdr (nolock) a
						inner join (
							select x.* from LayingPT (nolock) x
							inner join LayingHdr (nolock) y
								on x.mono =y.mono and x.layNo = y.layNo
							and y.status = 'G'
						) b
						on a.PTNo = b.PTNo
					--where b.mono not in ('10601901001')
					group by MONo, a.PTNO, a.Seq, ProdLine
				) a GROUP by a.MONo

			) B on a.MONo = b.MONo

		) a
		WHERE season = (case when @season = '' then Season else @season end)
	) a
END
--assemblyDetails
--exec usp_execute_report_wip @reportName ='ReceivedSetDet', @search='10538601001', @Season= 'Fall18'
ELSE IF @reportName = 'ReceivedSetDet'
BEGIN
		SELECT A.Mono,a.OrderQty, SetReceived, Good= isnull(B.Good,0), Reject= isnull(b.Reject,0), A.Season, a.SVAP
		FROM (
			SELECT a.*,
			  --OrderQty  = convert(int,(select sum(qty)  from MODet where MONo = a.MONo)),
			  SetReceived = (select dbo.fnGetReceivedByCheckpointBySetByDateRange('ASSY',a.MONo,'01/01/1900',getdate() + 1) )
			FROM (
				SELECT A.* FROM (
					SELECT A.*, Svap = 'ASSY'
					FROM (
						select mono,  color , style = StyleNo , deliveryDate = RevCusDelDt, orderQty = convert(int,qty), iono, setQty = 0,status, Season, (select count(*) from MODet (nolock) where mono = a.mono) as coCount
						from view_mo a
						where
						mono in    ( select * from dbo.fnSplitString (@mono,',') )  or mono = case when @mono = '' then mono   end
						and mono in (select distinct mono from wip_consolidation (nolock) where svap = 'ASSY')
					) A
					WHERE
					  season = (case when @season = '' then season else @season end)
					  and Style = (case when @style = '' then Style else @style end)
					  and Color = (case when @color = '' then Color else @color  end)
					and convert(varchar(4),year(deliveryDate)) + RIGHT('00' + convert(varchar(2), month(deliveryDate)),2)
						= (case when @deliveryYearMonth = '' then convert(varchar(4),year(deliveryDate)) + RIGHT('00' + convert(varchar(2), month(deliveryDate)),2) else @deliveryYearMonth  end)
				) A
				WHERE (mono like '%'+@search+'%' or style like '%'+@search+'%' or color like '%'+@search+'%' or season like '%'+@search+'%')
			) A
		) A LEFT OUTER JOIN ( --GOOD AND REJECT
				SELECT A.* FROM (
					SELECT A.MoNo, Good=sum(good) , Reject = ISNULL(SUM(B.REJECT),0)
					FROM (
						select  distinct a.MoNo,  Prodline =  WorkSection, Good = sum(qty)
						from wipscan (nolock) a
						where  a.VAP = @AssyPack
						group by mono, WorkSection
					) A
					LEFT OUTER JOIN (
						--REPLACE---
						SELECT A.MONO, A.ProdLine, COUNT(*) AS REJECT
						FROM (
							select A.*,B.MONO from EndLineQCHdr (nolock) a
							inner join (
								select x.* from LayingPT (nolock) x
								inner join LayingHdr (nolock) y
									on x.mono =y.mono and x.layNo = y.layNo
								and y.status = 'G'
							) b
							on a.PTNo = b.PTNo
							and reject = 1
						 ) A LEFT OUTER JOIN (
								select A.*, B.MONO from EndLineQCRFID (nolock) a
								inner join (
									select x.* from LayingPT (nolock) x
									inner join LayingHdr  (nolock) y
										on x.mono =y.mono and x.layNo = y.layNo
									and y.status = 'G'
								) b
								on a.PTNo = b.PTNo
								WHERE A.Status = 'PASSED'
						) B ON A.PTNo = B.PTNo AND A.ProdLine = B.ProdLine AND A.Seq = B.Seq AND A.MONO = B.MONO AND A.ProdLine = B.ProdLine
						WHERE B.PTNo IS NULL
						GROUP BY A.MONO, A.ProdLine
					) B ON A.MONo = B.MONO AND A.Prodline = B.ProdLine
					GROUP BY A.Mono
					--REPLACE---
				) A
		) B on a.mono = b.mono
END
--exec usp_execute_report_wip @reportName ='EQCHourlyOutputHdr', @dateFrom = '10/21/2019', @prodLine = 'L04'
ELSE IF @reportName = 'EQCHourlyOutputHdr'
BEGIN
	SELECT ProdLine, Desc1, Output = case when b.Qty > 0 then 'true' else 'false' end
	FROM prodlines (nolock) a
	LEFT OUTER JOIN (
			SELECT distinct WorkSection, Qty = isnull(sum(qty),0)
			from WIPScan (nolock)
			WHERE convert(date,ScanDt) = @dateFrom
			and vap = @AssyPack
			group by WorkSection
	) b on a.ProdLine = b.WorkSection
	WHERE (ProdLine in (select * from dbo.fnSplitString (@prodLine,',') ) or  ProdLine = case when @prodLine ='' then ProdLine end)
END
/*
	exec usp_execute_report_wip @reportName ='EQCHourlyOutputDet', @dateFrom = '08/25/2018', @prodLine='M01'

*/
ELSE IF @reportName = 'EQCHourlyOutputDet'
BEGIN

	SELECT distinct A.moNo, hoursx, good = isnull(good,0) + isnull(Reworked,0)
		,Reject, hourlyTarget = isnull(hourlyTarget,0), ProductionTarget = isnull(ProductionTarget,0), Manpower = isnull(b.Manpower,0),
		smv = isnull(b.smv,0), WorkingHour = isnull(b.WorkingHour,0), WorkingMinutes = isnull(b.WorkingMinutes,0), NPT = isnull(b.NPT,0),
		IoNo, MoQty = Qty, MoSmv = c.smv , StyleNo, Color, DeliveryDate = RevCusDelDt,  StartDate = isnull(StartDate,'') , FinishDate = isnull(FinishDate,'') ,
		LineMoOutput, a.WorkSection, Reworked = isnull(Reworked,0), UnderRepair = isnull(UnderRepair,0), UnRepairable = isnull(UnRepairable,0)
	FROM
	(
			---------
			select aa.mono, aa.WorkSection, Hoursx = aa.ScanHr, Datex = aa.date, Good = isnull(a.good,0),
				 Reject = isnull(b.TotalRejects,0),
				 Reworked = isnull(C.Reworked,0), UnderRepair = isnull(UnderRepair,0), UnRepairable = isnull(UnRepairable,0)
			from (
				select distinct a.*
				from (
					select   mono, workSection, date = convert(date,ScanDt), ScanHr = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, ScanDt)), 2)
					from WIPScan (nolock) where convert(date,ScanDt) = @dateFrom
					and vap = @AssyPack and	SVAP = 'ISS'
					and WorkSection =case when  @prodLine ='' then WorkSection  else @prodLine end
					UNION
					SELECT    MONo, ProdLine, TransDt, TransHour
					FROM (
								select
										b.mono, a.*,
										FixedDt = convert(date,FixedDt),
										FixedHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, FixedDt)), 2),
										TransDt = convert(date,c.TransDt),
										TransHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, c.TransDt)), 2),
										c.status, c.color, c.rejectType, FixedUserId,  RejectQty = 1
								from EndLineQCHdr (nolock) a
									Inner join LayingPT (nolock) b on a.PTNo = b.PTNo
									INNER JOIN EndLineQCRFID (nolock) c on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine
								where Reject = 1
					) a
					where ProdLine = case when  @prodLine ='' then ProdLine  else @prodLine end
							and TransDt =  @dateFrom
				) a
			) aa
			LEFT OUTER JOIN (
					SELECT mono, WorkSection,Hoursx, Datex, Good = sum(good), Reject = sum(reject)
					FROM (
						select   a.mono, PTNO, WorkSection,
							Hoursx = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, a.ScanDt)), 2),
							Datex = convert(date,a.ScanDt),
							Good = sum(qty),
						  Reject = 0
						from wipscan (nolock) a
						where  a.VAP = @AssyPack and	a.SVAP = 'ISS'
							and convert(date,a.ScanDt) =  @dateFrom
							and WorkSection = case when  @prodLine ='' then WorkSection  else @prodLine end
						group by mono, RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, a.ScanDt)), 2),
						convert(date,a.ScanDt), WorkSection, PTNo
					) A
					GROUP BY mono, WorkSection,Hoursx, Datex
			) a on a.MONo = aa.MONo and a.WorkSection = aa.WorkSection and aa.date = a.Datex and aa.ScanHr = a.Hoursx
			LEFT OUTER JOIN (
						--REJECT per hour
							SELECT A.MONo, TransDt, TransHour, ProdLine, TotalRejects = sum(TotalRejects), Reworked = sum(Reworked),
									UnderRepair = sum(UnderRepair), UnRepairable = sum(UnRepairable)
							FROM (
									SELECT  MONo, TransDt,TransHour,   ProdLine, TotalRejects = sum(RejectQty),
												Reworked = case when Status = 'PASSED' and RejectType in ('REPAIR','REWORK') and FixedDt is not null then sum(RejectQty)  else 0 end,
												UnderRepair = case when Status = 'REJECT' and RejectType in ('REPAIR','REWORK') and FixedDt is null then sum(RejectQty)  else 0 end,
												UnRepairable = case  when RejectType in ('UNREPAIRABLE') then sum(RejectQty)  else 0 end
									FROM (
												select
														b.mono, a.*,
														FixedDt = convert(date,FixedDt),
														FixedHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, FixedDt)), 2),
														TransDt = convert(date,c.TransDt),
														TransHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, c.TransDt)), 2),
														c.status, c.color, c.rejectType, FixedUserId,  RejectQty = 1
												from EndLineQCHdr (nolock) a
													Inner join LayingPT (nolock) b on a.PTNo = b.PTNo
													INNER JOIN EndLineQCRFID (nolock) c on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine
												where Reject = 1
									) a
									where ProdLine = @prodLine and TransDt = @dateFrom
									--where ProdLine = 'M04' and TransDt = '08/25/2018'
									GROUP BY  TransDt, a.ProdLine,   Status, RejectType, TransDt,TransHour, MONo,FixedDt, FixedHour
							) A
							group by A.MONo, TransDt, TransHour, ProdLine
			)B ON aa.MONo = b.MONo and aa.WorkSection = b.ProdLine and aa.ScanHr = b.TransHour and aa.date = b.TransDt
			LEFT OUTER JOIN (
					--FIXED per HOUR
					SELECT A.MONo, FixedDt, FixedHour, ProdLine, Reworked = sum(Reworked)
					FROM (
							SELECT  MONo, FixedDt,FixedHour,   ProdLine,
										Reworked = case when Status = 'PASSED' and RejectType in ('REPAIR','REWORK') and FixedDt is not null then sum(RejectQty)  else 0 end
							FROM (
										select
												b.mono, a.*,
												FixedDt = convert(date,FixedDt),
												FixedHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, FixedDt)), 2),
												TransDt = convert(date,c.TransDt),
												TransHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, c.TransDt)), 2),
												c.status, c.color, c.rejectType, FixedUserId,  RejectQty = 1
										from EndLineQCHdr (nolock) a
											Inner join LayingPT (nolock) b on a.PTNo = b.PTNo
											INNER JOIN EndLineQCRFID (nolock) c on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine
										where Reject = 1
										--AND c.ProdLine = 'M04' and convert(varchar(12),FixedDt,101) = '08/25/2018'
							) a
							GROUP BY  FixedDt, a.ProdLine,   Status, RejectType, TransDt,TransHour, MONo,FixedDt, FixedHour
					) A
					group by A.MONo, FixedDt, FixedHour, ProdLine
			) C ON aa.MONo = c.MONo and aa.WorkSection = c.ProdLine and aa.ScanHr = c.FixedHour and aa.date = c.FixedDt
	) A
	LEFT OUTER JOIN (
		-- Production Target and Attendance
				SELECT * FROM (
							select
								ProductionTarget =   ceiling( ( (@ProductionHeadcount * @ProductionWorkingMinutes) / a.smv) * @TargetPercentage),
								a.WorkSection as ProdLine,
								WorkDate = convert(date,a.workDate),
								Manpower = (case when @company = 'cambodia' then b.Headcount when @company = 'bataan' then c.Headcount else 0 end) ,
								WorkingMinutes = @ProductionWorkingMinutes , SMV,
								HourlyTarget = ceiling((( @ProductionHeadcount * @ProductionWorkingMinutes) / a.smv * @TargetPercentage) / (@ProductionWorkingMinutes/60)),
								WorkingHour = (@ProductionWorkingMinutes/60),
								MOCount,
								NPT = 0,
								[Absent] = (case when @company = 'cambodia' then b.Absent when @company = 'bataan' then c.TotalAbsent else 0 end) -- b.Absent
						from (

							select workDate, worksection, avg(smv) smv, moCount =   count(distinct a.mono)
								FROM (
									select distinct convert(date,ScanDt) as workDate, worksection, mono,  smv = (select top 1 PlanSMV from mohdr  where mono = a.mono)
									from WIPScan (nolock) a where convert(date,ScanDt) between  @dateFrom and @dateTo
									and vap = @AssyPack
								) a
								GROUP BY  workDate, worksection
						) a

						LEFT OUTER JOIN  tmp (nolock) b
								on  b.OrganizationName  = a.workSection and b.WorkDate = a.workDate
						LEFT OUTER JOIN (
								select  WorkDate = a.datex, a.line, avg(total) Headcount ,  sum(wip_headcount_skill_total) TotalAbsent
								from wip_headcount_hdr (nolock) a
									inner join  wip_headcount_skill (nolock) whs on a.id = whs.wip_headcount_hdr_id
								Group by a.datex, a.line
						) c on c.WorkDate = a.workDate and c.line = a.WorkSection

					) A  --WHERE ProductionTarget is not null

	) B on a.WorkSection = b.prodline and convert(date,a.Datex) = convert(date,b.workDate)
	LEFT OUTER JOIN (
		--get All MO
		SELECT * FROM view_mo_all (nolock)
	) C on c.mono = a.mono
	LEFT OUTER JOIN (
		-- GET GOOD
		select  distinct a.MoNo, LineMoOutput = sum(qty), Prodline =  WorkSection
		from wipscan (nolock) a
		where  a.VAP = @AssyPack and	a.SVAP = 'ISS' --  and mono = '10517501001'
		group by mono, WorkSection
	) D on d.mono = a.mono  and a.WorkSection = D.Prodline
	LEFT OUTER JOIN (
		--GET START and FINISH
		select mono,	line, StartDate =  isnull(min(ActualStart),min(PlanStart)) ,  FinishDate = isnull(max(ActualFinish),max(PlanFinish))
		from BOHdr (nolock)
		group by mono,	line
	) E on e.mono = a.mono  and e.line = a.WorkSection
	--order by convert(int,hoursx)
END
--exec usp_execute_report_wip @reportName ='EQDailyOutputHdr', @dateFrom = '08/25/2018', @dateTo = '08/25/2018', @prodLine = 'M01'
ELSE IF @reportName = 'EQDailyOutputHdr'
BEGIN
	SELECT distinct WorkSection, '' as Description
	from WIPScan (nolock)
	WHERE convert(date,ScanDt) between @dateFrom and @dateTo
	and WorkSection = case when  @prodLine ='' then WorkSection  else @prodLine end
	and vap = @AssyPack
	order by WorkSection
END
--exec usp_execute_report_wip @reportName ='EQCDailyOutputDet', @dateFrom = '04/07/2021', @dateTo = '04/13/2021', @prodLine='L37'
ELSE IF @reportName = 'EQCDailyOutputDet'
BEGIN

	  declare @useSystemTarget varchar(10) = (select settings from wip_settings (nolock) where code = 'useSystemTarget')

		SELECT
				Datex = a.Date
				, Good = isnull(b.Good,0)
				, Reject = isnull(b.Reject,0),
			  ProductionTarget =
             case when @useSystemTarget = 'false'
                then isnull(( select top 1 convert(int,isnull(line_target,0)) from wip_headcount_hdr (nolock) where line = a.line and datex  =a.date and line_target > 0 order by datex desc ),0)
             else
               case when ProductionTarget is null then
               (ceiling( ( (@ProductionHeadcount * @ProductionWorkingMinutes) /
                          ( select top 1  PlanSMV from mohdr  where mono = (select top 1  MONo from WIPScan (nolock) where WorkSection = @prodLine order by ScanDt desc)  --SMV ONLY
               ) ) * @TargetPercentage) )
               else ProductionTarget end
            END,
				ProdLine = a.Line,
				HeadCount =  isnull(case when @company = 'cambodia' then (select top 1 HeadCount from tmp  (nolock) where OrganizationName = a.Line and WorkDate = a.date ) else isnull(HeadCount,0) end,0),
				WorkingMinutes =  isnull(b.WorkingMinutes,0),
				SMV = convert(numeric(12,3), isnull(smv, (select top 1  PlanSMV from mohdr  where mono = (select top 1  MONo from WIPScan (nolock) where WorkSection = @prodLine order by ScanDt desc)) ) ),
				HourlyTarget = isnull(HourlyTarget,0),
				WorkingHour = isnull(WorkingHour,0),
				MOCount = isnull(MOCount,0),
				NPT = isnull(NPT,0),
				Absent = isnull(case when @company = 'cambodia' then (select top 1 Absent from tmp (nolock) where OrganizationName = a.Line and WorkDate = a.date ) else isnull(absent,0) end,0),
				IncomingMo = isnull(IncomingMo,''),
				CurrentMo = isnull(CurrentMo, (select top 1  MONo from WIPScan (nolock) where WorkSection = @prodLine order by ScanDt desc) ) ,
				rework = isnull(reworkAll,0), --isnull(rework,0),
				scrap = isnull(scrap,0),
				repair = isnull(repair,0),
				rft = isnull(rft,0),
				previousRework = isnull(reworkAll,0) - isnull(rework,0),
        				targetSAH = isnull( (select sum(convert(int,target_set)) from wip_headcount_hdr (nolock) where line = a.line and datex = a.Date),0),
				targetPcs = isnull( (select sum(convert(int,line_target,0)) from wip_headcount_hdr (nolock) where line = a.line and datex = a.Date ),0),
			  OutputSAH = isnull( convert(int , round ( (SELECT SMV = AVG(SMV)
								FROM (
										select distinct MONo, SMV = (Select top 1  PlanSMV from mohdr (nolock) where mono =  x.moNo)
										from WIPScan (nolock) x where WorkSection = a.Line  and convert(date,ScanDt) = a.Date and x.VAP = @AssyPack and x.SVAP ='ISS'
								) XX ) / 60 * isnull(b.Good,0), 0) ), 0)

		FROM (

			SELECT  Line = a.ProdLine, Date = DateString  FROM dbo.DateRange_To_Table (@dateFrom,@dateTo)
			cross join dbo.ProdLines (nolock) a
			where a.ProdLine =  case when  @prodLine ='' then a.ProdLine  else @prodLine end
				--and  a.ProdLine in ('M01','M02','M03','M04','M05','M06','M07','M08','M09','M10','M11','M12','M13','M14','M15','M16','M17','M18','M19','M20','M21','M22','M23','M24','M25','M26','M27','M28','M29','M30','M31','M32')
		) a
		LEFT OUTER JOIN  (
			SELECT distinct
					Datex,
					Good,
					Reject = TotalReject, -- isnull(e.rework,0) +  isnull(d.scrap,0) +  isnull(d.repair,0),
					ProductionTarget = isnull(b.ProductionTarget,0 ),
					ProdLine = isnull(a.WorkSection,0),
					HeadCount= isnull(b.HeadCount,0),
					WorkingMinutes =  isnull(b.WorkingMinutes,0),
					SMV = isnull(b.SMV,0),
					HourlyTarget = isnull(b.HourlyTarget,0),
					WorkingHour = isnull(b.WorkingHour,0),
					MOCount = isnull(b.MOCount,0),
					NPT = isnull(b.NPT,0),
					Absent = isnull(b.Absent,0),
					IncomingMo = c.NextMo,
					CurrentMo = c.MoNo,
					rework =  isnull(d.rework,0), --isnull(d.rework,0),
					scrap = isnull(d.scrap,0),
					repair = isnull(d.repair,0),
					rft = good - isnull(e.rework,0),
					reworkAll = isnull(e.rework,0)
			FROM (
				SELECT Datex, Good = sum(Good), Reject =sum(Reject), WorkSection
				FROM (

					select   a.MONo, PTNO, WorkSection,
						Hoursx = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, a.ScanDt)), 2),
						Datex = convert(date,a.ScanDt),
						Good = sum(qty),
						Reject =  0
					from wipscan (nolock) a
					where  a.VAP = @AssyPack and	a.SVAP = 'ISS'
						and convert(date,a.ScanDt) between  @dateFrom and @dateTo
						 and WorkSection = case when  @prodLine ='' then WorkSection  else @prodLine end
					group by mono, RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, a.ScanDt)), 2),
					convert(date,a.ScanDt), PTNO, WorkSection
				) A GROUP BY Datex , WorkSection

			) A
			LEFT OUTER JOIN (
					-- Production Target and Attendance
					SELECT * FROM (
							select
								ProductionTarget =   ceiling( ( (@ProductionHeadcount * @ProductionWorkingMinutes) / a.smv) * @TargetPercentage),
								a.WorkSection as ProdLine,
								WorkDate = convert(date,a.workDate),
								HeadCount = (case when @company = 'cambodia' then b.HeadCount else c.Headcount  end),
								WorkingMinutes = @ProductionWorkingMinutes , SMV,
								HourlyTarget = ceiling((( @ProductionHeadcount * @ProductionWorkingMinutes) / a.smv * @TargetPercentage) / (@ProductionWorkingMinutes/60)),
								WorkingHour = (@ProductionWorkingMinutes/60),
								MOCount,
								NPT = 0,
								[Absent] = (case when @company = 'cambodia' then b.Absent else  c.TotalAbsent  end)
						from (
							select workDate, worksection, avg(smv) smv, moCount =   count(distinct a.mono)
								FROM (
									select distinct convert(date,ScanDt) as workDate, worksection, mono,  smv = (select top 1 PlanSMV from mohdr (nolock)  where mono = a.mono)
									from WIPScan (nolock) a where convert(date,ScanDt) between  @dateFrom and @dateTo
									and vap = @AssyPack
								) a
								GROUP BY  workDate, worksection
						) a
						LEFT OUTER JOIN  tmp b
								on  b.OrganizationName  = a.workSection and b.WorkDate = a.workDate
						LEFT OUTER JOIN (
								select  WorkDate = a.datex, a.line, avg(present) Headcount ,  sum(absentx) TotalAbsent
								from wip_headcount_hdr (nolock) a
									left outer join  wip_headcount_skill (nolock) whs on a.id = whs.wip_headcount_hdr_id
							--	where line = 'L01' and datex > '09/01/2019'
								Group by a.datex, a.line
						) c on c.WorkDate = a.workDate and c.line = a.WorkSection

					) A  --WHERE ProductionTarget is not null
			) B on  a.Datex = b.workDate and a.WorkSection = b.ProdLine
			LEFT OUTER JOIN
			(   --GET INCOMING AND CURRENT MO
				SELECT  A.workSection, B.MOno, NextMo = isnull((select top 1 MOno from BOHdr (nolock) where Line = a.workSection and mono !=b.mono and planStart > a.createdDt order by PlanStart),'N/A')
				from (
					select WorkSection, vap, max(ScanDt) createdDt from WIPScan (nolock) where VAP = @AssyPack
					group by vap, WorkSection
				) A INNER JOIN (
					Select  distinct mono, CreatedDt, workSection from WIPScan (nolock) where VAP = @AssyPack
				) b on a.createdDt = b.CreatedDt
			)C on a.workSection = c.workSection
			LEFT OUTER JOIN (
					--REJECT NEW
					SELECT DefectDate =  RejectDate, ProdLine,
							TotalReject = sum(reject),
							rework = sum(reworked),
							repair = sum(repair), scrap = sum(scrap)
					FROM (

						 -- Rejects and Rework Current Day
							select distinct
								MoNo, ProdLine, RejectDate,
								reject = sum(RejectQty)over(partition by MoNo, ProdLine, RejectDate),
								reworked = sum( case when FixedDt is not null and RejectType in ('REPAIR','REWORK') then 1 else 0 end )over(partition by MoNo, ProdLine, RejectDate),
								repair = sum( case when FixedDt is not null and RejectType = 'REPAIR' then 1 else 0 end )over(partition by MoNo, ProdLine, RejectDate),
								scrap = sum(case when RejectType = 'UNREPAIRABLE' then 1 else 0 end )over(partition by MoNo, ProdLine, RejectDate)
							FROM (
									select
											b.mono, a.*, RejectDate = TranDt,
											c.status, c.color, c.rejectType, FixedUserId,FixedDt, RejectQty = 1
									from (
											Select *, TranDt = convert(date,CreatedDt) from EndLineQCHdr (nolock) qh
											where Reject = 1 and convert(date,CreatedDt) between  @dateFrom and @dateTo
									) a
									Inner join LayingPT b (nolock) on a.PTNo = b.PTNo
									INNER JOIN EndLineQCRFID c  (nolock) on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine
							) A

					) A
					GROUP BY RejectDate, ProdLine
			) D on d.prodLine = a.WorkSection and a.Datex = d.defectDate
			LEFT OUTER JOIN (
					--REWOKED NEW
					select  a.ProdLine, convert(date,FixedDt) as workDate, rework =count(*)
					from EndLineQCHdr (nolock) a
						Inner join LayingPT (nolock) b on a.PTNo = b.PTNo
						INNER JOIN EndLineQCRFID (nolock) c on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine
					where Reject = 1
						and FixedDt is not null
						--and convert(varchar(12),FixedDt,101) between @dateFrom and @dateTo
						--and a.ProdLine = 'M04'
					group by  a.ProdLine, convert(date,FixedDt)
			) E on e.ProdLine = a.WorkSection and e.workDate = a.Datex

		) B on a.Line = b.ProdLine and a.Date = b.Datex
		order by a.Line
END
--exec usp_execute_report_wip 'ActualVsTargetListMono',  @season = 'Fall18', @style = 'DL9046-10', @color = 'BLACK/BLACK-003', @deliveryYearMonth = '201807'
ELSE IF @reportName = 'ActualVsTargetListMono'
BEGIN
  /*
	SELECT distinct  a.MoNo
	From wip_workers_output a
	Where  svap in ('FCUT', 'BPP', 'CEN')
	order by a.MONo
	 */
	 SELECT A.* FROM (
		SELECT A.*
		FROM (
				select mono,  color , style = StyleNo , deliveryDate = RevCusDelDt, orderQty = convert(int,qty), iono, setQty = 0,status, Season, (select count(*) from MODet (nolock) where mono = a.mono) as coCount
				from view_mo a
				where
				mono in    ( select * from dbo.fnSplitString (@mono,',') )  or mono = case when @mono = '' then mono   end
				and
				mono in (select distinct mono from wip_workers_output (nolock) )
		) A
		WHERE
		  season = (case when @season = '' then season else @season end)
		and Style = (case when @style = '' then Style else @style end)
		and Color = (case when @color = '' then Color else @color  end)
		and convert(varchar(4),year(deliveryDate)) + RIGHT('00' + convert(varchar(2), month(deliveryDate)),2)
		  = (case when @deliveryYearMonth = '' then convert(varchar(4),year(deliveryDate)) + RIGHT('00' + convert(varchar(2), month(deliveryDate)),2) else @deliveryYearMonth  end)
	) a
	WHERE (mono like '%'+@search+'%' or style like '%'+@search+'%' or color like '%'+@search+'%' or season like '%'+@search+'%')
	order by mono

END
--exec usp_execute_report_wip @reportName ='ActualVsTargetHdr', @moNo='10534601002'
ELSE IF @reportName = 'ActualVsTargetHdr'
BEGIN
  SELECT A.* FROM (
      SELECT distinct
        a.moNo,
          svap = 'FCUT'
      FROM OB a
      where mono in (
        SELECT distinct moNo
        From wip_workers_output (nolock) a
      )
      UNION
      SELECT distinct
        a.moNo,
          svap = 'STR'
      FROM OB a
      where mono in (
        SELECT distinct moNo
        From wip_workers_output (nolock) a
      )
  ) A
  where MONo = @moNo
  ORDER BY MONo
END
--exec usp_execute_report_wip @reportName ='ActualVsTargetDet', @moNo='10487301002', @svap = 'BPP'
ELSE IF @reportName = 'ActualVsTargetDet'
BEGIN
  SELECT SUM(TargetQty) as targetQty, Sum(outputQty) as OutputQty
  FROM (
    SELECT distinct
        targetQty = (
                      select sum(qty)
                      from LayingPT (nolock) x
                        inner join LayingHdr (nolock) y
                          on x.mono = y.mono and x.layNo = y.layNo
                      where x.mono = a.mono
                            and y.status = 'G'
                    ) * count(Feature),
        outputQty = isnull((select sum(qty)
                            from wip_workers_output (nolock)
                            where mono = a.MONo and svap = a.svap), 0)
    From OB (nolock) a
    Where a.mONo in (@moNo) and svap = @svap
    Group BY a.mONo, a.svap
    UNION
    SELECT
      0 as targetQty,
      0 as OutoutQty
  ) A

END
--exec usp_execute_report_wip @reportName ='WorkSections', @dateFrom = '06/26/2018', @dateTo = '06/26/2018'
ELSE IF @reportName = 'WorkSections'
BEGIN
	select distinct a.WorkSection, a.Desc1, a.VAP, a.SVAP
	from WorkSections (nolock) a
	  inner join view_wip_workers_output_by_worksection (nolock) b
		on a.WorkSection = b.workSection
	WHERE b.date between @dateFrom and @dateTo
--exec usp_execute_report_wip @reportName ='WorkSectionsDailyOutput', @dateFrom = '06/26/2018', @dateTo = '06/26/2018', @workSection = 'MCUT'
END
ELSE IF @reportName = 'WorkSectionsDailyOutput'
BEGIN
	SELECT   b.mono, b.style, b.color, b.svap, b.workSection, b.date, sum(b.qty) qty
	FROM WorkSections  (nolock)a
	  inner join view_wip_workers_output_by_worksection (nolock) b
		on a.WorkSection = b.workSection
	and b.date between @dateFrom and @dateTo
	WHERE b.workSection = @workSection --MCUT
	group by  b.mono, b.style, b.color, b.svap, b.workSection, b.date
	order by date, mono, svap
END
--exec usp_execute_report_wip @reportName ='WorkSectionsDailyOutput2', @dateFrom = '06/26/2018 06:00:00', @dateTo = '06/27/2018 06:00:00', @workSection = 'MCUT'
ELSE IF @reportName = 'WorkSectionsDailyOutput2'
BEGIN
	SELECT   b.mono, b.style, b.color, b.svap, b.workSection, date = convert(date,b.OutputDt),  RIGHT(CONCAT('00', DATEPART(hour, OutputDt)), 2) hour
		,sum(b.qty) qty
	FROM WorkSections (nolock) a
	  inner join wip_workers_output (nolock) b
		on a.WorkSection = b.workSection
	and b.OutputDt between @dateFrom and @dateTo
	WHERE b.workSection = @workSection --MCUT
	group by  b.mono, b.style, b.color, b.svap, b.workSection, convert(date,b.OutputDt),  RIGHT(CONCAT('00', DATEPART(hour, OutputDt)), 2)
	order by convert(date,b.OutputDt), mono, svap
END
--exec usp_execute_report_wip @reportName ='SytleImage', @moNo = '10038601001'
*/ --remarks by Donel 1
ELSE IF @reportName = 'SytleImage'
BEGIN
	select b.img01 as Photo from mo_hdr (nolock) a
	  inner join   Style_Image (nolock) b
		on a.Style_No = b.style_No
	where mono = @moNo
END --select distinct mono from wip_workers_output
--exec usp_execute_report_wip @reportName ='ActualVsTargetBppFcut', @moNo = '10774601001'
/* remarks by Donel 2
ELSE IF @reportName = 'ActualVsTargetBppFcut'
BEGIN
	select distinct a.*, svapBPP =  case when @company = 'cambodia' then 'STR' when @company = 'bataan' then 'HDL' else '' end,
																				  targetQtyBpp =isnull( b.targetQty,0), outputQtyBPP = isnull( b.outputQty,0),
			                 svapFCUT = @cut , targetQtyFCUT =isnull( c.targetQty,0), outputQtyFCUT = isnull( c.outputQty,0)
  from (
			SELECT distinct a.mono FROM (
				SELECT A.*
				FROM (
						select mono,  color , style = StyleNo , deliveryDate = RevCusDelDt, orderQty = convert(int,qty), iono, setQty = 0,status, Season, (select count(*) from MODet (nolock) where mono = a.mono) as coCount
						from view_mo (nolock) a
						where
						mono in    ( select * from dbo.fnSplitString (@mono,',') )  or mono = case when @mono = '' then mono   end
						and mono in (select distinct mono from wip_workers_output (nolock) a  where svap in ('STR', 'FCUT'))
				) A
				WHERE
					season = (case when @season = '' then season else @season end)
				  and Style = (case when @style = '' then Style else @style end)
				  and Color = (case when @color = '' then Color else @color  end)
				and convert(varchar(4),year(deliveryDate)) + RIGHT('00' + convert(varchar(2), month(deliveryDate)),2)
						= (case when @deliveryYearMonth = '' then convert(varchar(4),year(deliveryDate)) + RIGHT('00' + convert(varchar(2), month(deliveryDate)),2) else @deliveryYearMonth  end)
			) A
			WHERE (mono like '%'+@search+'%' or style like '%'+@search+'%' or color like '%'+@search+'%' or season like '%'+@search+'%')
  ) a
  LEFT OUTER JOIN
	(
		SELECT distinct Mono, svap,
			targetQty = isnull((
						  select sum(qty)
						  from LayingPT (nolock) x
							inner join LayingHdr (nolock) y
							  on x.mono = y.mono and x.layNo = y.layNo
						  where x.mono = a.mono
								and y.status = 'G'
						) * count(Feature),0),
			outputQty = isnull((select sum(qty)
								from wip_workers_output (nolock)
								where mono = a.MONo and svap = a.svap), 0)
		From OB (nolock) a
		Where  svap = case when @company = 'cambodia' then 'STR' when @company = 'bataan' then 'HDL' else '' end
		Group BY a.mONo, a.svap
	) B on a.mono = b.MONo
	LEFT OUTER JOIN
	(
		SELECT distinct Mono, svap,
			targetQty = isnull((
						  select sum(qty)
						  from LayingPT  (nolock)x
							inner join LayingHdr (nolock) y
							  on x.mono = y.mono and x.layNo = y.layNo
						  where x.mono = a.mono
								and y.status = 'G'
						) * count(Feature),0),
			outputQty = isnull((select sum(qty)
								from wip_workers_output (nolock)
								where mono = a.MONo and svap = a.svap), 0)
		From OB a
		Where  svap = 'FCUT' -- case when @company = 'cambodia' then 'STR' when @company = 'bataan' then 'HDL' else '' end
		Group BY a.mONo, a.svap
	) C on a.mono = C.MONo
END
--exec usp_execute_report_wip @reportName ='Kanban', @dateFrom = '07/18/2022', @prodLine = 'L20'
ELSE IF @reportName = 'Kanban'
	BEGIN

	declare @KanbanDate date = @dateFrom
	--KANBAN here usp_execute_report_wip
	SELECT distinct A.Line, A.ScanDt, A.MoNo, A.SMV, A.Start, A.Finish, A.PlanQty, A.MOQty, A.MOCusDelDt,
		Good = isnull(b.Good,0)  ,
		Reject = isnull(B.Reject,0)
		,Iono = (select  Iono from MOHdr (nolock) where mono = a.MONo) ,
		StyleNo = (select  StyleNo from MOHdr (nolock) where mono = a.MONo),
		Color = (select  top 1 MODet.Color from MODet (nolock) where mono = a.MONo) ,
    Season =  (select top 1 Season from IOHdr (nolock) where iono = (select  Iono from MOHdr (nolock) where mono = a.MONo))
		,NextMo = A.NextMO ,  -- ( case when Finish = 'Not Set in Planning' then isnull(( select top 1 mono as NextMo from bohdr where line = a.line and mono != b.mono and  isnull(ActualFinish,PlanFinish) > a.Finish order by isnull(ActualFinish,PlanFinish)),0) else '' end),
		Headcount =  isnull(HeadCount,0),
		WorkingMinutes = isnull(WorkingMinutes,0),
		Absent = isnull(Absent,0),
		avgSMV = isnull(d.avgSMV,0),
		-- ProductionTarget =   ceiling( ( (@ProductionHeadcount * @ProductionWorkingMinutes) /a.SMV) * @TargetPercentage),
		ProductionTarget = isnull( (-- GET PRODUCTION TARGET
												SELECT distinct
														 top  1 ProductionTarget =   ceiling( ( (32 * 660) / avg((select PlanSMV from MOHdr (nolock) where MONo = x.mono))over(partition by x.WorkSection, x.scanDt) ) * .75) -- FROM SMV =
												FROM (
													SELECT distinct MONo, WorkSection, ScanDt = convert(date,ScanDt),
														SMV = (select PlanSMV from MOHdr (nolock) where MONo = WIPScan.MONo)
													from WIPScan (nolock)
													where convert(date,ScanDt) = a.scanDt and vap = @AssyPack and SVAP = 'ISS' and WorkSection = a.Line
												) x
										),0),
		PercentageOfTarget = isnull(@TargetPercentage,0),
		HourlyTarget = isnull(HourlyTarget,0) ,
		MoCount = isnull(d.MoCount,0), NPT = isnull(NPT,0),
		a.TodayOutput, OverallOutput = isnull(a.OverallOutput,0),
		NextPlanQty = isnull(a.NextPlanQty,0), NextPlanStart = isnull(a.NextPlanStart,''),NextPlanFinish = isnull(a.NextPlanFinish,''),
		NextMOCusDelDt = isnull(a.NextMOCusDelDt,'') , -- newly addesd
		rework = isnull(rework,0), repair = isnull(repair,0), scrap = isnull(scrap,0)
		,DeviceLogIn = isnull( (select top 1  createdBy from WIPScan (nolock) where VAP = @AssyPack and MONo = a.mono AND WorkSection = a.line AND CONVERT(date,ScanDt) = a.ScanDt),'')
		,DeviceIDMac = (select top 1 MacId from DeviceProdLines (nolock) where ProdLines = a.Line order by CreatedDt desc)
		,OverAllPlanQtyByLine = isnull( (select sum(PlanQty) from BOHdr (nolock) where BOHdr.MONo = a.MONo and Line = a.Line),0)
    ,OverallMOOutput = isnull((select sum(qty) from WIPScan (nolock) where vap = @AssyPack and svap = 'ISS' and MONo = a.moNo),0)
		,Pending = isnull(Pending,0)-- = (isnull(B.Reject,0) - isnull(B.rework,0) - isnull(scrap,0) )
		,PlanStart ,PlanFinish
		,daysRunning = (select count(distinct convert(date,scanDt)) from wipScan (nolock) where Vap = @AssyPack and svap = 'ISS' and mono = a.MONo and WorkSection = a.Line)
		,previousRework = ( select count(1) from EndLineQCRFID (nolock) WHERE ProdLine = a.Line and convert(date,FixedDt) =  @dateFrom ) - sum(isnull(rework,0))over(partition by a.line)
	  ,PreviousPending = (select  count(*) FROM EndLineQCRFID (nolock) WHERE FixedDt is null and RejectType IN ('REJECT','REPLACEABLE') and ProdLine = a.Line and convert(date,TransDt) < @dateFrom )
    ,PreviousUnrepairable = (select  count(*) FROM EndLineQCRFID (nolock)  WHERE FixedDt is null and RejectType IN ('UNREPAIRABLE') and ProdLine = a.Line and convert(date,TransDt) < @dateFrom )
    ,NptMinutes = isnull(NptMinutes,0)
		,NptPercentage = isnull(NptPercentage,0.00)
		,qc_leader = isnull( (select top 1 CreatedBy from WIPScan (nolock) where MONo = a.moNo and convert(date,ScanDt) = A.ScanDt and VAP = @AssyPack and svap = 'ISS' and WorkSection = a.Line order by CreatedDt desc),'')
	FROM (

			SELECT A.Line, ScanDt, MoNo,
				SMV = AVG(SMV)over(partition by a.Line, a.MONo), Start, Finish, PlanQty, MOQty, MOCusDelDt,
				TodayOutput, OverallOutput,
        NextMO, NextPlanQty, NextPlanStart, NextPlanFinish, NextMOCusDelDt,
				PlanStart,PlanFinish
			FROM (

				SELECT A.*,
					Finish = isnull((
														(select convert(varchar(30),ActualEnd,101) from MOEvents (nolock) where MONo = a.MONo and eventSeq = '510')
											),'Not Set in Process Plan'),
					PlanStart = isnull((
											 (select convert(varchar(30),PlanStart,101) from MOEvents (nolock) where MONo = a.MONo and eventSeq = '510')
											),'Not Set in Process Plan'),
					PlanFinish = isnull((
											 (select convert(varchar(30),PlanEnd,101) from MOEvents (nolock) where MONo = a.MONo and eventSeq = '510')
											),'Not Set in Process Plan'),
					PlanQty = isnull((select top 1 PlanQty from BOHdr (nolock) where   line = a.Line and mono =a.MONo
											),0),

					MOCusDelDt = isnull((select top 1 MOCusDelDt = convert(varchar(20),MOCusDelDt,101) from BOHdr (nolock) where   line = a.Line and mono =a.MONo
											),'Not Set in Process Plan'),
					NextMO =  isnull((select TOP 1 MoNo from dbo.fnGetNextMo(a.Line) where seq > moseq and mono != a.MONo ORDER BY SEQ asc),''),
					NextPlanQty =  (select TOP 1 PlanQty from dbo.fnGetNextMo(a.Line) where seq > moseq and mono != a.MONo ORDER BY SEQ asc),
					NextPlanStart =  (select TOP 1 convert(date,Start) from dbo.fnGetNextMo(a.Line) where seq > moseq and mono != a.MONo ORDER BY SEQ asc),
					NextPlanFinish =  (select TOP 1 convert(date,Finish) from dbo.fnGetNextMo(a.Line) where seq > moseq and mono != a.MONo ORDER BY SEQ asc),
					NextMOCusDelDt =  (select TOP 1 convert(date, MoCusDelDt) from dbo.fnGetNextMo(a.Line) where seq > moseq and mono != a.MONo ORDER BY SEQ asc)
				FROM
					(

							SELECT distinct
									Line = ProdLine,
									ScanDt = @KanbanDate,
									moNo,
									MoQty = (select convert(int, sum(qty)) from MODet (nolock) where mono = a.MONo),
									SMV = (select PlanSMV from MOHdr (nolock) where mono = a.MONo),
									TodayOutput = isnull( (select sum(qty) from WIPScan (nolock) where vap = @AssyPack and svap = 'ISS' and WorkSection = a.ProdLine and MONo = a.moNo and convert(date, ScanDt) = @KanbanDate ),0) ,
									OverallOutput = (select sum(qty) from WIPScan (nolock) where vap = @AssyPack and svap = 'ISS' and WorkSection = a.ProdLine and MONo = a.moNo), --@AssyPack
									Start = isnull( (select convert(varchar(30),ActualStart,101) from MOEvents (nolock) where MONo = a.MONo and eventSeq = '510'),'Not Set in Process Plan'),
									MoSeq = (select TOP 1 Seq from dbo.fnGetNextMo(a.ProdLine) where mono = a.MONo ORDER BY SEQ DESC)
							FROM (
									--ADD all MO with OUTPUT
									select distinct a. mono, ProdLine = workSection  FROM WIPScan (nolock) a WHERE convert(date, ScanDt) = @KanbanDate and vap = @AssyPack  and svap = 'ISS' and WorkSection = @prodLine
									UNION
										--ADD all MO with REJECT
									select distinct xx.mono, x.ProdLine from EndLineQCHdr (nolock) x inner join  LayingPT (nolock) xx on x.PTNo = xx.PTNo where convert(date,x.CreatedDt) = @KanbanDate and x.Reject = 1 and prodLine =  @prodLine
									UNION
									 --ADD all MO with REPAIR
									select distinct xx.mono, x.ProdLine from EndLineQCRFID (nolock) x inner join  LayingPT xx on x.PTNo = xx.PTNo where convert(date,x.FixedDt) = @KanbanDate and prodLine =  @prodLine
							) A

				) A
			) A
	) A
	LEFT OUTER JOIN
	(
			SELECT A.MoNo,
					Line = a.Prodline,
					a.ScanDt, a.Good,
					reject = isnull(b.Reject,0),
					scrap = isnull(b.scrap,0),
					repair = isnull(c.repair,0),
					rework = isnull(c.rework,0),
					pending = isnull(d.Pending,0)

			FROM (
					--GOOD---
					SELECT distinct
							ScanDt = @KanbanDate,
							moNo,
							Prodline,
							Good =  isnull( (select sum(qty) from WIPScan (nolock) where vap = @AssyPack and svap = 'ISS' and WorkSection = a.ProdLine and MONo = a.moNo and convert(date, ScanDt) = @KanbanDate ),0)
					FROM (
							--ADD all MO with OUTPUT
							select distinct a. mono, ProdLine = workSection  FROM WIPScan (nolock) a WHERE convert(date, ScanDt) = @KanbanDate and vap = @AssyPack  and svap = 'ISS' and WorkSection = @prodLine
							UNION
								--ADD all MO with REJECT
							select distinct xx.mono, x.ProdLine from EndLineQCHdr (nolock) x inner join  LayingPT (nolock) xx on x.PTNo = xx.PTNo where convert(date,x.CreatedDt) = @KanbanDate and x.Reject = 1 and prodLine =  @prodLine
							UNION
							 --ADD all MO with REPAIR
							select distinct xx.mono, x.ProdLine from EndLineQCRFID (nolock) x inner join  LayingPT (nolock) xx on x.PTNo = xx.PTNo where convert(date,x.FixedDt) = @KanbanDate and prodLine =  @prodLine
					) A

			) A
			LEFT OUTER JOIN (
					--REJECT NEW
					SELECT  a.mono, a.ProdLine,
						RejectDate =convert(date,RejectDate),
						Reject = sum(TotalReject),
						scrap = sum(scrap)
					FROM (
							SELECT  mono,
										RejectDate,
										ProdLine,
										TotalReject = sum(RejectQty),
										scrap = case when  RejectType = 'UNREPAIRABLE' then sum(RejectQty)  else 0 end
							FROM (
										-- REJECT
											select
												b.mono, a.*, RejectDate = TranDt,
												c.status, c.color, c.rejectType, FixedUserId,FixedDt,
													RejectQty = 1
											from (
													Select *, TranDt = convert(date,CreatedDt) from EndLineQCHdr (nolock) qh
													where Reject = 1 and convert(date,CreatedDt) =   @KanbanDate

											) a
											Inner join LayingPT b (nolock) on a.PTNo = b.PTNo
											INNER JOIN EndLineQCRFID c  (nolock) on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine
												WHERE c.status not in ('CONDPASS')

								) a
							--WHERE RejectDate = '08/06/2018'
							GROUP BY  mono, a.ProdLine, RejectDate,  Status, RejectType
					) A
					GROUP BY mono, RejectDate, ProdLine
			) B ON A.MONo = B.MONO AND A.Prodline = B.ProdLine and a.ScanDt = b.RejectDate
			LEFT OUTER JOIN (
					-- GET ALL FIXED TODAY
					SELECT
							b.mono,
							a.ProdLine,
							FixedDt=convert(date,FixedDt),
							rework =  sum( case when status = 'PASSED' and RejectType in ('REPAIR','REWORK','CONDPASS')  then 1  else 0 end),
							repair =  sum( case when status = 'PASSED' and RejectType in ('REPAIR','CONDPASS')  then 1  else 0 end)
					from (
							Select *, TranDt = convert(date,CreatedDt) from EndLineQCHdr (nolock) qh
							where Reject = 1
					) a
					Inner join LayingPT b (nolock) on a.PTNo = b.PTNo
					INNER JOIN EndLineQCRFID c  (nolock) on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine
					WHERE convert(date,FixedDt) between  @dateFrom and @dateTo
					GROUP BY b.mono, a.ProdLine, convert(date,FixedDt)
			) C ON A.MONo = C.MONO AND A.Prodline = C.ProdLine and a.ScanDt = c.FixedDt
			LEFT OUTER JOIN (
					-- GET PENDING
					SELECT mono, prodLine, TransDt, Pending = sum(Pending)
					FROM (
							select MoNo = (select mono from LayingPT (nolock) where PTNo = a.ptNo), ProdLine, TransDt = convert(date,TransDt), Pending = count(*)
							FROM EndLineQCRFID (nolock) a
							where convert(date,TransDt) <= @dateFrom
								and FixedDt is null and RejectType != 'UNREPAIRABLE'
							group by a.ProdLine, convert(date,a.TransDt), PTNo
					) a
					GROUP By mono, prodLine, TransDt
			) d on a.MONo = d.MoNo and a.Prodline = d.ProdLine and a.ScanDt = d.TransDt
			--WHERE a.scanDt = @KanbanDate
	) B on A.MONo = B.MONO AND A.LIne = B.LIne and A.scanDt = b.ScanDt
	LEFT OUTER JOIN
	(	Select * from view_mo (nolock)
	) C  on a.mono = c.mono
	LEFT OUTER JOIN (

		--FOR REPLACE
		SELECT Line = a.OrganizationName, a.WorkDate, a.HeadCount,	a.WorkingMinutes, a.Absent, isnull(b.smv,0) as AvgSMV,
			--ProductionTarget =  isnull( ceiling( ( (HeadCount + absent ) * WorkingMinutes) / b.smv * @TargetPercentage) ,0),
			ProductionTarget =   ceiling( ( (@ProductionHeadcount * @ProductionWorkingMinutes) / b.smv) * @TargetPercentage),
			PercentageOfTarget = @TargetPercentage,
			HourlyTarget = isnull( ceiling((( (HeadCount + absent) * WorkingMinutes) / b.smv * @TargetPercentage) / (WorkingMinutes/60)) ,0),
			MOCount = isnull(MOCount,0) ,
			NPT = 0
		FROM TMP (nolock) a
		LEFT OUTER JOIN (
			SELECT Line, WorkDate = @KanbanDate,  avg(b.SMV) smv, count(a.mono) as MoCount
			FROM bohdr (nolock) a
			  inner join (
					select distinct vap, mono, worksection, convert(date,scanDt) scanDt,
							SMV = (select PlanSMV from MOHdr (nolock) where MONo = WIPScan.MONo)
					FROM wipScan (nolock)
					WHERE vap  = @AssyPack
					and convert(date,scanDt) = @KanbanDate
			   ) b on a.line = b.workSection  and a.mono = b.moNo
			WHERE @KanbanDate  between convert(date, isnull(actualStart,planStart)) and convert(date,isnull(actualFinish,planFinish))
			GROUP BY Line
		) B on a.OrganizationName = b.line and convert(date,a.workDate) = convert(date,b.workDate)
	) D on convert(date,d.workDate) = convert(date,a.scanDt) and d.line = a.line
  LEFT OUTER JOIN (

				SELECT a.work_section, NptMinutes = convert(numeric(12,2),a.NptMinutes), NptPercentage =  convert(numeric(12,2), NptMinutes/ nullif(PresentMinutes,0) * 100.00)
				FROM (
					SELECT work_section,
							NptMinutes = sum(NptMinutes),
							PresentMinutes =  ( select present from wip_headcount_hdr (nolock) where convert(date,datex) = convert(date,a.date_from) and line = a.work_section )  * 480
					FROM (
						select date_from = convert(date,date_from) , work_section, npt_type, employee_count,
								NPT = datediff(second,date_from, date_to) / 60.00,
								NptMinutes =  datediff(second,date_from, date_to) / 60.00 * employee_count
						from wip_npt_records (nolock) a
						where work_section = @prodLine and convert(date,date_from) = @dateFrom
					)A
					GROUP BY work_section, date_from
				) A
		) E on E.work_section = a.Line
	--Where good is not null
	order by a.line

END
--exec usp_execute_report_wip @reportName ='Get Attendance', @dateFrom = '08/27/2019', @dateTo = '08/27/2019'
ELSE IF @reportName = 'Get Attendance'
BEGIN
	DECLARE @sqlCommand2 varchar(1000)
	DECLARE @RecordCount2 int
		IF @company = 'Cambodia'
		BEGIN
					SET @sqlCommand2 = 'DELETE FROM TMP WHERE WorkDate between '''+ convert(varchar(12),@dateFrom,101) +''' and '''+ convert(varchar(12),@dateTo,101) +''' INSERT INTO TMP SELECT * FROM OPENROWSET(
					''MSDASQL'',''DRIVER={SQL Server};SERVER=172.30.44.24\DLUXE;UID=sa;PWD=glohrisdevadmin'',
					''exec iplex_hris.dbo.usp_get_report_wip ''''HeadCountByLine'''','''''+ convert(varchar(12),@dateFrom,101) +''''','''''+ convert(varchar(12),@dateTo,101) +''''''')'
					exec (@sqlCommand2 )

					SELECT * FROM TMP where WorkDate between @dateFrom and @dateTo
		END
END
/*
	exec usp_execute_report_wip @reportName ='EQCHourlyOutputDet2', @dateFrom = '09/16/2019 01:00:00', @dateTo = '09/16/2019 23:59:00' , @prodLine = 'M02'
*/
ELSE IF @reportName = 'EQCHourlyOutputDet2'
BEGIN

	SET @dateTo = dateadd(hour, 4, @dateTo)

	SELECT distinct A.moNo, hoursx, good = isnull(good,0)  --+ isnull(Reworked,0)
		,Reject, hourlyTarget = isnull(hourlyTarget,0), ProductionTarget = isnull(ProductionTarget,0), Manpower = isnull(b.Manpower,0),
		smv = isnull(b.smv,0), WorkingHour = isnull(b.WorkingHour,0), WorkingMinutes = isnull(b.WorkingMinutes,0), NPT = isnull(b.NPT,0),
		IoNo, MoQty = Qty, MoSmv = c.smv , StyleNo, Color, DeliveryDate = RevCusDelDt,  StartDate = isnull(StartDate,'') , FinishDate = isnull(FinishDate,'') ,
		LineMoOutput = isnull(LineMoOutput,0), a.WorkSection, Reworked = isnull(Reworked,0), UnderRepair = isnull(UnderRepair,0), UnRepairable = isnull(UnRepairable,0),
		Rft = isnull(case
					when  ( reworked  > 0 and  reject !=  reworked )  then  (good -  reject)  +  (reject - reworked)
					when reworked  = reject then good - reject
					else isnull(good,0) end,0),
		Absent = isnull(b.Absent,0)
	FROM
	(
		---------
			select aa.mono, aa.WorkSection,
					Hoursx = aa.ScanHr, Datex = aa.date,
					Good = isnull(a.good,0),
				  Reject = isnull(b.TotalRejects,0),
				  Reworked = isnull(C.Reworked,0),
					UnderRepair = isnull(UnderRepair,0),
					UnRepairable = isnull(UnRepairable,0)
			from (
				select distinct a.*
				from (
						--MO in GOOD
						select   mono, workSection, date = convert(date,ScanDt),
								ScanHr = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, ScanDt)  ), 2)
						from WIPScan where  ScanDt between @dateFrom and @dateTo
						and vap = @AssyPack and	SVAP = 'ISS'
						and WorkSection =case when  @prodLine ='' then WorkSection  else @prodLine end

						UNION
						-- MO in REJECT
						SELECT    MONo, ProdLine, TransDt, TransHour
						FROM (
									select
											b.mono, a.*,
											FixedDt = convert(date,FixedDt),
											FixedHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, FixedDt)), 2),
											TransDt = convert(date,c.TransDt),
											TransHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, c.TransDt)), 2),
											c.status, c.color, c.rejectType, FixedUserId,  RejectQty = 1
									from EndLineQCHdr a
										Inner join LayingPT b on a.PTNo = b.PTNo
										INNER JOIN EndLineQCRFID c on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine
									where Reject = 1
									and c.ProdLine = case when  @prodLine ='' then c.ProdLine  else @prodLine end
									and TransDt between @dateFrom and @dateTo
						) a

						UNION
							--REWORKED HOUR
						SELECT    MONo, ProdLine, FixedDt = convert(date,FixedDt) , FixedHour
						FROM (
									select
											b.mono, a.*,
											FixedDt =  FixedDt,
											FixedHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, FixedDt)), 2),
											TransDt = c.TransDt,
											TransHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, c.TransDt)), 2),
											c.status, c.color, c.rejectType, FixedUserId,  RejectQty = 1
									from EndLineQCHdr a
										Inner join LayingPT b on a.PTNo = b.PTNo
										INNER JOIN EndLineQCRFID c on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine
									where Reject = 1
									and c.ProdLine = case when  @prodLine ='' then c.ProdLine  else @prodLine end
									and FixedDt between  @dateFrom and @dateTo
						) a

				) a
			) aa
			LEFT OUTER JOIN (
					SELECT mono, WorkSection,Hoursx, Datex, Good = sum(good), Reject = sum(reject)
					FROM (
						select   a.mono, PTNO, WorkSection,
							Hoursx = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, a.ScanDt)), 2),
							Datex = convert(date,a.ScanDt),
							Good = sum(qty),
						  Reject = 0
						from wipscan a
						where  a.VAP =  @AssyPack and	a.SVAP = 'ISS'
							and a.ScanDt between  @dateFrom and @dateTo
							and WorkSection =  case when  @prodLine ='' then WorkSection  else @prodLine end
						group by mono, RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, a.ScanDt)), 2),
						convert(date,a.ScanDt), WorkSection, PTNo
					) A
					GROUP BY mono, WorkSection,Hoursx, Datex
			) a on a.MONo = aa.MONo and a.WorkSection = aa.WorkSection and aa.date = a.Datex and aa.ScanHr = a.Hoursx
			LEFT OUTER JOIN (
						--REJECT per hour
							SELECT A.MONo, TransDt, TransHour, ProdLine, TotalRejects = sum(TotalRejects), Reworked = sum(Reworked),
									UnderRepair = sum(UnderRepair), UnRepairable = sum(UnRepairable)
							FROM (
									SELECT  MONo, TransDt,TransHour,   ProdLine, TotalRejects = sum(RejectQty),
												Reworked = case when Status = 'PASSED' and RejectType in ('REPAIR','REWORK') and FixedDt is not null then sum(RejectQty)  else 0 end,
												UnderRepair = case when Status = 'REJECT' and RejectType in ('REPAIR','REWORK') and FixedDt is null then sum(RejectQty)  else 0 end,
												UnRepairable = case  when RejectType in ('UNREPAIRABLE') then sum(RejectQty)  else 0 end
									FROM (
												select
														b.mono, a.*,
														FixedDt = convert(date,FixedDt),
														FixedHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, FixedDt)), 2),
														TransDt = convert(date,c.TransDt),
														TransHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, c.TransDt)), 2),
														c.status, c.color, c.rejectType, FixedUserId,  RejectQty = 1
												from EndLineQCHdr a
													Inner join LayingPT b on a.PTNo = b.PTNo
													INNER JOIN EndLineQCRFID c on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine
												where Reject = 1
												and c.ProdLine = case when  @prodLine ='' then c.ProdLine  else @prodLine end
												and TransDt between  @dateFrom and @dateTo
									) a
									GROUP BY  TransDt, a.ProdLine,   Status, RejectType, TransDt,TransHour, MONo,FixedDt, FixedHour
							) A
							group by A.MONo, TransDt, TransHour, ProdLine
			)B ON aa.MONo = b.MONo and aa.WorkSection = b.ProdLine and aa.ScanHr = b.TransHour and aa.date = b.TransDt
			LEFT OUTER JOIN (
					--FIXED per HOUR
					SELECT A.MONo, FixedDt, FixedHour, ProdLine, Reworked = sum(Reworked)
					FROM (
							SELECT  MONo, FixedDt,FixedHour,   ProdLine,
										Reworked = case when Status = 'PASSED' and RejectType in ('REPAIR','REWORK') and FixedDt is not null then sum(RejectQty)  else 0 end
							FROM (
										select
												b.mono, a.*,
												FixedDt = convert(date,FixedDt),
												FixedHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, FixedDt)), 2),
												TransDt = convert(date,c.TransDt),
												TransHour = RIGHT('00' + CONVERT(VARCHAR(2), DATEPART(HOUR, c.TransDt)), 2),
												c.status, c.color, c.rejectType, FixedUserId,  RejectQty = 1
										from EndLineQCHdr a
											Inner join LayingPT b on a.PTNo = b.PTNo
											INNER JOIN EndLineQCRFID c on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine
										where Reject = 1
										and c.ProdLine = case when  @prodLine ='' then c.ProdLine  else @prodLine end
										and FixedDt between  @dateFrom and @dateTo
							) a
							GROUP BY  FixedDt, a.ProdLine,   Status, RejectType, TransDt,TransHour, MONo,FixedDt, FixedHour
					) A
					group by A.MONo, FixedDt, FixedHour, ProdLine
			) C ON aa.MONo = c.MONo and aa.WorkSection = c.ProdLine and aa.ScanHr = c.FixedHour and aa.date = c.FixedDt
	) A
	LEFT OUTER JOIN (
		-- Production Target and Attendance
				SELECT * FROM (
						select
								ProductionTarget =   ceiling( ( (@ProductionHeadcount * @ProductionWorkingMinutes) / a.smv) * @TargetPercentage),
								a.WorkSection as ProdLine,
								WorkDate = convert(date,a.workDate),
								Manpower = (case when @company = 'cambodia' then b.HeadCount when @company = 'bataan' then c.HeadCount else 0 end),
								WorkingMinutes = @ProductionWorkingMinutes , SMV,
								HourlyTarget = ceiling((( @ProductionHeadcount * @ProductionWorkingMinutes) / a.smv * @TargetPercentage) / (@ProductionWorkingMinutes/60)),
								WorkingHour = (@ProductionWorkingMinutes/60),
								MOCount,
								NPT = 0,
							  [Absent] = (case when @company = 'cambodia' then b.Absent when @company = 'bataan' then c.TotalAbsent else 0 end)
						from (
								select workDate, worksection, avg(smv) smv, moCount =   count(distinct a.mono)
								FROM (
									select distinct convert(date,ScanDt) as workDate, worksection, mono,  smv = (select top 1 PlanSMV from mohdr  where mono = a.mono)
									from WIPScan a where  ScanDt between  @dateFrom and @dateTo
									and vap = @AssyPack
								) a
								GROUP BY  workDate, worksection
						) a
						LEFT OUTER JOIN  tmp b
								on  b.OrganizationName  = a.workSection and b.WorkDate = a.workDate
						LEFT OUTER JOIN (
								select  WorkDate = a.datex, a.line, avg(total) Headcount ,  sum(wip_headcount_skill_total) TotalAbsent
								from wip_headcount_hdr a
									inner join  wip_headcount_skill whs on a.id = whs.wip_headcount_hdr_id
								Group by a.datex, a.line
						) c on c.WorkDate = a.workDate and c.line = a.WorkSection

					) A  --WHERE ProductionTarget is not null

	) B on a.WorkSection = b.prodline and convert(date,a.Datex) = convert(date,b.workDate)
	LEFT OUTER JOIN (
		--get All MO
		SELECT * FROM view_mo_all
	) C on c.mono = a.mono
	LEFT OUTER JOIN (
		-- GET GOOD
		select  distinct a.MoNo, LineMoOutput = sum(qty), Prodline =  WorkSection
		from wipscan a
		where  a.VAP = @AssyPack and	a.SVAP = 'ISS' --  and mono = '10517501001'
		group by mono, WorkSection
	) D on d.mono = a.mono  and a.WorkSection = D.Prodline
	LEFT OUTER JOIN (
		--GET START and FINISH
		select mono,	line, StartDate =  isnull(min(ActualStart),min(PlanStart)) ,  FinishDate = isnull(max(ActualFinish),max(PlanFinish))
		from BOHdr
		group by mono,	line
	) E on e.mono = a.mono  and e.line = a.WorkSection
	--order by convert(int,hoursx)
END
--exec usp_execute_report_wip @reportName ='Output Issue Receive History', @status= 'ISSUED' , @dateFrom = '07/01/2021', @dateTo = '07/11/2021',  @prodLine = 'M02',  @moNo ='11570301004',
ELSE IF @reportName = 'Output Issue Receive History'
BEGIN

		SELECT A.MONo, a.Style, Color, Process, destinaton, TransactionDate, status, BundleNo, Feature, FeatureDesc, Qty, CreatedBy, WorkSection,
				totalQty = sum(qty)over(partition by Filter)/*usp_execute_report_wip : 'Output Issue Receive History' */
		FROM (
			SELECT MONo, Style, Color,  Process =svap,
					destinaton = 'N/A',
					TransactionDate = OutputDt,
					 status = 'OUTPUT',
					BundleNo, Feature,  FeatureDesc,  Qty,
					CreatedBy,  Filter = 'All', WorkSection
			FROM wip_workers_output a
				WHERE	convert(date,OutputDt) between convert(date,@dateFrom)   and convert(date,@dateTo)
				and MONo = case when @mono = '' then mono else @mono end
			UNION
			SELECT MONo, Style, Color,
					Process = (select value from dbo.fnSplitStringWithRow(origin,' ') where id= '2'),
					destination = SVAP,
					TransactinDate = ScanDt,
					status = case when status = 'PENDING' then 'ISSUED' else 'RECEIVED' END,
					BundleNo, Feature, FeatureDesc,  Qty,
					issued_by, Filter = 'All', WorkSection
			FROM wip_consolidation a
			WHERE	convert(date,ScanDt) between convert(date,@dateFrom)   and convert(date,@dateTo)
			and  MONo = case when @mono = '' then mono else @mono end
		) A
		WHERE
			 convert(date,TransactionDate) between convert(date,@dateFrom)   and convert(date,@dateTo)
			and Process = case when @process = '%' then Process else @process end
		 	and MONo = case when @mono = '' then mono else @mono end
			and status = case when @status = '' then status else @status end
END
--exec usp_execute_report_wip @reportName ='EQC Hourly Output v2', @dateFrom = '04/21/2022 01:00:00', @dateTo = '04/21/2022 23:59:00', @prodLine = 'L02'
ELSE IF @reportName = 'EQC Hourly Output v2'
BEGIN
 	  SELECT A.Type, WorkSection, MONo = MONo + ' (' + isnull( (select STUFF((select  ',' +  iOLn from MODet aa inner join IODet bb on aa.ItemNo = bb.ItemNo where aa.MONo = a.MONo FOR XML PATH('')), 1, 1, '') ),'') + ')',
      ScanDt, Qty,
				Date = '',  Hours = '', SMV = convert(numeric(12,2), round(SMV,2))
		FROM (

				SELECT Type = 'GOOD', WorkSection , MONo, ScanDt, Qty, SMV=(select PlanSMV from MOHdr where MONo = a.MONo)
				FROM WIPScan a
				where convert(date,ScanDt) between convert(date,@dateFrom) and convert(date,@dateTo)
							and (WorkSection in (select * from dbo.fnSplitString (@prodLine,',') ) or  WorkSection = case when @prodLine ='' then WorkSection end)
							and VAP = @AssyPack and SVAP = 'ISS'

				UNION ALL

				SELECT Type = 'REJECT', a.ProdLine, MONo = (select moNo from LayingPT where PTNo = a.PTNo), CreatedDt,
						Qty = case when c.RejectType = 'CONDPASS' then 0 else 1 end, SMV = 0
				FROM EndLineQCHdr a
					INNER JOIN   EndLineQCRFID c  (nolock) on c.PTNo = a.PTNo and c.Seq = a.Seq and c.ProdLine = a.ProdLine -- added april 14 2021. eduard
				where convert(date,CreatedDt) between convert(date,@dateFrom) and convert(date,@dateTo) and Reject = 1
							and (a.ProdLine in (select * from dbo.fnSplitString (@prodLine,',') ) or  a.ProdLine = case when @prodLine ='' then a.ProdLine end)

				UNION ALL

				SELECT Type = 'REWORK', ProdLine , MONo = (select moNo from LayingPT where PTNo = a.PTNo), FixedDt, Qty = 1, SMV= 0
				FROM EndLineQCRFID (nolock) a
				where convert(date,FixedDt) between convert(date,@dateFrom) and convert(date,@dateTo)
							and (ProdLine in (select * from dbo.fnSplitString (@prodLine,',') ) or  ProdLine = case when @prodLine ='' then ProdLine end)
	  ) A
	  order by Type, ScanDt
END
--exec usp_execute_report_wip @reportName ='EQCHourlyOutputHdrV3', @dateFrom = '11/22/2021', @prodLine = 'L36'
--exec usp_execute_report_wip @reportName ='EQCHourlyOutputHdrV3', @dateFrom = '03/16/2021', @prodLine = 'B01'
ELSE IF @reportName = 'EQCHourlyOutputHdrV3'
BEGIN
	SELECT ProdLine, Desc1, Output = case when b.Qty > 0 then 'true' else 'false' end,
		MONo = isnull(b.MONo,''),
		StyleNo = c.StyleNo,
		OrderQty = c.qty,
		PlanMonth = c.ProdMonth,
		ExFactoryDate = isnull( (select top 1 convert(date,EX_FTY_DT) from view_wip_ex_factory where mono = c.mono order by EX_FTY_DT ),'1900-01-01'),
		AllocatedQty = isnull( (select sum(PlanQty) from BOHdr (nolock) where mono = b.MONo and Line = b.WorkSection),0),
		MoLineTotalQty = isnull( (select sum(Qty) from WIPScan (nolock) where mono = b.MONo and  WorkSection = b.WorkSection and VAP = @AssyPack and SVAP = 'ISS'),0),
		MoBalance = isnull( (select sum(PlanQty) from BOHdr (nolock) where mono = b.MONo and Line = b.WorkSection),0) - isnull( (select sum(Qty) from WIPScan (nolock) where mono = b.MONo and  WorkSection = b.WorkSection and VAP = @AssyPack and SVAP = 'ISS'),0) ,
		Target =isnull( ( select convert(int,line_target) from wip_headcount_hdr where datex = @dateFrom and line = b.WorkSection ),0),
		TodaysOutput = isnull( (select sum(Qty) from WIPScan (nolock) where mono = b.MONo and  WorkSection = b.WorkSection and VAP = @AssyPack and SVAP = 'ISS' and convert(date,ScanDt) = @dateFrom),0),
		--style_target = isnull( (select value_ from wip_references where ref_code ='style_target' and key_ = c.StyleNo),0),
		present = isnull((select isnull(present,0) from wip_headcount_hdr where datex = @dateFrom and line = a.ProdLine),0),
		CPONo = isnull(  STUFF((SELECT distinct  ', ' + CAST(CPONo + ' | '  +  MODet.Dest AS VARCHAR(20))  [text()]
                   FROM MODet
                   WHERE MONo = b.MONo  FOR XML PATH(''), TYPE).value('.','NVARCHAR(MAX)'),1,2,''),'') , 
		ColorDesc, '' as Dest, bb.CustStyle, ProdType = (select Desc1 from ProdTypes where ProdType = BB.ProdType)
	FROM prodlines a
	INNER JOIN (
			SELECT distinct WorkSection, Qty = isnull(sum(qty),0), Mono
			from WIPScan
			WHERE convert(date,ScanDt) = @dateFrom
			and vap = @AssyPack
			group by WorkSection, MONo
	) b on a.ProdLine = b.WorkSection
	LEFT OUTER JOIN view_mo_all c on c.mono = b.MONo
	INNER JOIN (
        SELECT distinct MONo, CPONo, ColorDesc, Dest, CustStyle, ProdType = (select top 1 ProdType from MOHdr where MONo = XX.MONo)  from ordMOInitvw XX
 ) BB on b.mono = BB.mono
	WHERE (ProdLine in (select * from dbo.fnSplitString (@prodLine,',') ) or  ProdLine = case when @prodLine ='' then ProdLine end)

END
--exec usp_execute_report_wip @reportName ='EQCHourlyOutputDetV3', @dateFrom = '07/18/2022', @dateTo = '07/18/2022 23:59:00' , @prodLine = 'L20'
--select * from WIPScan where MONo = '13550101001' and WorkSection = 'c27' and ScanDt >= '03/16/2021'
ELSE IF @reportName = 'EQCHourlyOutputDetV3'
BEGIN
 		SELECT A.Type, WorkSection, MONo, --ScanDt, qty, --
				 ScanDt = CONVERT(VARCHAR(13), ScanDt, 120) + ':00' , Qty =sum(Qty),
				Date = '',  Hours = '', SMV =  convert(numeric(12,2), round(SMV,2))
		FROM (

				SELECT Type = 'GOOD', WorkSection , MONo, ScanDt = format(ScanDt, 'MM/dd/yyyy HH:mm:ss'), Qty, SMV=(select PlanSMV from MOHdr where MONo = a.MONo)
				FROM WIPScan  (nolock) a
				where convert(date,ScanDt) = convert(date,@dateFrom)
							and (WorkSection in (select * from dbo.fnSplitString (@prodLine,',') ) or  WorkSection = case when @prodLine ='' then WorkSection end)
							and VAP = @AssyPack and SVAP = 'ISS'

				UNION ALL

				SELECT Type = 'REJECT', aa.ProdLine, MONo = (select moNo from LayingPT where PTNo = aa.PTNo), CreatedDt, Qty = 1, SMV = 0
				FROM EndLineQCHdr  (nolock) aa
        INNER JOIN EndLineQCRFID cc  (nolock) on cc.PTNo = aa.PTNo and cc.Seq = aa.Seq and cc.ProdLine = aa.ProdLine
				where convert(date,CreatedDt) = convert(date,@dateFrom) and Reject = 1
							and (aa.ProdLine in (select * from dbo.fnSplitString (@prodLine,',') ) or  aa.ProdLine = case when @prodLine ='' then aa.ProdLine end)
              and cc.Status not in ('CONDPASS')

				UNION ALL

				SELECT Type = 'REWORK', ProdLine , MONo = (select moNo from LayingPT where PTNo = a.PTNo), FixedDt, Qty = 1, SMV= 0
				FROM EndLineQCRFID  (nolock) a
				where convert(date,FixedDt) = convert(date,@dateFrom)
							and (ProdLine in (select * from dbo.fnSplitString (@prodLine,',') ) or  ProdLine = case when @prodLine ='' then ProdLine end)
	  ) A
		GROUP BY A.Type, WorkSection, MONo ,   CONVERT(VARCHAR(13), ScanDt, 120) + ':00',  convert(numeric(12,2), round(SMV,2))
	  order by Type, 4
END
*/ --remarks by Donel 2
go

CREATE procedure bo_hdr_recalculate_revert_confirm
	@recId VARCHAR(50) =''
AS
	--1. DELETE ALL THE DATA IN BO_HDR where tmp and bo_hdr is the same
	DELETE b
	from bo_hdr_deleted a
		inner join bo_hdr b on a.MONo = b.MONo and a.Line = b.Line and a.BONo = b.BONo
	where  a.rec_id = @recId

	--3 INSERT THE DATA NOW FROM TMP TO BO_HDR
	INSERT INTO BO_Hdr(mono, bono, mfg_loc, mo_qty,  Line, cp_no, plan_qty, smv, eff, plan_start, plan_finish,
							actual_start, actual_finish, plant_color, Prd_Typ, Prd_Typ2 , total_output_qty,
							prod_month, completed, created_by, time_created, time_updated, MO_Cus_Del_Dt  , Trans_Id, Updated_By)
	select a.mono, a.bono, a.mfg_loc, a.MO_Qty, a.Line, a.cp_no, a.plan_qty, a.smv, a.eff, a.plan_start, a.plan_finish,
							a.actual_start, a.actual_finish, a.plant_color, a.Prd_Typ, a.Prd_Typ2 , a.total_output_qty,
							a.prod_month, a.completed, a.created_by, a.time_created, a.time_updated, a.MO_Cus_Del_Dt, a.rec_id, a.Updated_By
	from bo_hdr_deleted a
	where  rec_id = @recId

	delete from bo_hdr_deleted where  rec_id = @recId
go

CREATE FUNCTION dbo.getNextWorkingDate(@dateToCheck date) RETURNS Datetime
AS
BEGIN
    DECLARE @tempDate datetime
    SET @tempDate=DATEADD(day,1,@dateToCheck)
    WHILE EXISTS(SELECT * FROM m_line_mp_exception WHERE @tempDate BETWEEN date_from AND date_to)
    BEGIN
        SET @tempDate=DATEADD(day,1,@tempDate)
    END

    IF( datename(weekday, @tempDate) = 'Sunday' )
    BEGIN
      SET @tempDate=DATEADD(day,1,@tempDate)
    END

    RETURN dateadd(minute, 450, @tempDate) -- default to 7:30 daily
END
go

CREATE PROCEDURE dbo.usp_insert_output_set
  @mono varchar(20) = 104447,
  @bundleNo bigint = 209,
  @svap varchar(10) = 'ICUT',
  @svapAndNext varchar(10) = ''
AS

  declare
  @moid bigint,
  @ptId bigint

  select @moId = id from mo_hdr where mono = @mono
  select @ptId = id from laying_pt where mo_id = @moid and bundle_no = @bundleNo

  insert into wip_scan(
    mo_id, pt_id, bundle_no,   vap, svap, load_type,  qty, work_section_id, output_id, scan_dt,
    active, created_by, sbu_id, time_created
  )
  SELECT a.mo_id, a.pt_id, a.bundle_no, vap = b.svap+'-'+b.next_check_point,
    a.svap, load_type = 'O', output_qty, work_sections_id, a.id, output_date,
    a.active, a.created_by, a.sbu_id, getdate()
  FROM wip_workers_output a
  INNER JOIN ob b ON a.ob_id = b.id
  WHERE a.mo_id = @moid
    AND a.pt_id = @ptId
    AND b.svap+'-'+b.next_check_point = @svapAndNext
    AND a.svap = @svap
    AND b.last_opn = 1
    AND NOT EXISTS (
      SELECT 1
      FROM wip_scan
      WHERE mo_id = @moid
        AND pt_id = @ptId
        AND load_type = 'O'
        --AND wip_scan.vap = @svapAndNext
        AND svap = @svap
        AND output_id  = a.id
    );
go

CREATE PROCEDURE [dbo].[prdGetDBDateSP] (@UserID nvarchar(50))  

AS  

BEGIN  
    
	SELECT DATEADD(dd, DATEDIFF(dd, 0, getdate()), 0) as DateToday, @UserID as UserID
  
END
go

CREATE PROCEDURE dbo.usp_insert_issued_set
  @mono varchar(20) = 104447,
  @bundleNo bigint = 209,
  @origin varchar(10) = 'ICUT',
  @svap varchar(10) = 'SKI',
  @nextCheckPoint varchar(10) = ''
AS

  declare
  @moid bigint,
  @ptId bigint

  select @moId = id from mo_hdr where mono = @mono
  select @ptId = id from laying_pt where mo_id = @moid and bundle_no = @bundleNo

  insert into wip_scan(
    mo_id, pt_id, bundle_no, vap, origin, svap, next_check_point, load_type, qty, work_section_id, issued_id, scan_dt,
    active, created_by, sbu_id, time_created )

  SELECT a.mo_id, a.pt_id, a.bundle_no,  vap=a.origin+'-'+a.svap,
    a.origin, a.svap, a.next_check_point, load_type = 'I', issued_qty, work_section_id, a.id, scan_dt,
    a.active, a.created_by, a.sbu_id, getdate()
  FROM wip_scan_part a
  INNER JOIN ob b ON a.ob_id = b.id
  WHERE a.mo_id = @moid
    AND a.pt_id = @ptId
    AND a.svap = @svap
    AND a.origin = @origin
    AND a.next_check_point = @nextCheckPoint
    AND b.last_opn = 1
      AND NOT EXISTS (
        SELECT 1
        FROM wip_scan
        WHERE mo_id = @moid
          AND pt_id = @ptId
          AND load_type = 'I'
          AND wip_scan.svap = @svap
          and wip_scan.next_check_point = @nextCheckPoint
          and wip_scan.origin = @origin
          AND issued_id  = a.id
      );
go



CREATE PROCEDURE [dbo].[prdGetCalendarSP] (@SBU_ID int,@UserID nvarchar(50))  

AS  

BEGIN  
    
	SELECT
		Calendar as Calendar_Cd
		,Long_Text as Long_Text
		,DefaultWeekName as Default_Week_Name
		,Deleted as Deleted
		,Time_Created as Time_Created
		,Created_By 
		,Time_Updated 
		,Updated_By    
	FROM 
		Calendar
	ORDER BY 
		Calendar_Cd
  
END

go

CREATE PROCEDURE dbo.usp_insert_received_set
  @mono varchar(20) = 104447,
  @bundleNo bigint = 209,
  @origin varchar(10) = 'ICUT',
  @svap varchar(10) = 'SKI',
  @nextCheckPoint varchar(10) = ''
AS

  declare
  @moid bigint,
  @ptId bigint

  select @moId = id from mo_hdr where mono = @mono
  select @ptId = id from laying_pt where mo_id = @moid and bundle_no = @bundleNo

  insert into wip_scan(
      mo_id, pt_id, bundle_no,   vap, svap, load_type,  qty, work_section_id, received_id, scan_dt,
      active, created_by, sbu_id, time_created )

  SELECT a.mo_id, a.pt_id, a.bundle_no,  vap=a.origin+'-'+a.svap,
    a.svap, load_type = 'R', issued_qty, work_section_id, a.id, scan_dt,
    a.active, a.created_by, a.sbu_id, getdate()
  FROM wip_scan_part a
  INNER JOIN ob b ON a.ob_id = b.id
  WHERE a.mo_id = @moid
    AND a.pt_id = @ptId
    AND a.svap = @svap
    AND a.origin = @origin
    and a.next_check_point = @nextCheckPoint
    AND a.received_date is not null
    AND b.last_opn = 1
      AND NOT EXISTS (
        SELECT 1
        FROM wip_scan
        WHERE mo_id = @moid
          AND pt_id = @ptId
          AND load_type = 'R'
          AND svap = @svap
          AND origin = @origin
          AND issued_id  = a.id
      );
go



CREATE PROCEDURE [dbo].[prdGetCalendarExsSP] (@SBU_ID int, @Calendar varchar(50),@UserID nvarchar(50))  

AS  

BEGIN  


	INSERT INTO BOTimestamp(Mfg_Loc,Process,User_Id,[Time_stamp]) 
	VALUES(@Calendar,'Loading Calendar',@UserID,getdate())

	SELECT
		Calendar as Calendar_Cd
		,NEWID() as Ex_Name
		,Long_Text 
		,Has_Work 
		,dateadd(d,v.number,e.Date_From) as Date_From
		,dateadd(d,v.number,e.Date_From) as Date_To
		,Time_Created
		,Created_By
		,Time_Updated
		,Updated_By 
	FROM 
		Calendar_Ex e
		INNER JOIN
		master..spt_values v on v.type='P'
			and v.number between 0 and datediff(d, Date_From, Date_To)
	WHERE
		Calendar = @Calendar
	ORDER BY 
		Date_From
		,Date_To


    
	
  
END


go

CREATE procedure dbo.usp_update_material_alert(@mono varchar(20), @returnSelect bit)
AS

    /*Common Table Expression (CTE)*/
    WITH alerts_cte AS (
      select a.*, KeyEvent, ExFactoryDate_Req_Start, Actual_Start,
          alert = case when Latest_ETA > ExFactoryDate_Req_Start then 1 else 0 end
      from (
        --MATERIAL ETA
        Select event_seq = case when Mat_Typ = 'Hardware' then 110 when Mat_Typ = 'Leather' then 100 when Mat_Typ = 'Textile' then 105 else 0 end,
          MONo, Mat_Typ, Latest_ETA
        from mo_mat_eta a where a.mono =@mono and Mat_Typ in ('Hardware','Leather','Textile')
      )  a
      INNER JOIN
        (
        --CRITICAL PATH
        SELECT Event_Seq, KeyEvent, ExFactoryDate_Req_Start, Actual_Start
        FROM ordMOEventsUpdateV3vw where mono = @mono and KeyEvent in ('Leather Arrvl','Fabric/Fillers Arrvl','Acc/Hardware Arrvl')
      ) B on a.event_seq = b.Event_Seq
    )
    --select  countAlert= sum(alert) from alerts_cte;
    update bo_hdr set is_material_delayed = case when (select  countAlert= sum(alert) from alerts_cte) >1 then 1 else 0 end where MONo = @mono

    if (@returnSelect = 1)
    BEGIN
        select a.*, KeyEvent, ExFactoryDate_Req_Start, Actual_Start,
            alert = convert(bit, case when Latest_ETA > ExFactoryDate_Req_Start then 1 else 0 end)
        from (
          --MATERIAL ETA
          Select event_seq = case when Mat_Typ = 'Hardware' then 110 when Mat_Typ = 'Leather' then 100 when Mat_Typ = 'Textile' then 105 else 0 end,
            MONo, Mat_Typ, Latest_ETA
          from mo_mat_eta a where a.mono =@mono and Mat_Typ in ('Hardware','Leather','Textile')
        )  a
        INNER JOIN
          (
          --CRITICAL PATH
          SELECT Event_Seq, KeyEvent, ExFactoryDate_Req_Start, Actual_Start
          FROM ordMOEventsUpdateV3vw where mono = @mono and KeyEvent in ('Leather Arrvl','Fabric/Fillers Arrvl','Acc/Hardware Arrvl')
        ) B on a.event_seq = b.Event_Seq
    END
go



CREATE PROCEDURE [dbo].[prdGetCalendarWeekSP] (@SBU_ID int,@UserID nvarchar(50))

AS  

BEGIN  
    
	SELECT
		Calendar as Calendar_Cd
		,Week_Name 
		,Date_From 
		,Date_To
		,Time_Created
		,Created_By
		,Time_Updated
		,Updated_By
	FROM 
		Calendar_Week
	ORDER BY 
		Date_From
		,Date_To
  
END


go



CREATE PROCEDURE [dbo].[prdGetCalendarWeekDaySP] (@SBU_ID int, @Calendar varchar(50),@UserID nvarchar(50))

AS  

BEGIN  
    
	SELECT
		Calendar as Calendar_Cd
		,Week_Name 
		,Week_Day 
		,Has_Work as HasWork
		,Seq as Seq
		,Time_Created 
		,Created_By 
		,Time_Updated 
		,Updated_By as UpdatedBy
	FROM 
		Calendar_Week_Day
	WHERE 
		Calendar = @Calendar 
	ORDER BY 
		Calendar
		,Week_Name
		,Seq
  
END


go

CREATE FUNCTION dbo.getNextWorkingDateV2(@dateToCheck date)
RETURNS  @rtnTable TABLE
(
  date datetime not null ,
  name nvarchar(25) not null
)
AS
BEGIN
    DECLARE @tempDate datetime

    SET @tempDate=DATEADD(day,1,@dateToCheck)
    WHILE EXISTS(SELECT * FROM m_line_mp_exception WHERE @tempDate BETWEEN date_from AND date_to)
    BEGIN
--         SET @tempDate=DATEADD(day,1,@tempDate)
        INSERT INTO @rtnTable(date, name)
        SELECT @tempDate, 'Holiday'
    END

    IF( datename(weekday, @tempDate) = 'Sunday' )
    BEGIN
--       SET @tempDate=DATEADD(day,1,@tempDate)
        INSERT INTO @rtnTable(date, name)
        SELECT @tempDate, 'Sunday'
    END

    if NOT EXISTS(select top 1 * from @rtnTable)
    BEGIN
        INSERT INTO @rtnTable(date, name)
        SELECT @tempDate, datename(weekday, @tempDate)
    END

    RETURN --SELECT top 1 date, name from @rtnTable order by date
END
go

--select newid()
--select sum(qty) from mo_det where mono = '13572801001'
/*
exec usp_save_planning @mfgLoc= 'TARLAC',  @mono= '15162301001', @lineNo = 'L05', @planStart = '2023-02-06 10:38:00',  @planQty= 203, @id = 0, @createdBy = 'Eduard', @sbuId = 1, @transId = '5A0ACFA7-816E-4B4F-8C68-0170917BB8B5'
select * from bo_hdr where Line = 'L01'
*/
CREATE PROCEDURE usp_save_planning
--declare
    @mfgLoc varchar(10) = 'TARLAC',
    @mono varchar(11) ='',
    @lineNo varchar(4) = '',
    @planStart datetime = null,
    @planQty integer = null ,
    @id BIGINT = 0,
    @createdBy varchar(20) ='',
    @sbuId int =  1,
    @isAutoAssignedPlanStart bit = 0,
    @isAutoPlanBalance bit = 0,
    @transId uniqueidentifier
AS
/*
set @mono  = '13133001002'
set @lineNo = 'L05'
SET @mfgLoc   = 'TARLAC'
SET @planStart = '2023-02-06 10:38:00'
SET @planQty = 203
SET @sbuId  =  1
SET @id = 0
SET @isAutoAssignedPlanStart = 0
SET @isAutoPlanBalance = 0
SET @transId = newid()
-- */

declare @MAX_SCHEDULED_TIME_FINISH int = 15 --3PM. SET SOON
declare @planBalance INTEGER
declare @previosPlanBalance INTEGER
declare @dailyTarget INTEGER
declare @minutesTarget numeric(12,6) = 0
declare @actualPlanQty integer = 0
declare @TotalPlanQty integer = 0
declare @periodStart integer
declare @newPlanStart datetime
declare @planFinish datetime
declare @mfgLocId integer
declare @moId bigint


declare @efficiency numeric(12,4)
declare @manpower int
declare @workingMinutes int
declare @smv numeric(12,4)
declare @planStartMinutes integer = 0
declare @sheduleFinishBase datetime
declare @planStartBase datetime
declare @duration integer
-- declare @transId UNIQUEIDENTIFIER
declare @bono int
declare @timeCreated datetime = getdate()
declare @prodType varchar(20)
declare @prodMonth varchar(20)
declare @cusDelDt varchar(20)
declare @moQty int
declare @nextWorkingDate datetime
declare @moPlannedQty integer = 0
declare @moQtyPLanBalance int = 0
declare @insertId varchar(50)= newid()

-- SET @mono = '13133001001'
-- SET @planQty = 500
-- SET @lineNo = 'L01'
-- SET @planStart = '2023-12-11 07:00:00.000'

declare @dateToCheck date = getdate()
declare @tempDate datetime = @dateToCheck
declare @DEFAULT_DATETIME datetime = dateadd(hour,7, @tempDate )

IF(@isAutoAssignedPlanStart = 1 OR @planStart is null )
BEGIN
  select @planStart = isnull(dateadd(minute, 1, max(Plan_Finish)), @DEFAULT_DATETIME ) from BO_Hdr where Line = @lineNo
END

--select @planStart, @isAutoAssignedPlanStart

SET @planBalance = isnull(@planQty,0)
SET @periodStart = 1
SET @newPlanStart = @planStart

-- IF EDITING and HAS ID PASSED. DELETE THE DATA
if(@id > 0)
BEGIN
    declare @lineToDelete varchar(4)
    select @mono = mono, @bono=bono, @lineToDelete= Line from BO_Hdr where id = @id
    delete from BO_Daily_Target where MONo = @mono and BONo = @bono and Mfg_Loc = @mfgLoc and Line = @lineToDelete
    delete from BO_Hdr where id = @id
END

SELECT @mfgLocId  = id from m_mfg_locs where code = @mfgLoc
SELECT @moId = id, @prodType = prod_type, @prodMonth = prod_month, @cusDelDt = cus_del_dt from mo_hdr where mono = @mono
select @bono = isnull(max(BONo) + 1,1) from BO_Hdr where MONo = @mono;
select @moQty = isnull(sum(qty),0) from mo_det where mono = @mono and qty > 0
select @moPlannedQty = isnull(sum(Plan_Qty),0) from BO_Hdr where MONo = @mono;

SET @moQtyPLanBalance = @moQty -  (@moPlannedQty + @planQty)

--SET THE NEW PLAN BALANCE FROM THE MO QTY LESS PLANNED
IF(@isAutoPlanBalance = 1 OR @planQty is null )
BEGIN
  SET @planBalance  = (@moQty-@moPlannedQty)
END

IF ( @moPlannedQty = @moQty )
BEGIN
  select code = 'error', description = 'this mono is already zero balance.'
  RETURN
END

-- VALIDATE. CHECK THE BALANCE
IF ( @moPlannedQty+@planBalance > @moQty )
BEGIN
  select code = 'error', description = 'please set your plan qty to ' + convert(varchar(12), @moQty-@moPlannedQty  )
  RETURN
END

if (EXISTS(select 1 from BO_Hdr where MONo = @mono and Line = @lineNo and @planStart between Plan_Start and Plan_Finish  ))
BEGIN
   SELECT 'error' as code, 'mono ' + @mono + ' with plan start ' + convert(varchar(20),@planStart) + ' and line '+ @lineNo + ' is already exists.' as description
    return
END

IF ( @planBalance = 0 )
BEGIN
  select code = 'error', description = 'no more balance to plan! total planned qty is ' + convert(varchar(12), @moPlannedQty)
  RETURN
END

IF(NOT EXISTS(select top 1 1 from  dbo.m_line_mp where line_code=@lineNo and eff_date<=@planStart order by eff_date desc))
BEGIN
  select code = 'error', description = 'Line manpower settings with effective date '
                                       + convert(varchar(20), @planStart) +' on line '+convert(varchar(20),@lineNo) +' not found. '
  RETURN
END

IF(NOT EXISTS(select * from m_line_lc where code =@prodType and line_code =@lineNo))
BEGIN
  select code = 'error', description = 'Learning curve settings with prod type '+convert(varchar(20),@prodType) +' and line '+convert(varchar(20),@lineNo) +' not found.'
  RETURN
END

IF( EXISTS(select 1 from mo_hdr where mono = @mono and plansmv <= 1 ))
BEGIN
  select code = 'error', description = 'Plan smv is less than or equal to 1.'
  RETURN
END

BEGIN TRAN START_TRANS
--LOOP UNTIL NO BALANCE LEFT
while(@planBalance > 0)
-- while (@periodStart <= 3 )
BEGIN

    SET @sheduleFinishBase = dateadd(hour, @MAX_SCHEDULED_TIME_FINISH,'1900-01-01 00:00')
    SET @planStartBase = '1900-01-01 ' + format(@newPlanStart,'HH:mm')
    -- GET THE DURATION FROM PLAN START TO END OF SCHEDULE
    SET @duration = datediff(minute,@planStartBase, @sheduleFinishBase)

    SELECT
        @periodStart = period,
        @dailyTarget = manpower*working_minutes/smv*efficiency,
        @minutesTarget = (manpower*working_minutes/smv*efficiency)/working_minutes,
        @efficiency = efficiency,
        @manpower = manpower,
        @workingMinutes = working_minutes,
        @smv =smv,
        --@actualPlanQty = case when @planBalance >= @dailyTarget then @dailyTarget else @planBalance end,
        @planStartMinutes = (DATEPART(HOUR, @newPlanStart ) * 60) + DATEPART(MINUTE, @newPlanStart ),
        --1. PCS = TARGET QTY PER MINUTE TIMES REMAINING MINUTES OF THE DAY
        @actualPlanQty = ((manpower*working_minutes/smv*efficiency)/working_minutes) * @duration
    FROM (
        --1. Get the learning curve
        select code, period = period , efficiency,
            manpower = (select  top 1 manpower from ImappsV2.dbo.m_line_mp
                        where line_code =a.line_code
                        and eff_date<= @newPlanStart order by eff_date desc ),
            working_minutes = 480,
            smv = (select  plansmv from mo_hdr where mono = @mono )
        from view_learning_curve a
        where  line_code = @lineNo  and code = @prodType
        AND period = @periodStart
    ) A2

    if(@efficiency = 0)
    BEGIN
      select code = 'error', description = 'No setup efficiency on line ' + convert(varchar(20),@lineNo) +' with period ' + convert(varchar(20), @periodStart) +
      ' and prod type ' + @prodType
      goto err
      RETURN
    END

    --PCS = PLAN BALANCE
    --DURATION = now base on the REMAINING BALANCE
    IF(@planBalance <= @actualPlanQty)
    BEGIN
        SET @actualPlanQty = @planBalance
        SET @duration = @planBalance/@minutesTarget
    END

    SET @planBalance = @planBalance - @actualPlanQty
    SET @TotalPlanQty = @TotalPlanQty + @actualPlanQty

  -- TEMPORARY STORE THE PREVIOUS BALANCE
    SET @previosPlanBalance = @planBalance

    --IF PLAN BALANCE > 0. MEANS COMPLETE PLAN = TARGET. BUT WE NEED TO CONSIDER WHAT TIME IT STARTED TO PLAN.
    SET @planFinish =  dateadd(minute, @duration, @newPlanStart ) -- working_minutes = 540, 480 = 8 hours + 60 = 1 hours Break

  --CHECK VALUE HERE
/*     select @periodStart as periodStart, @planBalance as planBalance,@previosPlanBalance as previosPlanBalance, @TotalPlanQty TotalPlanQty,  @planQty planQty, @actualPlanQty as actualPlanQty,
            @duration as duration, @planStartBase planStartBase, @sheduleFinishBase sheduleFinishBase, @newPlanStart as newPlanStart,
            @nextWorkingDate nextWorkingDate, @planFinish as planFinish
*/
    --INSERT THE DAILY TARGET HERE
    INSERT INTO BO_Daily_Target(MONo, BONo, Line, Date, smv, seq, plan_start, plan_finish, Qty, original_daily_target,
                                Trans_Id, Trans_Dt, Mfg_Loc, sbu_id, Mfg_Loc_id, mo_id, Created_By, Time_Created, insert_id )

    SELECT @mono, BONo = @bono, @lineNo, @newPlanStart, @smv, @periodStart, @newPlanStart, @planFinish, @actualPlanQty, @dailyTarget,
      @transId, Trans_Dt = getdate(), @mfgLoc, @sbuId, @mfgLocId, @moId, @createdBy, @timeCreated, @insertId


    SET @nextWorkingDate  = dbo.getNextWorkingDate(@planFinish)

    -- GET NEXT DAY OR CONTINUE
    SET @newPlanStart = case when datepart(hour,@planFinish) >= @MAX_SCHEDULED_TIME_FINISH
      then @nextWorkingDate else  dateadd(minute, 1, @planFinish) end

    SET @periodStart = @periodStart + 1

END



--STEP 2: Summarize the data
DELETE FROM BO_Hdr where MONo = @mono and BONo = @bono
INSERT INTO BO_Hdr(sbu_id, MONo, MO_Qty, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Plan_Start, Plan_Finish, Prd_Typ, MO_Cus_Del_Dt, Prod_Month, Created_By, Time_Created, Trans_Id, active, total_planned_qty, insert_id)
SELECT @sbuId, MONo, @moQty, BONo, Mfg_Loc, Line, sum(Qty) as qty, smv, min(plan_start), max(plan_finish), @prodType, @cusDelDt, @prodMonth, @createdBy, @timeCreated, @transId, 1, sum(Qty), @insertId
FROM BO_Daily_Target
WHERE MONo = @mono and Trans_Id = @transId
GROUP BY MONo, BONo, Mfg_Loc, Line,  smv

--STEP 3: INSERT THE MO+BO LEARNING CURVE
DELETE FROM BO_Learn_Curve where MONo = @mono and BONo = @bono and Line = @lineNo and sbu_id = @sbuId
insert into BO_Learn_Curve(MONo, BONo, Line, Learn_Curve, Period_01, Period_02, Period_03, Period_04, Period_05, Period_06, Period_07, Period_08, Period_09, Period_10,
                            Period_11, Period_12, Period_13, Period_14, Period_15, Period_16, Period_17, Period_18, Period_19, Period_20,
                            Period_21, Period_22, Period_23, Period_24, Period_25, Period_26, Period_27, Period_28, Period_29, Period_30,
                            Created_By, Time_Created, Updated_By, Trans_Id, Trans_Dt, Mfg_Loc, active, sbu_id, insert_id)
select top 1 MONo = @mono, BONo = @bono, Line = @lineNo, Learn_Curve, Period_01, Period_02, Period_03, Period_04, Period_05, Period_06, Period_07, Period_08, Period_09, Period_10,
                            Period_11, Period_12, Period_13, Period_14, Period_15, Period_16, Period_17, Period_18, Period_19, Period_20,
                            Period_21, Period_22, Period_23, Period_24, Period_25, Period_26, Period_27, Period_28, Period_29, Period_30,
                            Created_By, Time_Created, Updated_By, @transId, @timeCreated, @mfgLoc, active, sbu_id, @insertId
from m_line_lc
WHERE line_code = @lineNo and code = @prodType

--UPDATE MATERIAL STATSU
exec usp_update_material_alert @mono =@mono, @returnSelect = 0

SELECT 'success' as code, 'succesfull planned!' as description, plan_finish = @planFinish
-- SELECT *  from BO_Daily_Target where Line in ('L01','L02')

COMMIT TRAN START_TRANS
return

err:
ROLLBACK TRAN START_TRANS
go


-- exec [qconn_mo_summary] '12195901005', 'BLACK'
CREATE procedure [dbo].[qconn_mo_summary_v3]
(
	  @mono varchar(20),
    @color varchar(20) = '',
    @vap varchar(20) = 'ASSY-PPACK'
)
as
select a.MONo,
    total_inspected_qty = isnull(good_qty, 0) + isnull(TotalReject, 0) + isnull(total_repaired_qty, 0) + isnull(total_unrepairable, 0),
    total_good_qty = isnull(good_qty, 0) - isnull(total_reworked_qty, 0),
    total_rejected_qty = isnull(TotalReject, 0) + isnull(total_reworked_qty, 0),
    total_reworked_qty = isnull(total_reworked_qty, 0),
    total_repaired_qty = isnull(total_repaired_qty, 0),
    total_unrepairable = isnull(total_unrepairable, 0),
    actualRejectedQty = isnull(TotalReject, 0),
    total_replaceable_qty = isnull(total_replaceable_qty, 0)
from
(
 /*   select MONo, sum(qty) as good_qty
    from WIPScan (nolock)
    where vap = @vap and svap = 'ISS' and MONo = @mono
    group by MONo
	*/
	--declare @mono varchar(20) = '15405901001'
	select mono, sum(good) as good_qty from (
	select mono,sum(1) as good
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	where b.mono = @mono and reject = 0
	group by mono
	union all
	select mono,sum(1) as good
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	inner join endlineqcrfid c on a.ptno  = c.ptno and a.seq = c.seq and c.status = 'PASSED'
	where b.mono = @mono and reject = 1
	group by mono
	union all
	select mono,sum(c.qty) as good
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	inner join endlineqcrfid c on a.ptno  = c.ptno and a.seq = c.seq and c.status = 'CONDPASS' and cpapproveduserid is not NULL
	where b.mono = @mono and reject = 1
	group by mono

	) a
	group by mono
) a
left outer join
(
    select c.MONo,
        SUM(CASE WHEN b.RejectType = 'REJECT' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as TotalReject,
        SUM(CASE WHEN b.RejectType in ('REWORK', 'REPAIR') and b.[Status] = 'PASSED' THEN 1 ELSE 0 END) as total_reworked_qty,
        SUM(CASE WHEN b.RejectType = 'REPAIR' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as total_repaired_qty,
        SUM(CASE WHEN b.RejectType = 'UNREPAIRABLE' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as total_unrepairable,
        SUM(CASE WHEN b.RejectType = 'REPLACEABLE' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as total_replaceable_qty
    from EndLineQCHdr a (nolock)
    inner join Laying_PT c (nolock) on a.PTNo = c.PTNo
    inner join EndLineQCRFID b (nolock) on a.PTNo = b.PTNo and a.Seq = b.Seq
    where a.Reject = 1 and c.MONo = @mono
    group by c.MONo
) b on a.MONo = b.MONo
go

CREATE PROCEDURE usp_save_planning_re_arrange
--BEGIN  TRANSACTION
--rollback transaction
--declare
    @mfgLoc varchar(10) = 'TARLAC',
    @mono varchar(11) ='',
    @lineNo varchar(4) = '',
    @planStart datetime = null,
    @planQty integer = null ,
    @id BIGINT = 0,
    @createdBy varchar(20) ='',
    @sbuId int =  1,
    @isAutoAssignedPlanStart bit = 0,
    @isAutoPlanBalance bit = 0,
    @transId uniqueidentifier
AS
/*
set @mono  = '15270901001'
set @lineNo = 'L09'
SET @mfgLoc   = 'TARLAC'
SET @planStart = '2023-03-21 07:30:00.000'
SET @planQty = 100
SET @sbuId  =  1
SET @id = 32797
SET @isAutoAssignedPlanStart = 0
SET @isAutoPlanBalance = 0
SET @transId = '4D357B06-0104-4E66-9A29-53EB81C29044' --newid()
 --*/

declare @MAX_SCHEDULED_TIME_FINISH int = 15 --3PM. SET SOON
declare @planBalance INTEGER
declare @previosPlanBalance INTEGER
declare @dailyTarget INTEGER
declare @minutesTarget numeric(12,6) = 0
declare @actualPlanQty integer = 0
declare @TotalPlanQty integer = 0
declare @periodStart integer
declare @newPlanStart datetime
declare @planFinish datetime
declare @mfgLocId integer
declare @moId bigint


declare @efficiency numeric(4,2)
declare @manpower int
declare @workingMinutes int
declare @smv numeric(12,4)
declare @planStartMinutes integer = 0
declare @sheduleFinishBase datetime
declare @planStartBase datetime
declare @duration integer
-- declare @transId UNIQUEIDENTIFIER
declare @bono int
declare @timeCreated datetime = getdate()
declare @prodType varchar(20)
declare @prodMonth varchar(20)
declare @cusDelDt varchar(20)
declare @moQty int
declare @nextWorkingDate datetime
declare @moPlannedQty integer = 0
declare @moQtyPLanBalance int = 0
declare @dateToCheck date = getdate()
declare @tempDate datetime = @dateToCheck
declare @DEFAULT_DATETIME datetime = dateadd(minute,450, @tempDate ) --7:30 am
declare @insertId varchar(50)= newid()



IF(@isAutoAssignedPlanStart = 1 OR @planStart is null )
BEGIN
  select @planStart = isnull(dateadd(minute, 1, max(Plan_Finish)), @DEFAULT_DATETIME ) from BO_Hdr where Line = @lineNo
END

--select @planStart, @isAutoAssignedPlanStart

SET @planBalance = isnull(@planQty,0)
SET @periodStart = 1
SET @newPlanStart = @planStart

-- IF EDITING and HAS ID PASSED. DELETE THE DATA
if(@id > 0)
BEGIN
    declare @lineToDelete varchar(4)
    select @mono = mono, @bono=bono, @lineToDelete= Line from BO_Hdr where id = @id
    delete from BO_Daily_Target where MONo = @mono and BONo = @bono and Mfg_Loc = @mfgLoc and Line = @lineToDelete
    --delete from BO_Hdr where id = @id
END
ELSE
BEGIN
  select @bono = isnull(max(BONo) + 1,1) from BO_Hdr where MONo = @mono;
END

SELECT @mfgLocId  = id from m_mfg_locs where code = @mfgLoc
SELECT @moId = id, @prodType = prod_type, @prodMonth = prod_month, @cusDelDt = cus_del_dt from mo_hdr where mono = @mono
select @moQty = isnull(sum(qty),0) from mo_det where mono = @mono and qty > 0
select @moPlannedQty = isnull(sum(Plan_Qty),0) from BO_Hdr where MONo = @mono and id != @id;

SET @moQtyPLanBalance = @moQty -  (@moPlannedQty + @planQty)

--SET THE NEW PLAN BALANCE FROM THE MO QTY LESS PLANNED
IF(@isAutoPlanBalance = 1 OR @planQty is null )
BEGIN
  SET @planBalance  = (@moQty-@moPlannedQty)
END

IF ( @moPlannedQty = @moQty )
BEGIN
  select code = 'error 1 ', description = 'this mono is already zero balance.', next_mo_plan_start = null
  RETURN
END

-- VALIDATE. CHECK THE BALANCE
IF ( @moPlannedQty+@planBalance > @moQty )
BEGIN
  select code = 'error 2 ' + @mono, description = 'please set your plan qty to ' + convert(varchar(12), @moQty-@moPlannedQty  ), next_mo_plan_start = null
  RETURN
END

if (EXISTS(select 1 from BO_Hdr where MONo = @mono and Line = @lineNo and @planStart between Plan_Start and Plan_Finish and id !=@id ))
BEGIN
  select * from BO_Hdr where MONo = @mono and Line = @lineNo and @planStart between Plan_Start and Plan_Finish and id !=@id
   SELECT 'error 3 ' + @mono as code, 'mono ' + @mono + ' with plan start ' + convert(varchar(20),@planStart) + ' and line '+ @lineNo + ' is already exists.' as description,  next_mo_plan_start = null
    return
END

IF ( @planBalance = 0 )
BEGIN
  select code = 'error 4 ' + @mono, description = 'no more balance to plan! total planned qty is ' + convert(varchar(12), @moPlannedQty) , next_mo_plan_start = null
  RETURN
END

IF(NOT EXISTS(select top 1 1 from  dbo.m_line_mp where line_code=@lineNo and eff_date<=@planStart order by eff_date desc))
BEGIN
  select code = 'error 5 ' + @mono, description = 'Line manpower settings with effective date '
                                       + convert(varchar(20), @planStart) +' on line '+convert(varchar(20),@lineNo) +' not found. ' , next_mo_plan_start = null
  RETURN
END

IF(NOT EXISTS(select * from m_line_lc where code =@prodType and line_code =@lineNo))
BEGIN
  select code = 'error 6 ' + @mono, description = 'Learning curve settings with prod type '+convert(varchar(20),@prodType) +' and line '+convert(varchar(20),@lineNo) +' not found.', next_mo_plan_start = null
  RETURN
END

IF( EXISTS(select 1 from mo_hdr where mono = @mono and plansmv <= 1 ))
BEGIN
  select code = 'error 7 ' + @mono, description = 'Plan smv is less than or equal to 1.' , next_mo_plan_start = null
  RETURN
END

-- BEGIN TRAN START_TRANS
--LOOP UNTIL NO BALANCE LEFT
while(@planBalance > 0)
-- while (@periodStart <= 3 )
BEGIN

    SET @sheduleFinishBase = dateadd(hour, @MAX_SCHEDULED_TIME_FINISH,'1900-01-01 00:00')
    SET @planStartBase = '1900-01-01 ' + format(@newPlanStart,'HH:mm')
    -- GET THE DURATION FROM PLAN START TO END OF SCHEDULE
    SET @duration = datediff(minute,@planStartBase, @sheduleFinishBase)

    SELECT
        @periodStart = period,
        @dailyTarget = manpower*working_minutes/smv*efficiency,
        @minutesTarget = (manpower*working_minutes/smv*efficiency)/working_minutes,
        @efficiency = efficiency,
        @manpower = manpower,
        @workingMinutes = working_minutes,
        @smv =smv,
        --@actualPlanQty = case when @planBalance >= @dailyTarget then @dailyTarget else @planBalance end,
        @planStartMinutes = (DATEPART(HOUR, @newPlanStart ) * 60) + DATEPART(MINUTE, @newPlanStart ),
        --1. PCS = TARGET QTY PER MINUTE TIMES REMAINING MINUTES OF THE DAY
        @actualPlanQty = ((manpower*working_minutes/smv*efficiency)/working_minutes) * @duration
    FROM (
        --1. Get the learning curve
        select code, period = period , efficiency,
            manpower = (select  top 1 manpower from ImappsV2.dbo.m_line_mp
                        where line_code =a.line_code
                        and eff_date<= @newPlanStart order by eff_date desc ),
            working_minutes = 480,
            smv = (select  plansmv from mo_hdr where mono = @mono )
        from view_learning_curve a
        where  line_code = @lineNo  and code = @prodType
        AND period = @periodStart
    ) A2

    if(@efficiency = 0)
    BEGIN
      select code = 'error ' + @mono, description = 'No setup efficiency on line ' + convert(varchar(20),@lineNo) +' with period ' + convert(varchar(20), @periodStart) +
      ' and prod type ' + @prodType, next_mo_plan_start = null
      --goto err
      RETURN
    END

    --PCS = PLAN BALANCE
    --DURATION = now base on the REMAINING BALANCE
    IF(@planBalance <= @actualPlanQty)
    BEGIN
        SET @actualPlanQty = @planBalance
        SET @duration = @planBalance/@minutesTarget
    END

    SET @planBalance = @planBalance - @actualPlanQty
    SET @TotalPlanQty = @TotalPlanQty + @actualPlanQty

  -- TEMPORARY STORE THE PREVIOUS BALANCE
    SET @previosPlanBalance = @planBalance

    --IF PLAN BALANCE > 0. MEANS COMPLETE PLAN = TARGET. BUT WE NEED TO CONSIDER WHAT TIME IT STARTED TO PLAN.
    SET @planFinish =  dateadd(minute, @duration, @newPlanStart ) -- working_minutes = 540, 480 = 8 hours + 60 = 1 hours Break

  --CHECK VALUE HERE
/*     select @periodStart as periodStart, @planBalance as planBalance,@previosPlanBalance as previosPlanBalance, @TotalPlanQty TotalPlanQty,  @planQty planQty, @actualPlanQty as actualPlanQty,
            @duration as duration, @planStartBase planStartBase, @sheduleFinishBase sheduleFinishBase, @newPlanStart as newPlanStart,
            @nextWorkingDate nextWorkingDate, @planFinish as planFinish
*/
    --INSERT THE DAILY TARGET HERE
    INSERT INTO BO_Daily_Target(MONo, BONo, Line, Date, smv, seq, plan_start, plan_finish, Qty, original_daily_target,
                                Trans_Id, Trans_Dt, Mfg_Loc, sbu_id, Mfg_Loc_id, mo_id, Created_By, Time_Created, insert_id )

    SELECT @mono, BONo = @bono, @lineNo, @newPlanStart, @smv, @periodStart, @newPlanStart, @planFinish, @actualPlanQty, @dailyTarget,
      @transId, Trans_Dt = getdate(), @mfgLoc, @sbuId, @mfgLocId, @moId, @createdBy, @timeCreated, @insertId


    SET @nextWorkingDate  = dbo.getNextWorkingDate(@planFinish)

    -- GET NEXT DAY OR CONTINUE
    SET @newPlanStart = case when datepart(hour,@planFinish) >= @MAX_SCHEDULED_TIME_FINISH
      then @nextWorkingDate else  dateadd(minute, 1, @planFinish) end

    SET @periodStart = @periodStart + 1

END

--STEP 2: Summarize the data
--DELETE FROM BO_Hdr where MONo = @mono and BONo = @bono

declare @planStartx datetime
declare @planFinishx datetime
if(@id = 0)
BEGIN
  INSERT INTO BO_Hdr(sbu_id, MONo, MO_Qty, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Plan_Start, Plan_Finish, Prd_Typ, MO_Cus_Del_Dt, Prod_Month, Created_By, Time_Created, Trans_Id, active, total_planned_qty, insert_id)
  SELECT @sbuId, MONo, @moQty, BONo, Mfg_Loc, Line, sum(Qty) as qty, smv, min(plan_start), max(plan_finish), @prodType, @cusDelDt, @prodMonth, @createdBy, @timeCreated, @transId, 1, sum(Qty), @insertId
  FROM BO_Daily_Target
  WHERE MONo = @mono and Trans_Id = @transId
  GROUP BY MONo, BONo, Mfg_Loc, Line,  smv
END
ELSE
BEGIN


  SELECT   @planStartx = min(plan_start), @planFinishx = max(plan_finish)
  FROM BO_Daily_Target
  WHERE MONo = @mono and BONo = @bono and Trans_Id = @transId
  GROUP BY MONo, BONo, Mfg_Loc, Line,  smv

  UPDATE BO_Hdr set Plan_Start = @planStartx, Plan_Finish = @planFinishx, Trans_Id = @TransId, Trans_Dt = getdate(), insert_id = @insertId, re_order_seq = null
  WHERE id = @id
END

--STEP 3: INSERT THE MO+BO LEARNING CURVE
DELETE FROM BO_Learn_Curve where MONo = @mono and BONo = @bono and Line = @lineNo and sbu_id = @sbuId
insert into BO_Learn_Curve(MONo, BONo, Line, Learn_Curve, Period_01, Period_02, Period_03, Period_04, Period_05, Period_06, Period_07, Period_08, Period_09, Period_10,
                            Period_11, Period_12, Period_13, Period_14, Period_15, Period_16, Period_17, Period_18, Period_19, Period_20,
                            Period_21, Period_22, Period_23, Period_24, Period_25, Period_26, Period_27, Period_28, Period_29, Period_30,
                            Created_By, Time_Created, Updated_By, Trans_Id, Trans_Dt, Mfg_Loc, active, sbu_id, insert_id)
select top 1 MONo = @mono, BONo = @bono, Line = @lineNo, Learn_Curve, Period_01, Period_02, Period_03, Period_04, Period_05, Period_06, Period_07, Period_08, Period_09, Period_10,
                            Period_11, Period_12, Period_13, Period_14, Period_15, Period_16, Period_17, Period_18, Period_19, Period_20,
                            Period_21, Period_22, Period_23, Period_24, Period_25, Period_26, Period_27, Period_28, Period_29, Period_30,
                            Created_By, Time_Created, Updated_By, @transId, @timeCreated, @mfgLoc, active, sbu_id, @insertId
from m_line_lc
WHERE line_code = @lineNo and code = @prodType

SELECT 'success ' + @mono as code, 'succesfull planned!' as description, next_mo_plan_start = @newPlanStart
go


CREATE procedure [dbo].[qconn_pt_summary_v3]
(
	  @ptno varchar(13),
    @vap varchar(20) = 'ASSY-PPACK',
    @line varchar(20) = null
)
as
select a.ptno,
    pt_inspected_qty = isnull(good_qty, 0) + isnull(reject_qty, 0) + isnull(repaired_qty, 0) + isnull(unrepairable, 0) + isnull(replaceable_qty, 0),
    pt_good_qty = isnull(good_qty, 0) - isnull(reworked_qty, 0),
    pt_rejected_qty = isnull(reject_qty, 0) + isnull(reworked_qty, 0) + isnull(repaired_qty, 0),
    pt_reworked_qty = isnull(reworked_qty, 0),
    pt_repaired_qty = isnull(repaired_qty, 0),
    pt_unrepairable = isnull(unrepairable, 0),
    mo_inspected_qty = isnull(mo_inspected_qty, 0),
    order_qty = isnull(order_qty, 0),
    a.mono,
    actual_rejected_qty = isnull(reject_qty, 0),
    pt_replaceable_qty = isnull(replaceable_qty, 0)
from
(
 /*   select MONo, PTNo, sum(qty) as good_qty
    from WIPScan (nolock)
    where vap = @vap and svap = 'ISS' and PTNo = @ptno and WorkSection = case when @line is null then WorkSection else @line end
    group by MONo, PTNo
*/
--declare @ptno varchar(20) = '401200056160', @line varchar(20) = NULL
select mono, ptno, sum(good) as good_qty from (
	select mono, a.ptno, sum(1) as good
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	where a.ptno = @ptno and reject = 0 and a.prodline =  case when @line is null then a.prodline else @line end
	group by mono, a.ptno
	union all
	select mono, a.ptno, sum(1) as good
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	inner join endlineqcrfid c on a.ptno  = c.ptno and a.seq = c.seq and c.status = 'PASSED'
	where a.ptno = @ptno and reject = 1 and a.prodline =  case when @line is null then a.prodline else @line end
	group by mono, a.ptno
	union all
	select mono, a.ptno, sum(c.qty) as good
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	inner join endlineqcrfid c on a.ptno  = c.ptno and a.seq = c.seq and c.status = 'CONDPASS' and cpapproveduserid is not NULL
	where a.ptno = @ptno and reject = 1 and a.prodline =  case when @line is null then a.prodline else @line end
	group by mono, a.ptno

	) a
	group by mono, ptno

) a
left outer join
(
    select det.MONo, sum(det.qty) as order_qty
    from MO_Det det (nolock)
    group by det.MONo
) a1 on a.MONo = a1.MONo
left outer join
(
/*    select MONo, sum(qty) as mo_inspected_qty
    from WIPScan (nolock)
    where vap = @vap and svap = 'ISS' and WorkSection = case when @line is null then WorkSection else @line end
    group by MONo
*/
--declare @ptno varchar(20) = '401200056160', @line varchar(20) = NULL
select mono, sum(good) as mo_inspected_qty from (
	select mono,sum(1) as good
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	where  reject = 0 and a.prodline =  case when @line is null then a.prodline else @line end
	group by mono
	union all
	select mono,sum(1) as good
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	inner join endlineqcrfid c on a.ptno  = c.ptno and a.seq = c.seq and c.status = 'PASSED'
	where reject = 1 and a.prodline =  case when @line is null then a.prodline else @line end
	group by mono
	union all
	select mono,sum(c.qty) as good
	from endlineqchdr a
	inner join laying_pt b  on a.ptno = b.ptno
	inner join endlineqcrfid c on a.ptno  = c.ptno and a.seq = c.seq and c.status = 'CONDPASS' and cpapproveduserid is not NULL
	where reject = 1 and a.prodline =  case when @line is null then a.prodline else @line end
	group by mono

	) a
	group by mono
) a2 on a.MONo = a2.MONo

left outer join
(
    select a.PTNo,
        SUM(CASE WHEN b.RejectType = 'REJECT' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as reject_qty,
        SUM(CASE WHEN b.RejectType in ('REWORK', 'REPAIR') and b.[Status] = 'PASSED' THEN 1 ELSE 0 END) as reworked_qty,
        SUM(CASE WHEN b.RejectType = 'REPAIR' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as repaired_qty,
        SUM(CASE WHEN b.RejectType = 'UNREPAIRABLE' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as unrepairable,
        SUM(CASE WHEN b.RejectType = 'REPLACEABLE' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as replaceable_qty
    from EndLineQCHdr a (nolock)
    inner join EndLineQCRFID b (nolock) on a.PTNo = b.PTNo and a.Seq = b.Seq
    where a.Reject = 1 and a.PTNo = @ptno and a.ProdLine = case when @line is null then a.ProdLine else @line end
    group by a.PTNo
) c on a.PTNo = c.PTNo
go

CREATE PROCEDURE usp_rearrange_planning_while_loop
--declare
    @createdBy varchar(20) ='',
    @recId varchar(50) = '1BA6C51F-015E-4EE2-AE14-FAD73A264269',
    @dateFrom date = '03/21/2023',
    @dateTo date = '05/27/2023'
AS
declare
    @mono varchar(11) ='',
    @planStart datetime = null,
    @planQty integer = null ,
    @id BIGINT = 0,
    @isAutoAssignedPlanStart bit = 0,
    @mfgLoc varchar(10) = '',
    @lineNo varchar(4) = ''

declare @minPlanStart DATETIME
declare @count INT = 1
declare @maxCount INT
declare @transId varchar(50) = newid()
declare @date datetime = getDate()

declare @tempDate datetime = convert(date,getdate())
declare @DEFAULT_DATETIME datetime = dateadd(minute,450,@tempDate )

IF OBJECT_ID(N'TEMPDB..#BO_HDR_TMP') IS NOT NULL DROP TABLE #BO_HDR_TMP
SELECT id, MONo, BONo, Mfg_Loc, Line, Plan_Qty, Plan_Start, Trans_Id,
    row_number()over(order by line, re_order_seq) as Seq
INTO  #BO_HDR_TMP
FROM BO_Hdr
WHERE Trans_Id = @recId and re_order_seq is not null
and convert(date,Plan_Start) between  @dateFrom and @dateTo -- PROCESS DATE RANGE

SELECT @maxCount = count(Seq) from #BO_HDR_TMP where Trans_Id = @recId
SELECT @minPlanStart = min(Plan_Start) FROM #BO_HDR_TMP where Trans_Id = @recId

set @minPlanStart =  case when  datepart(hh, @minPlanStart) = 0 then dateadd(minute, 450, convert(datetime,convert(date, @minPlanStart))) else @minPlanStart end -- set to 7:30

BEGIN TRAN REARRANGE_PLANNING_TRANS

--BACKUP BEFORE DELETE
insert into BO_Hdr_OK(mono, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Plan_Start, Plan_Finish, Actual_Start, Actual_Finish, Plant_Color, Prd_Typ, Prd_Typ2, Plant, MO_Qty, MO_Cus_Del_Dt, Completed, Trans_Id, Prod_Month, active, sbu_id, total_planned_qty, total_output_qty, Created_By, Time_Created)
SELECT mono, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Plan_Start, Plan_Finish, Actual_Start, Actual_Finish, Plant_Color, Prd_Typ, Prd_Typ2, Plant, MO_Qty, MO_Cus_Del_Dt, Completed, Trans_Id, Prod_Month, active, sbu_id, total_planned_qty, total_output_qty, @createdBy, @date
FROM BO_Hdr a
WHERE exists (select id from #BO_HDR_TMP b where a.id = b.id)

--DELETE
/*DELETE FROM bo_hdr where id in(select id from #BO_HDR_TMP WHERE Trans_Id = @recId and seq is not null)
DELETE a from BO_Daily_Target a
where EXISTS(select b.id from #BO_HDR_TMP b where a.mono = b.mono and a.Line = b.line and a.BONo = b.bono  and Trans_Id = @recId and seq is not null )*/

IF OBJECT_ID(N'TEMPDB..#TMP_RESULTS') IS NOT NULL DROP TABLE #TMP_RESULTS

CREATE TABLE #TMP_RESULTS
(
	code VARCHAR(20),
	description VARCHAR(100),
  next_mo_plan_start DATETIME,
  id int identity not null
)

declare @nextMoPlanStart datetime

while(@count <= @maxCount)
BEGIN
    SELECT @id = id, @mono = MONo, @mfgLoc = Mfg_Loc, @lineNo = Line, @planQty = Plan_Qty,
        @planStart = case when @count = 1 then @minPlanStart else @nextMoPlanStart  end,
        @isAutoAssignedPlanStart = case when @count = 1 then 0 else 1 end
    from #BO_HDR_TMP
    where Seq = @count


    INSERT INTO #TMP_RESULTS (code, description, next_mo_plan_start)
    exec usp_save_planning_re_arrange @mfgLoc= @mfgLoc,  @mono= @mono, @lineNo = @lineNo, @planStart = @planStart,
                             @planQty= @planQty, @id= @id, @createdBy = @createdBy, @sbuId = 1, @transId = @recId

    print @@error


    SELECT top 1 @nextMoPlanStart = next_mo_plan_start FROM #TMP_RESULTS order by id desc

    /*select mfgLoc= @mfgLoc,  mono= @mono, line_no = @lineNo, planStart = @planStart,
                             planQty= @planQty, id= @id, createdBy = @createdBy, sbuId = 1, transId = @recId, @count as count, @nextMoPlanStart as nextMoPlanStart*/
    SET @count = @count + 1
END

IF(EXISTS(SELECT * FROM #TMP_RESULTS where code like 'error%'))
BEGIN
    GOTO err;
    RETURN
END

SELECT * FROM #TMP_RESULTS
COMMIT TRAN REARRANGE_PLANNING_TRANS
return
err:
SELECT * FROM #TMP_RESULTS
ROLLBACK TRAN REARRANGE_PLANNING_TRANS
go

create procedure [dbo].[usp_wip_report_line_summary_info_v3]
    @dateFrom date = null,
    @dateTo date = null,
    @prodline varchar(20) = 'L01',
    @vap varchar(20) = 'ASSY-PPCK'
as
    set nocount on
    set @dateFrom = ISNULL(@dateFrom, GETDATE())
    set @dateTo = ISNULL(@dateTo, GETDATE())

    declare @dtFrom datetime = @dateFrom, @dtTo datetime = cast(Format(@dateTo,'dd-MMM-yyyy 23:59:59') as datetime)

    select id = (row_number() over (order by trans_date, prodline)), a.*
    from
    (
        SELECT trans_date, line as prodline,
          sum(ISNULL(good_qty,0)) as good,
          sum(ISNULL(reject_qty,0))  as reject,
          sum(ISNULL(reworked_qty,0)) + sum(ISNULL(prev_reworked,0))  as rework,
          sum(ISNULL(prev_reworked,0))  as previousrework,
  --       sum(ISNULL(repaired_qty,0)) as repaired,
          sum(ISNULL(unreapairable_qty,0)) as unrepairable,
          sum(ISNULL(replaceable_qty,0)) as replaceable,

--           sum(ISNULL(reject_qty,0) - ISNULL(reworked_qty,0)) as actual_reject_qty,

          actual_reject_qty = (   SELECT COUNT(1)
                                  FROM EndLineQCRFID r
                                  WHERE r.ProdLine = @prodline and r.TransDt  <= @dtTo
                                    AND r.status = 'REJECT' and (r.RejectType = 'REJECT' or r.RejectType = 'REPAIR' or r.RejectType = 'REPLACEABLE')
                              ),
          sum(ISNULL(good_qty,0) - (ISNULL(reworked_qty,0) + ISNULL(prev_reworked,0))) as rft,
          sum(ISNULL(reject_qty,0) + (ISNULL(good_qty,0) - (ISNULL(reworked_qty,0) + ISNULL(prev_reworked,0)))) as inspectedqty

    from qconn_output_detail_daily_v3 a
        where line = @prodline and trans_date between @dtFrom and @dtTo
    group by trans_date, line
    ) a
go

CREATE FUNCTION [dbo].[fn_getCapacity]
(
    @date date,
		@mono varchar(20),
		@line varchar(20),
    @prodType  varchar(20),
		@period int,
		@manpower int,
		@workingMinutes int,
		@smv numeric(12,4),
		@capacity int
)
RETURNS TABLE

RETURN

		SELECT
			period_start = period,
			daily_target = round(manpower*working_minutes/smv*efficiency,0),
			minute_target = round(round(manpower*working_minutes/smv*efficiency,0)/working_minutes,6),
			working_minutes,
			efficiency,
			capacity = case when @capacity>0 then @capacity else round(manpower*working_minutes/smv*efficiency,0) end,
			smv
			--actualPlanQty = ((manpower*working_minutes/smv*efficiency)/working_minutes) * @duration
		FROM (
			--1. Get the learning curve
			select code, period = period , efficiency,
					manpower = case when @manpower > 0 then @manpower
											else (select  top 1 manpower from ImappsV2.dbo.m_line_mp where line_code =a.line_code and eff_date<= @date  order by eff_date desc )
											end, --@newPlanStart
					working_minutes = case when @workingMinutes > 0 then @workingMinutes else 8*60 end, --default to 8 hours
					smv = case when @smv >0 then @smv else (select  plansmv from mo_hdr where mono = @mono ) end
			from view_learning_curve a
			where  line_code = @line  and code = @prodType
			AND period = case when @period >30 then 30 else @period end
		) A2
go


CREATE procedure [dbo].[usp_wip_report_mo_line_summary_info]
    @dateFrom date = null,
    @dateTo date = null,
    @vap varchar(20) = 'ASSY-PPCK'
as
    set nocount on
    set @dateFrom = ISNULL(@dateFrom, GETDATE())
    set @dateTo = ISNULL(@dateTo, GETDATE())

    declare @dtFrom datetime = @dateFrom,
        @dtTo datetime = cast(Format(@dateTo,'dd-MMM-yyyy 23:59:59') as datetime)

    select Id = (row_number() over (order by WorkSection, mono)), a.* from
        (select distinct
            WorkSection,
            mono,
            deliveryDate = (select min(Dlv_Dt) from MO_Det where mono = a.MONo)
        from WIPScan a (nolock)
        where vap = @vap and ScanDt between @dtFrom and @dtTo
    ) a
go

CREATE FUNCTION dbo.AllocateDailyTarget (@Mono varchar(20), @line varchar(10),  @TotalTarget DECIMAL(18, 2), @InitialPlanStart datetime, @capacityx INT
)
RETURNS @BalanceTable TABLE (
	id INT,
	mono varchar(20),
	line varchar(20),
	bono int,
	prod_type varchar(20),
	total_target INT,
	efficiency numeric(12,4),
	daily_target INT,
	daily_target_base_on_duration INT,
	minute_target numeric(12,6),
	running_value INT,
 	balance INT,
	duration INT,
	plan_start datetime,
	plan_finish datetime,
	scheduled_finish datetime,
	capacity INT,
	next_mo_plan_start datetime,
	smv numeric(12,4)
)
AS

/*
declare @Mono varchar(20), @line varchar(10),  @TotalTarget DECIMAL(18, 2), @InitialPlanStart datetime, @capacityx INT
set @Mono = '15164201003'
set @line = 'L03'
set @TotalTarget = 100
set @InitialPlanStart = '2023-03-06 15:00:00'
set @capacityx = 0

IF OBJECT_ID(N'TEMPDB..#BalanceTable') IS NOT NULL DROP TABLE #BalanceTable
CREATE TABLE #BalanceTable  (
	id INT,
	mono varchar(20),
	line varchar(20),
	bono int,
	prod_type varchar(20),
	total_target INT,
	efficiency numeric(12,4),
	daily_target INT,
	daily_target_base_on_duration INT,
	minute_target numeric(12,6),
	running_value INT,
 	balance INT,
	duration INT,
	plan_start datetime,
	plan_finish datetime,
	scheduled_finish datetime,
	capacity INT,
	next_mo_plan_start datetime,
	smv numeric(12,4)
)*/

BEGIN
-- ALLOCATE DAILY TARGET
	DECLARE @Remaining INT;
	DECLARE @RunningValue INT = 0;
  DECLARE @Counter int = 1;
	DECLARE @DailyTarget int = 0;
	DECLARE @MinuteTarget numeric(12,6) = 0.00
	DECLARE @NewPlanStart datetime = @InitialPlanStart;
	DECLARE @PlanFinish datetime;
	DECLARE @next_mo_plan_start datetime;

	DECLARE @nextWorkingDate datetime;
	DECLARE @scheduledFinish datetime;
	DECLARE @scheduledFinishTime varchar(20);
	DECLARE @dailyTargetBaseOnDuration INT;
	DECLARE @Efficiency numeric(12,4)
	DECLARE @smv numeric(12,4)
	DECLARE @prodType varchar(20) = (select prod_type from mo_hdr where mono = @Mono)
	DECLARE @bono int =   (select max(bono) + 1 from BO_Hdr where MONo = @Mono)
	DECLARE @capacity INT = 0;

	DECLARE @durationFromSched int = 0
	DECLARE @durationFromQty INT;
	DECLARE @duration INT;

	set @capacity = @capacityx
	-- Set the remaining amount to the total target
	SET @Remaining = @TotalTarget;

	-- Loop through the table and deduct daily targets until there is no remaining balance
	WHILE @Remaining > 0
	BEGIN

		--GET DAILY TARGET BASE ON THE CAPACITY PERIOD/@counter
		select @DailyTarget = daily_target, @MinuteTarget = minute_target, @Efficiency = efficiency, @smv = smv
		from dbo.fn_getCapacity(@NewPlanStart, @Mono, @line, @prodType, @Counter, 0, 0, 0, 0)

		select @scheduledFinishTime = convert(datetime, plan_finish_base), @durationFromSched = duration from dbo.fn_getDurationRegHours(@newPlanStart)
		SET @durationFromQty = case when @DailyTarget>@Remaining then  @Remaining/@MinuteTarget else @DailyTarget/@MinuteTarget end
		SET @duration = case when @durationFromSched <@durationFromQty then @durationFromSched else @durationFromQty  end
	 	SET @PlanFinish =  dateadd(minute, @duration, @newPlanStart )
		SET @dailyTargetBaseOnDuration = round(@Duration * @MinuteTarget,0)

		-- Check if the remaining amount is less than the daily target
		IF @Remaining <= 0
		BEGIN
			-- Set the daily target to the remaining amount
			SET @DailyTarget = @DailyTarget + @Remaining;
			SET @RunningValue = @RunningValue + @Remaining;
		END
		SET @Remaining = @Remaining - @dailyTargetBaseOnDuration
		SET @RunningValue = @RunningValue + @dailyTargetBaseOnDuration;

		--GET SCHEDULED FINISH
		SET @scheduledFinish = convert(datetime, convert(varchar(12), @newPlanStart,101) + ' ' +  convert(datetime, @scheduledFinishTime))

		SET @next_mo_plan_start = case when  @planFinish >= @scheduledFinish
      then dbo.getNextWorkingDate(@planFinish) else  dateadd(minute, 1, @planFinish) end

		INSERT INTO @BalanceTable (id, mono, line, bono, prod_type, total_target, daily_target, capacity, smv, efficiency, daily_target_base_on_duration, minute_target, running_value,  balance, duration, plan_start, plan_finish, scheduled_finish, next_mo_plan_start)
		SELECT @Counter, @Mono, @line, isnull(@bono,1), @prodType, @TotalTarget, @DailyTarget, @capacity, @smv, @Efficiency,  @dailyTargetBaseOnDuration, @MinuteTarget, @RunningValue, @Remaining, @Duration, @NewPlanStart, @PlanFinish, @scheduledFinish,  @next_mo_plan_start;

		SET @nextWorkingDate  = dbo.getNextWorkingDate(@planFinish)
		-- GET NEXT DAY OR CONTINUE
	 	SET @newPlanStart = case when  @planFinish >= @scheduledFinish
      then @nextWorkingDate else  dateadd(minute, 1, @planFinish) end

		--select @scheduledFinish as scheduledFinish, @newPlanStart as newPlanStart, convert(datetime, @scheduledFinishTime) as scheduledFinishTime
		--		select @DailyTarget DailyTarget, @MinuteTarget MinuteTarget,  @Duration  as  Duration , @dailyTargetBaseOnDuration, @newPlanStart as newPlanStart
    set @Counter +=1;
	END
	RETURN;
END
go


CREATE procedure [dbo].[qconn_get_qty_left_v3]
    @ptno VARCHAR(20),
    @line VARCHAR(20) = NULL
AS
BEGIN

  DECLARE @mono varchar(20), @total_bundles INTEGER, @line_plan_qty_left INTEGER, @pt_qty_rec_left INTEGER, @mo_plan_qty_left INTEGER;

  SET @mono = (SELECT DISTINCT mono from Laying_PT where PTNo = @ptno)

        SELECT
            /*
            ah.mono, ah.ptno, ah.line,
            line_plan_qty = ISNULL(ah.line_plan_qty,0),     --> qty plan based on BOHDR
            pt_bundle_qty = ah.bundle_qty,                --> plan qty per PT
            mo_plan_qty = (SELECT SUM(PlanQty) from BOHdr (nolock) where MONo = ah.mono),  --> MO plan qty SUM  base on BOHdr
            line_inspected_qty = ISNULL((select SUM(isnull(good_qty, 0) + isnull(reject_qty, 0) + isnull(repaired_qty, 0) + isnull(unrepairable_qty, 0) + isnull(replaceable_qty, 0) )
                                from qconn_output_detail_scan Where ptno = ah.ptno and prodline = ah.Line ),0),
            pt_inspected_qty = ISNULL((select SUM(isnull(good_qty, 0) + isnull(reject_qty, 0) + isnull(repaired_qty, 0) + isnull(unrepairable_qty, 0) + isnull(replaceable_qty, 0) )
                                from qconn_output_detail_scan Where ptno = ah.ptno ),0),
            --> per LIne received vs output
            min_received_line = ISNULL(ds.min_sets,0), --> complete parts received per line
            output_line = ISNULL((select SUM(isnull(good_qty, 0) + isnull(reject_qty, 0) + isnull(repaired_qty, 0) + isnull(unrepairable_qty, 0) + isnull(replaceable_qty, 0) )
                                from qconn_output_detail_scan Where ptno = ah.ptno and prodline = ah.Line ),0),
            -->PER PT = received vs output -> OK for singlePT or Multiple
            min_received_sets = (select SUM(isnull(min_sets, 0) ) from qconn_output_detail_scan where ptno = ah.PTNo ), --> complete parts received per MO / PT
            output_pt =  ISNULL((select SUM(isnull(good_qty, 0) + isnull(reject_qty, 0) + isnull(repaired_qty, 0) + isnull(unrepairable_qty, 0) + isnull(replaceable_qty, 0) )
                                      from qconn_output_detail_scan Where ptno = ah.ptno ),0),

            total_bundles = (SELECT COUNT(DISTINCT ptno) from LayingPT where mono = ah.MONo),
            */
            --> Line base on Plan New Logic
--             @line_plan_qty_left = CASE WHEN (SELECT COUNT(DISTINCT ptno) from LayingPT where mono = ah.MONo) = 1 THEN
            @line_plan_qty_left = CASE WHEN (SELECT multi from qconn_mo_type where mono = ah.MONo) = 0 THEN
                                    ISNULL(ah.line_plan_qty,0) -
                                    ISNULL((select SUM(isnull(good_qty, 0) + /*isnull(reject_qty, 0) + */isnull(repaired_qty, 0) + isnull(unrepairable_qty, 0) + isnull(replaceable_qty, 0) )
                                            from qconn_output_detail_scan_v3 Where ptno = ah.ptno and prodline = ah.Line ),0)
                                 ELSE
                                    ah.bundle_qty -
                                    ISNULL((select SUM(isnull(good_qty, 0) + /*isnull(reject_qty, 0) +*/ isnull(repaired_qty, 0) + isnull(unrepairable_qty, 0) + isnull(replaceable_qty, 0) )
                                              from qconn_output_detail_scan_v3 Where ptno = ah.ptno ),0)
                                 END,


            @pt_qty_rec_left = ISNULL((select SUM(isnull(min_sets, 0) ) from qconn_output_detail_scan_v3 where ptno = ah.PTNo),0) -
                                     ISNULL((select SUM(isnull(good_qty, 0) + /*isnull(reject_qty, 0) +*/ isnull(repaired_qty, 0) + isnull(unrepairable_qty, 0) + isnull(replaceable_qty, 0) )
                                              from qconn_output_detail_scan_v3 Where ptno = ah.ptno ),0),

            @mo_plan_qty_left = CASE WHEN (SELECT COUNT(DISTINCT ptno) from Laying_PT where mono = ah.MONo) = 1 THEN
                                    (SELECT SUM(Plan_Qty) as planqty from BO_Hdr (nolock) where MONo = ah.mono) -
                                    ISNULL((select SUM(isnull(good_qty, 0) + /*isnull(reject_qty, 0) +*/ isnull(repaired_qty, 0) + isnull(unrepairable_qty, 0) + isnull(replaceable_qty, 0) )
                                              from qconn_output_detail_scan_v3 Where ptno = ah.ptno ),0)
                               ELSE --ptlaying qty
                                    ah.bundle_qty -
                                     ISNULL((select SUM(isnull(good_qty, 0) + /*isnull(reject_qty, 0) +*/ isnull(repaired_qty, 0) + isnull(unrepairable_qty, 0) + isnull(replaceable_qty, 0) )
                                              from qconn_output_detail_scan_v3 Where ptno = ah.ptno ),0)
                               END
        FROM (
              Select MAX(h.inBO) as inBO, MAX(h.PlanQty) as line_plan_qty, h.Line, a.PTNo, a.MONo, a.LayNo, a.Qty as bundle_qty
              FROM Laying_PT a (nolock)
              INNER JOIN (
                          SELECT mono, Line, 1 as inBO, SUM(Plan_Qty) as PlanQty from BO_Hdr (nolock) where mono = @mono GROUP BY mono, line
                          UNION
                          SELECT distinct mono, prodline, null, null from qconn_output_detail_scan_v3 (nolock) where mono = @mono
                         ) h ON h.MONo = a.MOno
              INNER JOIN qconn_output_detail_info_v3 c (nolock) ON c.MONo = a.MOno
              WHERE a.MONo = @mono
              GROUP BY a.MONo, a.Time_Created , a.LayNo, a.PTNo, a.Bundle_No, a.Color, a.Size, a.Qty, h.Line,
                  C.IONO, c.customer, c.pono, c.StyleNo, c.product , c.order_qty, c.updatedDt
             ) ah
        LEFT JOIN qconn_output_detail_scan_v3 ds (nolock) ON ds.MOno = ah.MONo AND ds.PTno = ah.PTNo AND ah.LayNo = ds.layNo and ah.Line = ds.prodline
        WHERE ah.ptno = @ptno and ah.Line = @line

  -- SELECT @line_plan_qty_left, @pt_qty_rec_left, @mo_plan_qty_left, (SELECT MIN(x) FROM (VALUES (@line_plan_qty_left),(@pt_qty_rec_left),(@mo_plan_qty_left)) AS value(x))
  --SELECT (SELECT MIN(x) FROM (VALUES (@line_plan_qty_left),(@pt_qty_rec_left),(@mo_plan_qty_left)) AS value(x));
  Select 1
END
go

CREATE function fn_getDurationRegHours(
	@planStart datetime
)
RETURNS TABLE
RETURN
select plan_start_base = format( convert(datetime,@planStart),'HH:mm') , plan_finish_base ,  duration = datediff(minute, format( convert(datetime,@planStart),'HH:mm'), plan_finish_base )
FROM (
	select
			plan_start_base = format(min(date_from),'HH:mm'),
			plan_finish_base = format(min(dateadd(hour, 8, date_from)),'HH:mm')
	from m_calendar_week_day_det
	where code = 'Monday'
) A
go


CREATE procedure [dbo].[qconn_endline_scan]
(
	@assy		varchar(20),
	@prodline	varchar(20),
	@ptno		varchar(20),
	@username	nvarchar(50),
	@scandate	datetime,
	@reject	bit = 0
)
as
begin

    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
    set nocount on
    declare @seq int;
    declare @mono varchar(20);

    DECLARE @SCNQTY INT, @RejectQTY INT, @SVAP VARCHAR(20) = 'ISS', @Qty INT = 1
	DECLARE @PrevVAP VARCHAR(20), @PrevSVAP VARCHAR(20), @PrevQty INT
    declare @PlanQty int = 0, @multi bit = 0

	--select @assy = settings from wip_settings  where code = '@AssyPack'
	update qconn_tag set status = 'AVAILABLE' where code = 'CONDPASS'
	--select '1'

    /* Get MONo By PTNo */
    select @mono = mono from Laying_PT (NOLOCK) where PTNo = @ptno
/*
	-- begin Check last checkpoint date added 11/18/2022
	declare @LastCheckpointDt datetime, @VAP varchar(30) = 'ASSY-PPCK'
	SELECT @LastCheckpointDt = ScanDt,@PrevVAP = VAP, @PrevSVAP = SVAP FROM WIPScan WHERE MONo = @MONo AND PTNo = @PTNo
	AND VAP+SVAP IN
	(
	SELECT TOP 1 VAP+SVAP FROM MOVAPSVAP WHERE MONo = @MONo AND Seq2 <
	(
		SELECT Seq2 FROM MOVAPSVAP WHERE MONo = @MONo AND VAP = @VAP AND SVAP = @SVAP --and active = 1
	) and active = 1
		ORDER BY Seq2 DESC
	) order by scandt desc

	if(CAST(@scandate AS date) < CAST(@LastCheckpointDt AS date))
		begin
			Select 'Invalid, Scan date should not be earlier than previous checkpoint dated ' + CONVERT(VARCHAR(10),@LastCheckpointDt,101) + ' ' , 1 AS ERROR
			return
		end
	-- end Check last checkpoint date added 11/16/2022


    /* Get Previous VAP */
    SELECT TOP 1
    @PrevVAP = VAP,
    @PrevSVAP= SVAP
    FROM MOVAPSVAP (NOLOCK) WHERE MONo = @MONO AND GVAP IN
    (
        SELECT GVAP FROM MOVAPSVAP (NOLOCK) WHERE VAP = @assy AND SVAP = @SVAP AND MONo = @MONO
    )
    AND Seq2 < (SELECT Seq2 FROM MOVAPSVAP (NOLOCK) WHERE VAP = @assy AND SVAP = @SVAP AND MONo = @MONO)
    AND ACTIVE = 1
    AND SVAP <> @SVAP
    ORDER BY Seq2 DESC

    IF (@PrevVAP IS NULL OR @PrevSVAP IS NULL)
    BEGIN
        SELECT 'No active VAP, SVAP. Please check OB.', 1 As Error
        RETURN
    END
*/
	

    /* Get Received Qty */
    SELECT
    @PrevQty = ISNULL(SUM(QTY), 0)
    FROM WIPSCAN (NOLOCK) WHERE MONO = @MONO
--    AND VAP = @PrevVAP AND SVAP = @PrevSVAP
    AND PTNO = @PTNO

    /* is MO single bundled? */
    select @multi = isnull(multi, 0) from qconn_mo_type (NOLOCK) where mono = @mono
    if (@multi = 0)
    begin
        select
        @PlanQty = isnull(sum(Plan_Qty), 0)
        from BO_Hdr (NOLOCK)
        where Line = @prodline
        and MONo = @mono

        if (@PlanQty < @PrevQty)
            set @PrevQty = @PlanQty

    end
	--select '2'
    /* Get Scanned Qty */
    SELECT
    @SCNQTY = count(PTNo)
    FROM
    EndLineQCHdr (NOLOCK)
    --WHERE (@multi = 0 and ProdLine = @prodline) and PTNo = @PTNO
	WHERE ProdLine = @prodline and PTNo = @PTNO


	--begin get line plan qty per mo/line added by donel 03/30/2023
	declare @lineplanqty int
	select @lineplanqty = isnull(sum(Plan_Qty), 0)
			from BO_Hdr (NOLOCK)
			where MONo = @mono and Line = @prodline
	--
	if (coalesce(@scnqty,0) + @qty) > coalesce(@lineplanqty, 0) 
		begin
			select 'Scan Qty ' + CONVERT(VARCHAR(10), @scnqty) + ' exceeds the Plan Qty ' + CONVERT(VARCHAR(10), @lineplanqty) + ' [New] '  as error
			return
		end      
	--end get line plan qty per mo/line added by donel 03/30/2023

	
	--select '3'
    /* Get Reject Qty */
    SELECT
    @RejectQTY = count(1)
    FROM
    EndLineQCHdr a (NOLOCK) inner join EndLineQCRFID (NOLOCK) b on a.ProdLine = b.ProdLine and a.Seq = b.Seq
    WHERE a.ProdLine = @prodline and a.PTNo = @PTNO and a.Reject = 1 and b.Status in ('REJECT','CONDPASS')

	--check scan qty vs. pt qty
	declare @ptqty int
	select @ptqty = sum(qty) from laying_pt where ptno = @ptno
	if (coalesce(@PrevQty,0) + @RejectQTY + @qty ) > coalesce(@ptqty,0)
		begin 
			select 'Scan Qty ' + CONVERT(VARCHAR(10), @PrevQty + @RejectQTY) + ' exceeds the PT Qty ' + CONVERT(VARCHAR(10), @ptqty) + ' [' + @ptno + '] '  as error
			return
		end
	--select '4'
    /* Check Balance */
 /*   if (ISNULL(@PREVQTY,0) < (ISNULL(@SCNQTY,0) + ISNULL(@QTY,0) - ISNULL(@RejectQTY, 0)))
    begin
	select '5-1',@PrevSVAP, @PrevQty, @SCNQTY
        select 'More than ' + @PrevSVAP + ' qty ' + CONVERT(VARCHAR(10), @PrevQty) + '- available qty: '
            + CONVERT(VARCHAR(10),(ISNULL(@PrevQty,0) - ISNULL(@SCNQTY,0))), 1 as ERROR
        return
    end
    else
    begin
        /* Start - original */
		select '5'
  */      select @seq = isnull(max(seq), 0) + 1 from EndLineQCHdr (NOLOCK) where ptno = @ptno;
	--	select '6'
    --end

	
    begin try
        begin transaction;

            insert into EndLineQCHdr (ptno, seq, prodline, reject, createdby, createddt, updatedby, updateddt)
            values (@ptno, @seq, @prodline, @reject, @username, @scandate, @username, @scandate);

        commit transaction;

        if (@reject = 0)
            begin
                --EXEC [dbo].[prdScanWIPSP_MOD2_new] @assy, 'ISS', '', @ptno, @username, @scandate, @username, 'D', @prodline, @Qty, @reject, @seq
				--exec usp_wip_pre_process_report @reportName =  'Process Shipment Monitoring v2', @moNo = @mono
				select 'Successful', @seq as Error

            end
        else
            begin
                select 'Successful', @seq as Error
            end

        /* End - original */
    end try
    begin catch
        rollback transaction;
    end catch

    select error_message();
end
go


CREATE procedure [dbo].[qconn_process_output_summary_v3]
    @ptno varchar(20) = NULL,
    @MONo varchar(20) = NULL,
    @processDate DATETIME = NULL,
    @isList BIT = 0
AS
-- SET NOCOUNT ON
    DECLARE @vap varchar(20) = '-' --GET in the wip_settings Table
    DECLARE @dateStamp DATETIME = getdate();
    DECLARE @dateDone DATETIME = getdate();
    DECLARE @processPT BIT = 0;
    DECLARE @isMulti BIT = 0;
    DECLARE @v3MOinfo TABLE (mono varchar(50), IONo varchar(50), customer varchar(50), product varchar(100), StyleNo varchar(100),
                            Color varchar(50), Size varchar(50) , ProdType varchar(50), order_qty INT, UpdatedDt DATETIME, pono varchar(50), multi BIT DEFAULT 0, CustStyle varchar(50) )
    DECLARE @v3MOScan TABLE (mono varchar(50), PTNo varchar(50), LayNo varchar(50), ProdLine varchar(50), UpdatedDt DATETIME)


    SET @processDate = ISNULL(@processDate,@dateDone)
    SET @vap = (SELECT settings FROM wip_settings (nolock) where code = '@AssyPack')

    IF @MONo IS NULL BEGIN
        SET @processPT = 1
        SET @MONo = (SELECT MONo from Laying_PT (nolock) where PTNo = @PTNo );
    END

--    exec qconn_boHdr_plan_update @MONo

    INSERT INTO @v3MOinfo (mono, IONo, customer, product, StyleNo, Color, Size, ProdType, order_qty, UpdatedDt, pono, CustStyle)
    SELECT DISTINCT hdr.MONo, concat(hdr.IONo, '-', hdr.split_no) as IONo, det.Sold_To_Cust as customer, prod.Description as product, hdr.Style_No, det.Color, det.Size, hdr.Prod_Type,
                    sum(ISNULL(det.qty,0)), max(ISNULL(det.time_Updated,det.time_Created)) as UpdatedDt, max(distinct CPO_No) as pono, max(det.Cust_Style) as CustStyle
    FROM MO_Det det (nolock)
        inner join MO_Hdr hdr (nolock) on det.MONo = hdr.MONo and det.Style_No = hdr.Style_No
        inner join m_Prod_Type prod (nolock) on prod.code = hdr.Prod_Type
    WHERE det.MONo = @mono AND hdr.MONo = @mono --and det.Qty > 0
    GROUP BY hdr.MONo, concat(hdr.IONo, '-', hdr.split_no), det.Sold_To_Cust, prod.Description, hdr.Style_No, det.Color, det.Size, hdr.Prod_Type
--     HAVING sum(ISNULL(det.qty,0)) > 0



    PRINT '--> delete info missing from source'
        DELETE FROM t --SELECT s.MONo, s.IONo, s.customer, s.product, s.styleno, s.color, s.size
        FROM qconn_output_detail_info_v3 t (nolock)
        LEFT JOIN @v3MOinfo s ON t.MONo = s.Mono  AND t.Color = s.Color AND t.StyleNo = s.StyleNo
        WHERE t.MOno = @mono AND s.MONo IS NULL


    PRINT '--> will get primary MOHdr and MODet information'
        UPDATE t SET
                t.customer = s.customer,
                t.IONo = s.IONo,
                t.Size = s.Size,
                t.order_qty = s.order_qty,
                t.updatedDt = s.UpdatedDt,
                t.date_updated = @dateStamp,
                t.pono = s.pono
        FROM qconn_output_detail_info_v3 t
            INNER JOIN @v3MOinfo s ON t.MONo = s.Mono  AND t.Color = s.Color AND t.StyleNo = s.StyleNo
        WHERE t.mono = @mono

        INSERT INTO qconn_output_detail_info_v3 (MONo, IONo, customer, product, styleno, color, size, order_qty, updatedDt, date_updated, custStyle)
        SELECT s.MONo, s.IONo, s.customer, s.product, s.styleno, s.color, s.size, s.order_qty, s.updatedDt, @dateStamp, s.CustStyle
        FROM @v3MOinfo s
        LEFT JOIN qconn_output_detail_info_v3 t(nolock) ON t.MONo = s.Mono  AND t.Color = s.Color AND t.StyleNo = s.StyleNo AND t.mono = @mono
        WHERE s.mono = @mono AND t.mono IS NULL

        UPDATE t SET  t.multi = isnull(s.multi,0)
        FROM qconn_output_detail_info_v3 t
            -- remarks by donel 8/31/2022 INNER JOIN (
					left  JOIN (
                    select a.mono, CAST(1 as BIT) as multi
                    from Laying_PT a(nolock)
                    inner join Laying_Hdr b(nolock) on a.MONo = b.MONo and a.LayNo = b.LayNo
                    where b.Status = 'G' and a.MONo = @mono and b.MONo = @mono --AND b.Replacement = 0
                    group by a.mono
                    HAVING count(ptno) > 1
            ) s ON t.MONo = s.Mono
        WHERE t.mono = @mono

        UPDATE t SET  t.multi = isnull(s.multi,0)
        FROM @v3MOinfo t
            INNER JOIN qconn_output_detail_info_v3(nolock) s ON t.MONo = s.Mono
        WHERE t.mono = @mono

        SELECT @isMulti = isnull(multi,0) from qconn_output_detail_info_v3(nolock) where mono = @mono

    PRINT '--> Will process MOHdr and MODet = the cPoNo'
        UPDATE t SET pono = s.pono -- SELECT t.*
        FROM qconn_output_detail_info_v3 t
                INNER JOIN @v3MOinfo s ON t.MONo = s.Mono AND t.Color = s.Color AND t.StyleNo = s.StyleNo
        WHERE t.mono = @mono and s.mono = @MONo

    PRINT '--> dump daaily data'
        EXEC qconn_process_output_summary_daily_v3 @mono = @mono


        PRINT '--> lines'
        INSERT INTO @v3MOScan (mono, PTNo, LayNo, ProdLine)
        SELECT DISTINCT a.mono, a.ptno, a.layNo, a.line as ProdLine
        from qconn_output_detail_daily_v3 a(nolock)
        where a.mono = @mono AND @isMulti = 0
        UNION
        SELECT DISTINCT l.MONo, l.PTNo, l.LayNo, (w.line) as ProdLine
        FROM Laying_PT l (nolock)
            INNER JOIN qconn_output_detail_info_v3 i (nolock) ON l.MONo = i.MOno
            INNER JOIN Laying_Hdr b (nolock) on l.MONo = b.MONo and l.LayNo = b.LayNo
            INNER JOIN BO_Hdr w (nolock) ON l.MONo = w.MONo
        WHERE  b.Status = 'G' AND l.mono = @mono --AND @isMulti = 0
        UNION
        SELECT f.MONo, f.PTNo, f.LayNo, w.WorkSection as ProdLine
        FROM WIPScan w
        INNER JOIN (
                    SELECT l.MONo, l.PTNo, l.LayNo, MIN(w.ScanDt) as ScanDt
                    FROM Laying_PT l (nolock)
                        INNER JOIN qconn_output_detail_info_v3 t (nolock) ON l.MONo = t.MOno
                        INNER JOIN WIPScan w (nolock) ON l.MONo = w.MONo AND l.PTNo = w.PTNo AND l.LayNo = w.LayNo
                        INNER JOIN Laying_Hdr b (nolock) on l.MONo = b.MONo and l.LayNo = b.LayNo
                    WHERE b.Status = 'G' AND ISNULL(w.WorkSection,'') <> '' AND w.SVAP = 'RCV'  and w.VAP like '%-ASSY'
                        AND l.mono = @mono AND w.mono = @mono AND b.MONo = @mono AND @isMulti = 1
                    GROUP BY l.MONo, l.PTNo, l.LayNo
                ) f ON w.MONo = f.MONo AND w.ptno = f.PTNo AND f.LayNo = w.LayNo AND f.ScanDt = w.ScanDt
        WHERE w.mono = @mono
            AND ISNULL(w.WorkSection,'') <> ''


        UPDATE a SET UpdatedDt = b.ScanDt
        FROM @v3MOScan a
            INNER JOIN ( SELECT ptno, WorkSection, MAX(ScanDt) as ScanDt FROM wipscan(nolock) where mono = @mono AND ISNULL(WorkSection,'') <> ''  GROUP BY ptno,WorkSection ) b
            ON a.ptno = b.ptno AND a.ProdLine = b.WorkSection
        WHERE a.mono = @MONo

    PRINT '-- delete scan on missing from source'
        DELETE FROM t --SELECT s.MONo, s.PTNo, s.LayNo, s.ProdLine
        FROM qconn_output_detail_scan_v3 t
            LEFT JOIN @v3MOScan s ON t.MONo = s.Mono  AND t.ptno = s.ptno AND t.layNo = s.layNo AND t.ProdLine = s.ProdLine
        WHERE t.mono = @mono AND s.mono IS NULL

        UPDATE t SET
                prodline = s.prodline,
                LayNo = s.LayNo,
                last_scanDt = CASE WHEN last_scanDt >= s.UpdatedDt THEN last_scanDt ELSE s.UpdatedDt END,
                date_updated = @dateStamp,
                good_qty = 0,
                reject_qty = 0,
                reworked_qty = 0,
                repaired_qty = 0,
                unrepairable_qty = 0,
                replaceable_qty = 0,
                assy_status = 0,
                min_sets = 0,
                assy_ppack = 0,
                line_plan_qty = 0,
                pt_line_inspected = 0,
                pt_line_output = 0,
                pt_line_sets = 0,
                pt_inspected = 0,
                pt_output = 0
        FROM qconn_output_detail_scan_v3 t
            INNER JOIN @v3MOScan s ON t.MONo = s.Mono AND t.PTNo = s.PTNo  AND t.prodline = s.ProdLine
        WHERE t.mono = @mono

        INSERT INTO qconn_output_detail_scan_v3 (MONo, PTNo,  Layno, ProdLine, last_scanDt, date_updated)
        SELECT s.MONo, s.PTNo, s.LayNo, s.ProdLine, s.UpdatedDt, @dateStamp
        FROM @v3MOScan s
            LEFT JOIN qconn_output_detail_scan_v3 t(nolock) ON t.MONo = s.Mono AND t.PTNo = s.PTNo  AND t.prodline = s.ProdLine AND t.mono = @mono
        WHERE  t.mono IS NULL

		-- added by Donel 7/28/2023 - display only ptno that were received from prev checkpoint
		delete a 
		from qconn_output_detail_scan_v3 a
		left outer join (select distinct ptno, mono,work_section from wip_scan) b on a.mono = b.mono and a.ptno = b.ptno and b.work_section = a.prodline
		where a.mono = @mono  and b.ptno is NULL
		

    PRINT '--> THis will query up all the good quantity'
       UPDATE t SET good_qty = ISNULL(s.good_qty,0), last_scanDt = s.last_scanDt, date_updated = @dateStamp
        -- SELECT t.*
        FROM qconn_output_detail_scan_v3 t
        INNER JOIN (    SELECT a.mono, a.ptno, a.layNo, a.line as prodline, SUM(ISNULL(a.good_qty,0)) as good_qty, MAX(a.UpdatedDt) as last_scanDt
                        FROM qconn_output_detail_daily_v3 a (nolock)
                            INNER JOIN @v3MOinfo i   ON a.MONo = i.MOno
                        WHERE a.mono = @mono AND i.multi = 0 AND a.MOno = @mono
                        GROUP BY a.mono, a.ptno, a.layNo, a.line
                        UNION
                        SELECT a.mono, a.ptno, a.layNo, b.prodline, SUM(ISNULL(a.good_qty,0)) as good_qty, MAX(a.UpdatedDt) as last_scanDt
                        FROM qconn_output_detail_daily_v3 a (nolock)
                            INNER JOIN @v3MOinfo i   ON a.MONo = i.MOno
                            INNER JOIN qconn_output_detail_scan_v3 b(nolock) ON b.MOno = a.mono AND a.ptno = b.PTno --AND a.line = b.prodline
                        WHERE a.mono = @mono AND i.multi = 1  AND b.MOno = @mono
                        GROUP BY a.mono, a.ptno, a.layNo, b.prodline
            ) s ON t.MONo = s.Mono AND t.PTNo = s.PTNo and t.prodline = s.ProdLine
        WHERE t.mono = @mono

        PRINT '--> output scan from endline Hdr'

    PRINT '--> output scan from endline Hdr'
            UPDATE t SET
                    reject_qty = s.reject_qty,
                    reworked_qty = ISNULL(s.reworked_qty,0) + ISNULL(s.prev_reworked,0),
                    repaired_qty = s.repaired_qty,
                    unrepairable_qty = s.unrepairable_qty,
                    replaceable_qty = s.replaceable_qty,
                    last_scanDt = s.tDate,
                    date_updated = @dateStamp
					--,secondquality_qty = s.secondquality_qty
            --SELECT t.*
            FROM qconn_output_detail_scan_v3 t
                INNER JOIN (
                            SELECT a.mono, a.ptno, a.line as ProdLine, SUM(a.good_qty) as good_qty, SUM(a.reject_qty) - (ISNULL(SUM(a.reworked_qty),0) + /*ISNULL(SUM(a.repaired_qty),0) +*/ ISNULL(SUM(a.prev_reworked),0)) as reject_qty,
                                   ISNULL(SUM(a.reworked_qty),0) as reworked_qty, ISNULL(SUM(a.repaired_qty),0) as repaired_qty,
                                   ISNULL(SUM(a.unreapairable_qty),0) as unrepairable_qty, ISNULL(SUM(a.replaceable_qty),0) as replaceable_qty, ISNULL(SUM(a.prev_reworked),0) as prev_reworked,
                                   MAX( a.trans_date ) as tDate
								   --,ISNULL(SUM(a.secondquality_qty),0) as secondquality_qty
                            FROM qconn_output_detail_daily_v3 a (NOLOCK)
                                INNER JOIN @v3MOinfo i ON a.MONo = i.MOno
                            WHERE a.mono = @mono
                                AND ISNULL(i.multi,0) = 0
                            GROUP BY a.mono, a.ptno, line
                            UNION
                            SELECT  a.mono, a.ptno, s.prodline, SUM(a.good_qty) as good_qty, SUM(a.reject_qty) - (ISNULL(SUM(a.reworked_qty),0) + /*ISNULL(SUM(a.repaired_qty),0) +*/ ISNULL(SUM(a.prev_reworked),0)) as reject_qty,
                                   ISNULL(SUM(a.reworked_qty),0) as reworked_qty, ISNULL(SUM(a.repaired_qty),0) as repaired_qty,
                                   ISNULL(SUM(a.unreapairable_qty),0) as unreapairable_qty, ISNULL(SUM(a.replaceable_qty),0) as replaceable_qty, ISNULL(SUM(a.prev_reworked),0) as prev_reworked,
                                   MAX( a.trans_date ) as tDate
								   --,ISNULL(SUM(a.secondquality_qty),0) as secondquality_qty
                            FROM qconn_output_detail_daily_v3 a (NOLOCK)
                                INNER JOIN @v3MOinfo i ON a.MONo = i.MOno
                                INNER JOIN qconn_output_detail_scan_v3 s (nolock) ON s.MOno = a.MONo AND s.PTno = a.PTNo
                            WHERE a.mono = @mono
                                AND ISNULL(i.multi,0) = 1
                            GROUP BY a.mono, a.ptno, prodline
                    /*
                        SELECT l.mono, l.PTNo, a.ProdLine, MAX(COALESCE(b.FixedDt , b.TransDt, @dateStamp)) as tDate,
                            SUM(CASE WHEN b.RejectType = 'REJECT' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as reject_qty,
                            SUM(CASE WHEN b.RejectType in ('REWORK', 'REPAIR') and b.[Status] = 'PASSED' THEN 1 ELSE 0 END) as reworked_qty,
                            SUM(CASE WHEN b.RejectType = 'REPAIR' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as repaired_qty,
                            SUM(CASE WHEN b.RejectType = 'UNREPAIRABLE' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as unrepairable_qty,
                            SUM(CASE WHEN b.RejectType = 'REPLACEABLE' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as replaceable_qty
                        FROM LayingPT l
                            INNER JOIN qconn_output_detail_info_v3 t (nolock) ON l.MONo = t.MOno AND ISNULL(t.multi,0) = 0
                            INNER JOIN EndLineQCHdr a (nolock) ON l.PTNo = a.PTNo
                            LEFT JOIN EndLineQCRFID b (nolock) on a.PTNo = b.PTNo and a.Seq = b.Seq
                        WHERE a.Reject = 1 AND l.mono = @mono
                            AND a.PTNo in (SELECT DISTINCT PTNo FROM LayingPT WHERE MONo = '13376101001')
                        GROUP BY l.mono, l.PTNo, a.ProdLine
                        UNION
                        SELECT l.mono, l.PTNo, s.ProdLine, MAX(COALESCE(b.FixedDt , b.TransDt, @dateStamp)) as tDate,
                            SUM(CASE WHEN b.RejectType = 'REJECT' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as reject_qty,
                            SUM(CASE WHEN b.RejectType in ('REWORK', 'REPAIR') and b.[Status] = 'PASSED' THEN 1 ELSE 0 END) as reworked_qty,
                            SUM(CASE WHEN b.RejectType = 'REPAIR' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as repaired_qty,
                            SUM(CASE WHEN b.RejectType = 'UNREPAIRABLE' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as unrepairable_qty,
                            SUM(CASE WHEN b.RejectType = 'REPLACEABLE' and b.[Status] = 'REJECT' THEN 1 ELSE 0 END) as replaceable_qty
                        FROM LayingPT l
                            INNER JOIN qconn_output_detail_info_v3 t (nolock) ON l.MONo = t.MOno AND ISNULL(t.multi,0) = 1
                            INNER JOIN qconn_output_detail_scan_v3 s (nolock) ON s.MOno = l.MONo AND s.PTno = l.PTNo
                            INNER JOIN EndLineQCHdr a (nolock) ON l.PTNo = a.PTNo
                            LEFT JOIN EndLineQCRFID b (nolock) on a.PTNo = b.PTNo and a.Seq = b.Seq
                        WHERE a.Reject = 1 AND l.mono = @mono
                            AND a.PTNo in (SELECT DISTINCT PTNo FROM LayingPT WHERE MONo = '13376101001')
                        GROUP BY l.mono, l.PTNo, s.ProdLine */
                    ) s ON t.PTNo = s.PTNo and t.mono = s.mono and t.prodline = s.ProdLine
            WHERE t.mono = @mono

        PRINT '--> output scan from endline Hdr'
        UPDATE t SET
                assy_status = s.status,
                min_sets = s.min_sets,
                assy_ppack = s.assy_ppack,
                bundle_no = s.Bundle_No,
                date_updated = @dateStamp
        --SELECT t.*
        FROM qconn_output_detail_scan_V3 t
            INNER JOIN (
                        SELECT Mono, PTNo, status, min_sets, assy_ppack, bundle_No
                        FROM
                            (
                            SELECT DISTINCT Mono, PTNo, TargetQty, ASSY_PPACK, bundle_No,
                                min_sets = min(CASE WHEN ASSY_RECEIVE > 0 THEN ASSY_RECEIVE ELSE 0 END) over (partition by MONo, PTNo),
                                STATUS = CASE WHEN TargetQty = min(CASE WHEN ASSY_RECEIVE > 0 THEN ASSY_RECEIVE ELSE 0 END) over (partition by MONo, PTNo) THEN 'Completed'
                                        WHEN TargetQty  = min(CASE WHEN ASSY_RECEIVE > 0 THEN ASSY_RECEIVE ELSE 0 END) over (partition by MONo, PTNo) AND ASSY_PPACK = 0 THEN 'Pending'
                                        WHEN TargetQty > ASSY_PPACK and ASSY_PPACK > 0 THEN 'In Progress'
                                        ELSE 'No Sets' END
                            from (
                                SELECT DISTINCT b.MONo,  b.PTNo, s.prodline, TargetQty =  b.Qty, b.bundle_No,
                                    ASSY_RECEIVE = isnull( (select sum(w.qty) from WIP_Scan(nolock) w where w.mono = @mono AND w.MONo = b.MONo and w.PTNo = b.PTNo and w.VAP = v.VAP  and w.SVAP = 'RCV'),0),
                                    ASSY_PPACK = isnull( (select sum(qty) from WIPScan(nolock) w where w.mono = @mono AND w.MONo = b.MONo and w.PTNo = b.PTNo and w.VAP = @vap  and w.SVAP = 'ISS'),0)
                                FROM MO_VAP_SVAP v (nolock)
                                    inner join Laying_PT b (nolock) on b.MONo = v.MONo
                                    inner join Laying_Hdr c (nolock) on c.MONo = v.MONo and c.LayNo = b.LayNo
                                    INNER JOIN qconn_output_detail_info_v3 t (nolock) ON b.MONo = t.MOno AND ISNULL(t.multi,0) = 0
                                    INNER JOIN qconn_output_detail_scan_v3 s (nolock) ON s.MOno = b.MONo AND s.PTno = b.PTNo AND s.mono = @mono
                                where c.Status = 'G' and v.VAP like '%ASSY' and v.SVAP = 'RCV' and v.Active = 1 AND b.mono = @mono
                                UNION
                                SELECT b.MONo,  b.PTNo, s.prodline, TargetQty =  b.Qty, b.bundle_No,
                                    ASSY_RECEIVE = isnull( (select sum(w.qty) from WIP_Scan(nolock) w where w.MONo = b.MONo and w.PTNo = b.PTNo and w.VAP = v.VAP  and w.SVAP = 'RCV'),0),
                                    ASSY_PPACK = isnull( (select sum(qty) from WIPScan(nolock) w where w.MONo = b.MONo and w.PTNo = b.PTNo and w.VAP = @vap  and w.SVAP = 'ISS'),0)
                                FROM MO_VAP_SVAP v (nolock)
                                    inner join Laying_PT b (nolock) on b.MONo = v.MONo
                                    inner join Laying_Hdr c (nolock) on c.MONo = v.MONo and c.LayNo = b.LayNo
                                    INNER JOIN qconn_output_detail_info_v3 t (nolock) ON b.MONo = t.MOno AND ISNULL(t.multi,0) = 1
                                    INNER JOIN qconn_output_detail_scan_v3 s (nolock) ON s.MOno = b.MONo AND s.PTno = b.PTNo  AND s.mono = @mono
                                where c.Status = 'G' and v.VAP like '%ASSY' and v.SVAP = 'RCV' and v.Active = 1 AND b.mono = @mono
                                ) A
                            ) a
                ) s ON t.PTNo = s.PTNo
        WHERE t.mono = @mono

    --> SUMMARY PROCESS Starts here...

    -- qconn_mo_type
        UPDATE t SET multi = s.multi
        FROM qconn_mo_type t
            INNER JOIN @v3MOinfo s ON t.mono = s.mono
        WHERE t.mono = @mono

        INSERT INTO qconn_mo_type (mono, multi)
        SELECT DISTINCT s.mono, s.multi
        FROM @v3MOinfo s
            LEFT JOIN  qconn_mo_type t(nolock)  ON t.mono = s.mono AND t.mono = @mono
        WHERE s.mono = @mono AND t.mono IS NULL

    PRINT '--> Plan Qty base on BO'
        UPDATE s SET inBO = 1, line_plan_qty = ISNULL(p.PlanQty,0),
                    tag_pt_line_planned = CASE WHEN (ISNULL(p.PlanQty,0) > 0) THEN 1 ELSE 0 END
        FROM qconn_output_detail_scan_v3 s
            INNER JOIN (SELECT mono, Line, SUM(Plan_Qty) as PlanQty
                        FROM BO_Hdr (nolock) where MONo = @MONo GROUP BY mono, Line
                ) p ON p.MONo = s.MONo AND p.Line = s.prodline
        WHERE s.MONo = @MONo AND (ISNULL(line_plan_qty,0) <> ISNULL(p.PlanQty,0) OR ISNULL(inBO,0) <> 1 )

        UPDATE s SET mo_plan_qty = p.mo_plan_qty,
                 bundle_count = (SELECT COUNT(DISTINCT ptno) from laying_PT where mono = @MONo)
        FROM qconn_output_detail_info_v3 s
            INNER JOIN (SELECT MONo, Mo_Qty, sum(Plan_Qty)  as mo_plan_qty  FROM BO_Hdr where MONo = @MONo GROUP BY mono,Mo_Qty) p ON p.MONo = s.MONo
        WHERE s.MONo = @MONo

        --> TODO: May have issue later as 2 reeturnd data or something
        UPDATE a SET pt_inspected = b.pt_inspected_qty, pt_output = b.pt_output_qty, pt_sets = b.pt_set,
                    tag_pt_started = CASE WHEN (b.pt_set > 0 OR b.pt_inspected_qty > 0) THEN 1 ELSE 0 END
        FROM qconn_output_detail_scan_v3 a
            INNER JOIN (
                    SELECT ptno, SUM(isnull(good_qty, 0) + isnull( reject_qty, 0) /*+ isnull( repaired_qty, 0) + isnull( unrepairable_qty, 0) + isnull( replaceable_qty, 0)*/) AS pt_inspected_qty,
                                 SUM(isnull(good_qty, 0) /*+ isnull( reject_qty, 0) + isnull( repaired_qty, 0)*/ + isnull( unrepairable_qty, 0) + isnull( replaceable_qty, 0)) AS pt_output_qty,
                                  (isnull(min_sets, 0) ) AS pt_set
                    FROM qconn_output_detail_scan_v3 (NOLOCK)
                    WHERE MOno = @MOno
                    GROUP BY ptno  , min_sets
            ) b ON a.ptno = b.PTno
        WHERE a.MOno = @MOno

--         UPDATE a SET pt_line_inspected = b.line_inspected_qty, pt_line_output = b.line_output_qty, pt_line_sets = b.line_sets
-- --         SELECT a.mono, a.ptno, a.pt_line_inspected , b.line_inspected_qty, a.pt_line_output , b.line_output_qty, a.pt_line_sets , b.line_sets
--         FROM qconn_output_detail_scan_v3 a
--             INNER JOIN qconn_output_detail_info_v3 m ON a.mono = m.mono
--             INNER JOIN (
--                     SELECT MOno, ptno, prodline, SUM(isnull(good_qty, 0) + isnull( reject_qty, 0) + isnull( repaired_qty, 0) + isnull( unrepairable_qty, 0) + isnull( replaceable_qty, 0)) AS line_inspected_qty,
--                                  SUM(isnull(good_qty, 0) /*+ isnull( reject_qty, 0) + isnull( repaired_qty, 0)*/ + isnull( unrepairable_qty, 0) + isnull( replaceable_qty, 0)) AS line_output_qty,
--                                  SUM(isnull(min_sets, 0) ) AS line_sets
--                     FROM qconn_output_detail_scan_v3 (NOLOCK)
--                     WHERE MOno = @MOno
--                     GROUP BY MOno, ptno, prodline
--             ) b ON a.MOno = b.MOno AND a.PTno = b.PTno
--         WHERE a.MOno = @MOno AND m.mono = @mono AND ( a.prodline = b.prodline OR m.multi = 1)


    UPDATE a SET pt_line_inspected = b.line_inspected_qty, pt_line_output = b.line_output_qty, pt_line_sets = b.line_sets
    FROM qconn_output_detail_scan_v3 a
        INNER JOIN qconn_output_detail_info_v3 m(nolock) ON a.mono = m.mono
        INNER JOIN (
                SELECT MOno, ptno, prodline, SUM(isnull(good_qty, 0) + isnull( reject_qty, 0)  /*+ isnull( repaired_qty, 0) + isnull( unrepairable_qty, 0) + isnull( replaceable_qty, 0)*/ ) AS line_inspected_qty,
                             SUM(isnull(good_qty, 0) /*+ isnull( reject_qty, 0) + isnull( repaired_qty, 0)*/ + isnull( unrepairable_qty, 0) + isnull( replaceable_qty, 0)) AS line_output_qty,
                             SUM(isnull(min_sets, 0) ) AS line_sets
                FROM qconn_output_detail_scan_v3 (NOLOCK)
                WHERE MOno = @MOno
                GROUP BY MOno, ptno, prodline
        ) b ON a.MOno = b.MOno AND a.prodline = b.prodline AND a.PTno = b.PTno
    WHERE a.MOno = @MOno AND m.multi = 0


    UPDATE a SET pt_line_inspected = b.line_inspected_qty, pt_line_output = b.line_output_qty, pt_line_sets = b.line_sets
    FROM qconn_output_detail_scan_v3 a
        INNER JOIN qconn_output_detail_info_v3 m(nolock) ON a.mono = m.mono
        INNER JOIN (
                SELECT MOno, ptno, SUM(isnull(good_qty, 0) + isnull( reject_qty, 0) /*+ isnull( repaired_qty, 0) + isnull( unrepairable_qty, 0) + isnull( replaceable_qty, 0)*/ ) AS line_inspected_qty,
                             SUM(isnull(good_qty, 0) /*+ isnull( reject_qty, 0) + isnull( repaired_qty, 0)*/ + isnull( unrepairable_qty, 0) + isnull( replaceable_qty, 0)) AS line_output_qty,
                             SUM(isnull(min_sets, 0) ) AS line_sets
                FROM qconn_output_detail_scan_v3 (NOLOCK)
                WHERE MOno = @MOno
                GROUP BY MOno, ptno
        ) b ON a.MOno = b.MOno AND a.PTno = b.PTno
    WHERE a.MOno = @MOno AND m.multi = 1

--     select 'qconn_progression_tickets_v3 - 2',pt_line_inspected, * from qconn_progression_tickets_v3 where mono = '13431801001'
-- RETURN
        UPDATE a SET     mo_inspected = b.mo_inspected_qty, mo_output  = b.mo_output_qty,
                        mo_set = CASE WHEN a.multi = 1 THEN b.mo_set ELSE b.min_set END , -- b.mo_set,
                        tag_mo_started = CASE WHEN (b.mo_set > 0 or b.mo_inspected_qty > 0 ) THEN 1 ELSE 0 END
        FROM qconn_output_detail_info_v3 a
            INNER JOIN (
                SELECT MOno, SUM(isnull(good_qty, 0) + isnull( reject_qty, 0)   /*+isnull( repaired_qty, 0) + isnull( unrepairable_qty, 0) + isnull( replaceable_qty, 0)*/ ) as mo_inspected_qty,
                             SUM(isnull(good_qty, 0) /*+ isnull( reject_qty, 0) + isnull( repaired_qty, 0)*/ + isnull( unrepairable_qty, 0) + isnull( replaceable_qty, 0)) as mo_output_qty,
                             COUNT(DISTINCT ptno ) as bundle_count,
                             SUM(isnull(min_sets, 0) ) as mo_set,
                             MIN(isnull(min_sets, 0) ) as min_set
                FROM qconn_output_detail_scan_v3 (nolock)
                WHERE MOno = @MOno
                GROUP BY MOno
            ) b ON a.MOno = b.MOno
        WHERE a.MOno = @MOno

        /*
        UPDATE a SET pt_line_status = b.status, tag_mo_started = b.tag_mo_started, tag_multi = b.multi
        FROM qconn_output_detail_scan_v3 a
            INNER JOIN (
                        SELECT ds.id, a.tag_mo_started, a.multi,      --ds.mono, ds.ptno, ds.prodline,
                            CASE when ISNULL(a.multi,0) = 1 THEN
                                CASE WHEN ISNULL(ah.Qty,0) = ISNULL( ds.pt_output ,0) THEN 'COMPLETED'
                                     -- WHEN ISNULL(ds.pt_line_sets,0) = 0 AND ds.pt_line_inspected = 0 THEN 'PENDING'
                                     WHEN ds.pt_line_inspected = 0 THEN 'PENDING'
                                     -- WHEN ISNULL(ds.pt_line_sets,0) > 0 OR (ds.pt_inspected > 0 AND ds.pt_inspected < ah.Qty) THEN 'IN_PROGRESS'
                                     ELSE 'IN_PROGRESS'
                                END
                            ELSE
                    --             CASE WHEN ISNULL(a.mo_plan_qty,0) = ISNULL( a.mo_output,0) THEN 'COMPLETED'
                                CASE WHEN ISNULL(ds.line_plan_qty,0) = ISNULL(ds.pt_line_inspected,0) THEN 'COMPLETED'
                                    -- WHEN ISNULL(ds.pt_line_sets,0) = 0 AND ds.pt_line_inspected = 0 THEN 'PENDING'
                                    WHEN ds.pt_line_inspected = 0 THEN 'PENDING'
                                    ELSE 'IN_PROGRESS'
                                END
                            END status
                        FROM qconn_output_detail_info_v3 a (nolock)
                            INNER JOIN LayingPT (nolock) ah ON a.MONo = ah.MONo
                            INNER JOIN qconn_output_detail_scan_v3 ds (nolock) ON ds.MOno = ah.MONo AND ds.PTno = ah.PTNo AND ah.LayNo = ds.layNo
                        WHERE a.mono = @MOno
            ) b ON a.id = b.id
        WHERE a.MOno = @MOno */

        UPDATE a SET destination = (SUBSTRING((SELECT DISTINCT  '| ' + Dest AS 'data()' FROM mo_det WHERE qty > 0 AND MONo = a.mono AND mono = @MONo FOR XML PATH('')),3,2000))
        FROM qconn_output_detail_info_v3 a
        WHERE a.mono = @MONo AND ISNULL(destination,'') <> (SUBSTRING((SELECT DISTINCT  '| ' + Dest AS 'data()' FROM mo_det WHERE qty > 0 AND MONo = a.mono AND mono = @MONo FOR XML PATH('')),3,2000))

        IF NOT EXISTS( SELECT * FROM qconn_planning_mono_list(nolock) WHERE status <> 'DONE' AND date_created <= @dateStamp AND mono = @MOno) BEGIN
            INSERT INTO qconn_planning_mono_list(mono, date_created, date_processed, date_done, rem, status)
            VALUES (@mono,@dateStamp, @dateStamp, getdate(), 'Created by Trigger Run by ' + CASE WHEN @ptno IS NOT NULL THEN 'PT:' + @ptno ELSE 'MO:'+@Mono END, 'DONE')
        END ELSE BEGIN
            UPDATE a SET status = 'DONE', date_processed = @dateStamp, date_done = getdate(),
                rem = CASE WHEN @isList = 0 THEN 'Process by Trigger' ELSE 'Process by List' END + ' ->' + CASE WHEN @ptno IS NOT NULL THEN ' PT:' + @ptno ELSE ' MO:' + @Mono END
            FROM qconn_planning_mono_list a
            WHERE status <> 'DONE' AND date_created <= @dateStamp AND mono = @MOno
        END

--		exec qconn_update_tags_in_use

go


CREATE procedure [dbo].[qconn_process_output_summary_daily_v3]
    @ptno varchar(20) = NULL,
    @MONo varchar(20) = NULL
AS
-- SET NOCOUNT ON
    DECLARE @vap varchar(20) = '-' --GET in the wip_settings Table
    DECLARE @dateStamp DATETIME = getdate();
    DECLARE @processPT BIT = CASE WHEN @MONo IS NULL THEN 1 ELSE 0 END;
    DECLARE @V3daily TABLE (mono varchar(30), ptno varchar(30), Prodline varchar(30), StyleNo varchar(30), Color varchar(30), layNo varchar(50), trans_date date)
    DECLARE @V3PTno TABLE (mono varchar(30), ptno varchar(30), layNo varchar(30))

    SET @vap = (SELECT settings FROM wip_settings (nolock) where code = '@AssyPack')
    IF @MONo IS NULL BEGIN
        SET @MONo = (SELECT MONo from Laying_PT (nolock) where PTNo = @PTNo )
    END

    INSERT INTO @V3PTno (mono, ptno, layNo)
    SELECT DISTINCT mono, PTno, LayNo from Laying_PT (nolock) where MONo = @MONo

    --> Store the filtered data so that no double call on (DELETE/INSERT)
        INSERT INTO @V3daily (mono, ptno, Prodline, StyleNo, Color, trans_date, layNo)
        SELECT    s.MONo, s.ptno, s.ProdLine, s.Style_No, s.Color, s.trans_date, l.LayNo
        FROM (
              SELECT a.MONo, a.PTNo, d.Style_No, d.Color, trans_date, prodline
              FROM (
                    SELECT l.MONo, l.PTNo, (WorkSection) AS ProdLine, convert(date,ScanDt) AS trans_date
                    FROM Laying_PT l(NOLOCK)
                             INNER JOIN WIPScan w(NOLOCK) ON l.MONo = w.MONo AND l.PTNo = w.PTNo AND l.LayNo = w.LayNo
                                 AND ( (w.vap = @vap and svap = 'ISS') OR w.SVAP = 'RCV') AND w.mono = @MONo
                             INNER JOIN Laying_Hdr b (NOLOCK) ON l.MONo = b.MONo AND l.LayNo = b.LayNo
                    WHERE b.Status = 'G' AND ISNULL(w.WorkSection, '') <> '' AND l.mono = @MONo
                    GROUP BY l.MONo, l.PTNo, WorkSection, convert(date,ScanDt)
                    UNION
                    SELECT l.MONo, l.PTNo, h.ProdLine, convert(date, h.CreatedDt)
                    FROM @V3PTno l
                         INNER JOIN (SELECT ptno, ProdLine, CreatedDt
                                     FROM EndLineQCHdr (NOLOCK)
                                     WHERE PTNo in ( SELECT DISTINCT ptno FROM @V3PTno where mono = @MONo )
                                    ) h ON l.PTNo = h.PTNo
                    WHERE l.mono = @MONo
                    UNION
                    SELECT l.MONo, l.PTNo, r.ProdLine, convert(date, r.FixedDt)
                    FROM @V3PTno l
    --                              INNER JOIN EndLineQCRFID r(NOLOCK) ON l.PTNo = r.PTNo
                             INNER JOIN (SELECT ptno, ProdLine, FixedDt
                                         FROM EndLineQCRFID (NOLOCK)
                                         WHERE PTNo in ( SELECT DISTINCT ptno FROM @V3PTno where mono = @MONo )
                                        ) r ON l.PTNo = r.PTNo
                    WHERE l.mono = @MONo
                    UNION
                    SELECT l.MONo, l.PTNo, r.ProdLine, convert(date, r.TransDt)
                    FROM @V3PTno l
    --                              INNER JOIN EndLineQCRFID r(NOLOCK) ON l.PTNo = r.PTNo
                             INNER JOIN (SELECT ptno, ProdLine, TransDt
                                         FROM EndLineQCRFID (NOLOCK)
                                         WHERE PTNo in ( SELECT DISTINCT ptno FROM @V3PTno where mono = @MONo )
                                        ) r ON l.PTNo = r.PTNo
                    WHERE l.mono = @MONo
                    ) a
                    INNER JOIN ( SELECT DISTINCT hdr.MONo, hdr.Style_No, det.Color
                                FROM MO_Det det(NOLOCK)
                                    INNER JOIN MO_Hdr hdr(NOLOCK) ON det.MONo = hdr.MONo AND det.Style_No = hdr.Style_No
                                WHERE det.MONo = @MONo AND hdr.mono = @MONo --AND det.Qty > 0
                                ) d ON a.MONo = d.MONo
                    GROUP BY a.MONo, a.PTNo, d.Style_No, d.Color, trans_date, prodline
                ) s
        LEFT JOIN @V3PTno l ON s.mono = l.MONo AND s.ptno = l.ptno
        LEFT JOIN ( SELECT DISTINCT mono, ptno, line, convert(date,trans_date) as trans_date FROM qconn_output_detail_daily_v3 where mono = @MONo ) t
            ON t.MONo = s.Mono AND t.ptno = s.PTNo AND t.line = s.Prodline AND CAST(t.trans_date as date) = CAST(s.trans_date as date)

        DELETE FROM qconn_output_detail_daily_v3 where mono = @mono
       /*
    -- Try to delete if there is duplicate
        DELETE a
--         SELECT a.mono, a.ptno, a.line, a.style, a.color, a.trans_date, a.id, b.mID, CASE WHEN a.id <> b.mID THEN 1 END
        FROM qconn_output_detail_daily_v3 a
            INNER JOIN (SELECT a.mono, a.ptno, a.line, a.style, a.color, a.trans_date, MIN(id) AS mID, MAX(id) AS xID

                        FROM qconn_output_detail_daily_v3 a(nolock)
                                 INNER JOIN @V3daily b
                        ON a.mono = b.mono AND a.ptno = b.ptno AND a.line = b.Prodline AND a.style = b.StyleNo AND
                           a.color = b.Color AND a.trans_date = b.trans_date
                        WHERE a.mono = @MONo
                        GROUP BY a.mono, a.ptno, a.line, a.style, a.color, a.trans_date) b
            ON a.mono = b.mono AND a.ptno = b.ptno AND a.line = b.line AND a.style = b.style AND a.color = b.Color AND a.trans_date = b.trans_date
        WHERE a.id <> b.mID
-- RETURN


    --> delete item that not exist anymore
        DELETE FROM t --SELECT s.MONo, s.ptno, s.StyleNo, s.Color, s.trans_date, s.Prodline
        FROM qconn_output_detail_daily_v3 t
        LEFT JOIN @V3daily s ON t.MONo = s.Mono AND t.ptno = s.PTNo AND t.Color = s.Color AND t.style = s.StyleNo
                AND t.trans_date = s.trans_date AND t.line = s.Prodline AND ISNULL(s.LayNo,0)  =  ISNULL(t.layNo,-1)
        WHERE t.mono = @mono AND s.MONo IS NULL
        */
     --> insert only not exisiting
        INSERT INTO qconn_output_detail_daily_v3 (MONo, ptno, style, Color, trans_date, line, layNo, date_updated)
        SELECT DISTINCT   s.MONo, s.ptno, s.StyleNo, s.Color, s.trans_date, s.Prodline, s.layNo, getdate()
        FROM @V3daily s
        LEFT JOIN qconn_output_detail_daily_v3 t(nolock) ON t.MONo = s.Mono AND t.ptno = s.PTNo --AND t.Color = s.Color AND t.style = s.StyleNo
            AND CAST(t.trans_date as date) = CAST(s.trans_date as date) AND t.line = s.Prodline
        --WHERE t.mono IS NULL

        --> GOOD QTY
        UPDATE i SET good_qty = s.Good, UpdatedDt = s.UpdatedDt, date_updated = @dateStamp
        -- SELECT i.mono, i.ptno, i.style, i.color, i.line, i.trans_date, s.Good, s.UpdatedDt
        FROM qconn_output_detail_daily_v3 i
        INNER JOIN (
                select distinct a.mono, a.PTNo, ScanDt = convert(date,ScanDt), Prodline =  WorkSection, Good = sum(qty), UpdatedDt = MAX(ScanDt)
                from wipscan a (nolock)
                where  a.VAP = @vap AND ISNULL(Qty,0) > 0 
                      AND WorkSection IS NOT NULL AND ISNULL(WorkSection,'') <> '' AND a.mono = @mono
                group by a.mono, a.PTNo, WorkSection,convert(date,ScanDt)
                ) s ON i.MONo = s.MONo AND i.PTNo = s.PTNo and i.trans_date = s.ScanDt AND i.line = s.Prodline
        WHERE i.mono = @mono
    ---------------------------------------------------------------------------------------------------------

        --> REJECT AND SCARP
        UPDATE i SET reject_qty = r.reject_today, unreapairable_qty = r.scrap_today, UpdatedDt = r.UpdatedDt, date_updated = @dateStamp
        --SELECT i.mono, i.ptno, i.style, i.color, i.line, i.trans_date, r.reject_today, r.scrap_today, r.UpdatedDt
        FROM qconn_output_detail_daily_v3 i
        INNER JOIN (
              SELECT    b.MONo, b.PTNo, RejectDate = convert(date,c.TransDt), c.ProdLine,
						reject_today = sum(CASE WHEN C.RejectType != 'CONDPASS' then 1 else 0 end),
                        --reject_today = sum(1),
                        scrap_today = SUM(CASE WHEN C.RejectType = 'UNREPAIRABLE' then 1 else 0 end), UpdatedDt = MAX(c.TransDt)
              FROM Laying_PT b (nolock)
--                   INNER JOIN EndLineQCHdr h (nolock) ON b.PTNo = h.PTNo AND h.PTNo in ( SELECT DISTINCT ptno FROM @V3PTno )
--                   INNER JOIN EndLineQCRFID c (nolock) ON c.PTNo = h.PTNo AND c.Seq = h.Seq AND c.ProdLine = h.ProdLine AND h.PTNo in ( SELECT DISTINCT ptno FROM @V3PTno )
                  INNER JOIN EndLineQCRFID c (nolock) ON c.PTNo = b.PTNo AND /*c.Seq = h.Seq AND c.ProdLine = b.ProdLine AND*/ c.PTNo in ( SELECT DISTINCT ptno FROM @V3PTno )
              WHERE /*h.Reject = 1 AND*/ b.mono = @mono
              GROUP BY b.MONo, b.PTNo, convert(date,c.TransDt), c.ProdLine
              ) r ON i.MONo = r.MONo AND i.PTNo = r.PTNo and i.trans_date = r.RejectDate AND i.line = r.Prodline
        WHERE i.mono = @mono

        --> REWORD AND PASSED
        UPDATE i SET prev_reworked = r.prev_reworked, reworked_qty = r.rework_today, repaired_qty = repair_today, UpdatedDt = r.UpdatedDt, date_updated = @dateStamp --,  layNo = 'XX'
--         SELECT i.mono, i.ptno, i.style, i.color, i.line, i.trans_date, r.rework_today, r.repair_today, r.prev_reworked, r.UpdatedDt
        FROM qconn_output_detail_daily_v3 i
        INNER JOIN (
               --> REWORD AND PASSED
               SELECT    b.MONo, b.PTNo, ReworkDate = convert(date,c.FixedDt), c.ProdLine,
                     rework_today =  sum( case when status = 'PASSED' and c.RejectType in ('REPAIR','REWORK') AND convert(date,c.TransDt) = convert(date,c.FixedDt) then 1  else 0 end),
                     prev_reworked =  sum( case when status = 'PASSED' and c.RejectType in ('REPAIR','REWORK') AND convert(date,c.TransDt) < convert(date,c.FixedDt)  then 1  else 0 end),
                     repair_today =  sum( case when status = 'PASSED' and c.RejectType in ('REPAIR')  then 1  else 0 end), UpdatedDt = MAX(c.FixedDt)
               FROM Laying_PT b (nolock)
                   --INNER JOIN EndLineQCHdr h (nolock) ON b.PTNo = h.PTNo
                   INNER JOIN EndLineQCRFID c (nolock) ON c.PTNo = b.PTNo -- AND c.Seq = h.Seq AND c.ProdLine = h.ProdLine
                                            AND c.PTNo in ( SELECT DISTINCT ptno FROM @V3PTno)
               WHERE b.mono = @mono AND c.FixedDt IS NOT NULL
               GROUP BY b.MONo, b.PTNo, convert(date,c.FixedDt), c.ProdLine
               ) r ON i.MONo = r.MONo AND i.PTNo = r.PTNo and i.trans_date = r.ReworkDate AND i.line = r.Prodline
        WHERE i.mono = @mono

		 --> CONDPASS
        UPDATE i SET condpass_qty = r.condpass
        FROM qconn_output_detail_daily_v3 i
        INNER JOIN (
               --> CONDPASS
               SELECT    b.MONo, b.PTNo, InspectedDate = convert(date,c.transdt), c.ProdLine,
                      condpass = sum( case when status = 'CONDPASS' AND convert(date,c.CPApprovedDt) is not NULL then c.qty  else 0 end)

			   FROM Laying_PT b (nolock)
                   --INNER JOIN EndLineQCHdr h (nolock) ON b.PTNo = h.PTNo
                   INNER JOIN EndLineQCRFID c (nolock) ON c.PTNo = b.PTNo -- AND c.Seq = h.Seq AND c.ProdLine = h.ProdLine
                                            AND c.PTNo in ( SELECT DISTINCT ptno FROM @V3PTno)
               WHERE b.mono = @mono AND c.CPApprovedDt IS NOT NULL
               GROUP BY b.MONo, b.PTNo, convert(date,c.transdt), c.ProdLine
               ) r ON i.MONo = r.MONo AND i.PTNo = r.PTNo and i.trans_date = r.InspectedDate AND i.line = r.Prodline
        WHERE i.mono = @mono

		 --> DISPOSED
        UPDATE i SET disposed_qty = r.disposed
        FROM qconn_output_detail_daily_v3 i
        INNER JOIN (
               --> CONDPASS
               SELECT    b.MONo, b.PTNo, InspectedDate = convert(date,c.transdt), c.ProdLine,
                      disposed = sum( case when status = 'DISPOSED' AND convert(date,c.DisposedDt) is not NULL then 1  else 0 end)

			   FROM Laying_PT b (nolock)
                   --INNER JOIN EndLineQCHdr h (nolock) ON b.PTNo = h.PTNo
                   INNER JOIN EndLineQCRFID c (nolock) ON c.PTNo = b.PTNo -- AND c.Seq = h.Seq AND c.ProdLine = h.ProdLine
                                            AND c.PTNo in ( SELECT DISTINCT ptno FROM @V3PTno)
               WHERE b.mono = @mono AND c.DisposedDt IS NOT NULL
               GROUP BY b.MONo, b.PTNo, convert(date,c.transdt), c.ProdLine
               ) r ON i.MONo = r.MONo AND i.PTNo = r.PTNo and i.trans_date = r.InspectedDate AND i.line = r.Prodline
        WHERE i.mono = @mono

go

CREATE PROCEDURE usp_save_planning_v2
--	declare
		@mfgLoc varchar(10) = 'TARLAC',
		@mono varchar(11) ='',
		@line varchar(4) = '',
		@bono int = 1,
		@planStart datetime = null,
		@planQty integer = null ,
		@id BIGINT = 0,
		@createdBy varchar(20) ='',
		@sbuId int =  1,
		@isAutoAssignedPlanStart bit = 0,
		@isAutoPlanBalance bit = 0,
		@transId varchar(50) = ''
AS

/*SET @Id = 33631
SET @planStart = '2023-08-19 07:30'
SET @TransId = newid()
SET @createdBy  = 'System'
SET @planQty  = 1000
SET @line = 'L03'
SET @mono  = '15008101001'
*/

  -- BEGIN TRANSACTION
 --ROLLBACK TRANSACTION
	declare @insertId varchar(50)= newid()

	declare @prodType varchar(10), @prodMonth date, @moQty int, @custDelDt date,  @timeCreated datetime = getdate()
	declare  @active bit = 1
	declare @next_mo_plan_start datetime

	declare @moId bigint
	declare @mfgLocId integer
	declare @moPlannedQty integer = 0
	declare @moQtyPLanBalance int = 0
	declare @planBalance INTEGER


  if(@id > 0 )
	BEGIN
    select @mono = MONo, @line = line, @planQty = Plan_Qty from BO_Hdr where id = @id

		if(datepart(hour, @planStart)) = 0 and @planStart is not null
		BEGIN
			SET @planStart =  dateadd(minute, 450,  cast ( CAST(@planStart as date) as  datetime ))
		END
		IF( @planStart is null )
		BEGIN
			SELECT  @planStart = dateadd(minute,1, max(plan_start)) from BO_Hdr where MONo = @mono
		END

	--DELETE THE DATA
		select @insertId = insert_id from BO_Hdr where id = @id
		-- REMOVED  Aug 31,2023
		--delete from BO_Hdr where id = @id
		delete from BO_Daily_Target where insert_id = @insertId and MONo = @mono
	END

	-- GET ADDITIONAL MONO INFO
	select @moId = id, @prodType = prod_type, @prodMonth = prod_month, @moQty = (select sum(qty) from mo_det where mo_id = a.id ), @custDelDt=  cus_del_dt
	from mo_hdr a where mono = @mono

	--VALIDATE
	SELECT @mfgLocId  = id from m_mfg_locs where code = @mfgLoc
	select @moQty = isnull(sum(qty),0) from mo_det where mono = @mono and qty > 0
	-- added and id != @id Aug 31,2023
	select @moPlannedQty = isnull(sum(Plan_Qty),0) from BO_Hdr where MONo = @mono and id != @id;

	SET @moQtyPLanBalance = @moQty -  (@moPlannedQty + @planQty)

	--SET THE NEW PLAN BALANCE FROM THE MO QTY LESS PLANNED
	IF(@isAutoPlanBalance = 1 OR @planQty is null )
		BEGIN
			SET @planBalance  = (@moQty-@moPlannedQty)
		END

	IF ( @moPlannedQty = @moQty and @id = 0 )
		BEGIN
			select code = 'error 1 ' + @mono , description = 'this mono is already zero balance. MoPlanned:' +  convert(varchar(20), @moPlannedQty) + ' vs moQty: ' +  convert(varchar(20), @moQty),return_value =null
			RETURN
		END

	-- VALIDATE. CHECK THE BALANCE
	IF (@moQtyPLanBalance < 0 and @id = 0 )
		BEGIN
			select code = 'error 2 ' + @mono, description = 'please set your plan qty to ' + convert(varchar(12), @moQtyPLanBalance  ),return_value =null
			RETURN
		END

/*	if (EXISTS(select 1 from BO_Hdr where MONo = @mono and Line = @line and @planStart between Plan_Start and Plan_Finish  ))
		BEGIN
			SELECT 'error 3' as code, 'mono ' + @mono + ' with plan start ' + convert(varchar(20),@planStart) + ' and line '+ @line + ' is already exists.' as description,return_value =null
			return
		END
*/
	IF ( @planBalance = 0 )
		BEGIN
			select code = 'error 4 ' + @mono, description = 'no more balance to plan! total planned qty is ' + convert(varchar(12), @moPlannedQty),return_value =null
			RETURN
		END

	IF(NOT EXISTS(select top 1 1 from  dbo.m_line_mp where line_code=@line and eff_date<=@planStart order by eff_date desc))
		BEGIN
			select code = 'error 5 ' + @mono, description = 'Line manpower settings with effective date '
																					-- + convert(varchar(20), @planStart) +' on line '+convert(varchar(20),@line) +' not found. '
																						,return_value =null
			RETURN
		END

	IF(NOT EXISTS(select * from m_line_lc where code =@prodType and line_code =@line))
		BEGIN
			select code = 'error 6 ' + @mono, description = 'Learning curve settings with prod type '+convert(varchar(20),@prodType) +' and line '+convert(varchar(20),@line) +' not found.' ,return_value =null
			RETURN
		END

	IF( EXISTS(select 1 from mo_hdr where mono = @mono and plansmv <= 1 ))
		BEGIN
			select code = 'error 7  ' + @mono, description = 'Plan smv is less than or equal to 1.' , return_value =null
			RETURN
		END

	/*select top 1  bono = bono, next_mo_plan_start = next_mo_plan_start
	from AllocateDailyTarget(@mono, @line, @planQty, @planStart, 0)
	order by plan_start desc*/


	--GET BONO AND next Plan start
	select top 1  @next_mo_plan_start = next_mo_plan_start --@bono = bono,
	from AllocateDailyTarget(@mono, @line, @planQty, @planStart, 0)
	order by plan_start desc

	--INSERT INTO DAILY TARGET
	insert into BO_Daily_Target(MONo, BONo, Line, Mfg_Loc, plan_start, plan_finish, smv,  Date, Qty, original_daily_target, learning_curve, Trans_Id, sbu_id, active, Created_By, Time_Created, insert_id)
		select mono, @bono, line, @mfgLoc, plan_start, plan_finish, smv,  plan_start, daily_target_base_on_duration, daily_target, efficiency, @TransId as trans_id, @sbuId, @active, @createdBy, @timeCreated, @insertId
		from AllocateDailyTarget(@mono, @line, @planQty, @planStart, 0)

	--INSERT INTO BO_HDR
		IF(@id = 0)
		BEGIN
			insert into bo_hdr(MONo, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Plan_Start, Plan_Finish, Prd_Typ, Prod_Month, MO_Qty, MO_Cus_Del_Dt, Trans_Id, Trans_Dt, sbu_id, active, total_output_qty, Created_By, Time_Created, insert_id )
			select MONo, @bono, @mfgLoc, Line, Plan_Qty = sum(daily_target_base_on_duration), SMV, Plan_Start = min(Plan_Start), Plan_Finish = max(Plan_Finish),
				@prodType, @prodMonth, @moQty, @custDelDt, @TransId, Trans_Dt =getdate(), @sbuId, @active, total_output_qty = 0, @createdBy, @timeCreated, @insertId
			from AllocateDailyTarget(@mono, @line, @planQty,  @planStart, 0)
			GROUP BY MONo, BONo, Line,SMV
		END
		ELSE
		BEGIN
			UPDATE bo_hdr
			SET BONo = @bono,
					Mfg_Loc = @mfgLoc,
					Plan_Qty = subquery.PlanQtySum,
					SMV = subquery.SMV,
					Plan_Start = subquery.PlanStartMin,
					Plan_Finish = subquery.PlanFinishMax,
					Prd_Typ = @prodType,
					Prod_Month = @prodMonth,
					MO_Qty = @moQty,
					MO_Cus_Del_Dt = @custDelDt,
					Trans_Id = @TransId,
					Trans_Dt = GETDATE(),
					sbu_id = @sbuId,
					active = @active,
					total_output_qty = 0,
					Created_By = @createdBy,
					Time_Created = @timeCreated,
					insert_id = @insertId
			FROM (
					SELECT MONo,
								 SUM(daily_target_base_on_duration) AS PlanQtySum,
								 SMV,
								 MIN(Plan_Start) AS PlanStartMin,
								 MAX(Plan_Finish) AS PlanFinishMax
					FROM AllocateDailyTarget(@mono, @line, @planQty, @planStart, 0)
					GROUP BY MONo, BONo, Line, SMV
			) AS subquery
			WHERE bo_hdr.MONo = subquery.MONo
				AND bo_hdr.BONo = @bono
				AND bo_hdr.SMV = subquery.SMV
				and bo_hdr.id = @id
			;
		END


	--INSERT INTO BO_Learn_Curve
	DELETE FROM BO_Learn_Curve where MONo = @mono and BONo = @bono and Line = @line and sbu_id = @sbuId
	insert into BO_Learn_Curve(MONo, BONo, Line, Learn_Curve, Period_01, Period_02, Period_03, Period_04, Period_05, Period_06, Period_07, Period_08, Period_09, Period_10,
															Period_11, Period_12, Period_13, Period_14, Period_15, Period_16, Period_17, Period_18, Period_19, Period_20,
															Period_21, Period_22, Period_23, Period_24, Period_25, Period_26, Period_27, Period_28, Period_29, Period_30,
															Created_By, Time_Created, Updated_By, Trans_Id, Trans_Dt, Mfg_Loc, active, sbu_id, insert_id)
	select top 1 MONo = @mono, BONo = @bono, Line = @line, Learn_Curve, Period_01, Period_02, Period_03, Period_04, Period_05, Period_06, Period_07, Period_08, Period_09, Period_10,
															Period_11, Period_12, Period_13, Period_14, Period_15, Period_16, Period_17, Period_18, Period_19, Period_20,
															Period_21, Period_22, Period_23, Period_24, Period_25, Period_26, Period_27, Period_28, Period_29, Period_30,
															Created_By, Time_Created, Updated_By, @transId, @timeCreated, @mfgLoc, active, sbu_id, @insertId
	from m_line_lc
	WHERE line_code = @line and code = @prodType

	SELECT 'success' as code, description = 'successfully saved ' + @mono, return_value =  @next_mo_plan_start
go



-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[qconn_display_rejects]
	-- Add the parameters for the stored procedure here
	@prodline varchar(10) = '' , @search varchar(20) = ''

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	declare  @status varchar(10) = 'REJECT'
    if @search = 'REPAIRABLE' 
		begin
			select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
			a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as createdBy, a.transdt
			,b.mono, b.color, c.style_no as style
			,a.newseq, d.color as cardcolor
			from endlineqcrfid a
			inner join laying_pt b on b.ptno = a.ptno
			inner join mo_hdr c on c.mono = b.mono
			left outer join qconn_tag d on d.code = a.newrfid
			where a.prodline = @prodline and a.status = 'REJECT' and rejecttype in ('REJECT','REPAIRABLE','REPLACEABLE')
		end
	else
		if @search = 'UNREPAIRABLE' 
			begin
				select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
					a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as createdBy, a.transdt
					,b.mono, b.color, c.style_no as style
					,a.newseq, a.color as cardcolor
					from endlineqcrfid a
					inner join laying_pt b on b.ptno = a.ptno
					inner join mo_hdr c on c.mono = b.mono
					--inner join qconn_tag d on d.code = a.newrfid
					where a.prodline = @prodline and a.status = 'REJECT' and rejecttype ='UNREPAIRABLE'
			end

	

	


END


go

CREATE PROCEDURE usp_rearrange_planning_while_loop_v2
--declare
    @line varchar(10) = 'L03',
    @createdBy varchar(20) ='',
    @startDateToProcess date = '08/19/2023'
AS
declare
    @mono varchar(11) ='',
    @bono int,
    @planStart datetime = null,
    @planQty integer = null ,
    @id BIGINT = 0,
    @isAutoAssignedPlanStart bit = 0,
    @mfgLoc varchar(10) = '',
    @lineNo varchar(4) = ''

declare @minPlanStart DATETIME
declare @count INT = 1
declare @maxCount INT
declare @transId varchar(50) = newid()
declare @date datetime = getDate()

IF OBJECT_ID(N'TEMPDB..#BO_HDR_TMP') IS NOT NULL DROP TABLE #BO_HDR_TMP
SELECT id, MONo, BONo, Mfg_Loc, Line, Plan_Qty, Plan_Start, Trans_Id,
    row_number()over(order by line, re_order_seq) as Seq
INTO  #BO_HDR_TMP
FROM BO_Hdr
WHERE Line = @line and Plan_Start >= case when @startDateToProcess is null then  convert(date,getdate()-0) else dateadd(day, -0, @startDateToProcess) end  --'03/07/2023'
order by Plan_Start
-- re plan all mo where plan_start is equal to get date

SELECT @maxCount = count(Seq) from #BO_HDR_TMP --where Trans_Id = @recId
SELECT @minPlanStart = min(Plan_Start) FROM #BO_HDR_TMP --where Trans_Id = @recId

BEGIN TRAN REARRANGE_PLANNING_TRANS

--BACKUP BEFORE DELETE
insert into BO_Hdr_OK(mono, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Plan_Start, Plan_Finish, Actual_Start, Actual_Finish, Plant_Color, Prd_Typ, Prd_Typ2, Plant, MO_Qty, MO_Cus_Del_Dt, Completed, Trans_Id, Prod_Month, active, sbu_id, total_planned_qty, total_output_qty, Created_By, Time_Created)
SELECT mono, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Plan_Start, Plan_Finish, Actual_Start, Actual_Finish, Plant_Color, Prd_Typ, Prd_Typ2, Plant, MO_Qty, MO_Cus_Del_Dt, Completed, Trans_Id, Prod_Month, active, sbu_id, total_planned_qty, total_output_qty, @createdBy, @date
FROM BO_Hdr a
WHERE exists (select id from #BO_HDR_TMP b where a.id = b.id)

--DELETE
--REVOVE DELETE. Aug 31, 2023
--DELETE FROM bo_hdr where id in(select id from #BO_HDR_TMP )
DELETE a from BO_Daily_Target a
where EXISTS(select b.id from #BO_HDR_TMP b where a.mono = b.mono and a.Line = b.line and a.BONo = b.bono   )

IF OBJECT_ID(N'TEMPDB..#TMP_RESULTS') IS NOT NULL DROP TABLE #TMP_RESULTS

CREATE TABLE #TMP_RESULTS
(
	code VARCHAR(20),
	description VARCHAR(100),
	next_mo_plan_start datetime
)

declare @newPlanStart datetime

while(@count <= @maxCount)
BEGIN

    --GET THE NEW PLAN START
    if(exists(select top 1 next_mo_plan_start from #TMP_RESULTS where next_mo_plan_start is not null))
        BEGIN
            SELECT top 1 @newPlanStart = next_mo_plan_start from #TMP_RESULTS order by next_mo_plan_start desc
        end

    --ASSIGN THE NEW PLAN START
    SELECT @id = id, @mono = MONo, @mfgLoc = Mfg_Loc, @lineNo = Line, @planQty = Plan_Qty,
        @planStart = case when @count = 1 then @minPlanStart else @newPlanStart end,
        @isAutoAssignedPlanStart = case when @count = 1 then 0 else 1 end,
        @bono = bono
    from #BO_HDR_TMP
    where Seq = @count

    --select @planStart as planStartm, @newPlanStart as newPlanStart, @minPlanStart

    INSERT INTO #TMP_RESULTS (code, description, next_mo_plan_start)
    exec usp_save_planning_v2   @mono = @mono, @line = @lineNo, @planStart =@planStart, @planQty = @planQty, @id=@id, @transId = @transId, @bono = @bono

    --select mono = @mono, line = @lineNo, planStart =@planStart, planQty = @planQty, id=@id, transId = @transId, bono = @bono


    SET @count = @count + 1
END

IF(EXISTS(SELECT * FROM #TMP_RESULTS where code like 'error%'))
BEGIN
    GOTO err;
    RETURN
END

select * from  #TMP_RESULTS
COMMIT TRAN REARRANGE_PLANNING_TRANS
return

err:
select * from  #TMP_RESULTS
ROLLBACK TRAN REARRANGE_PLANNING_TRANS
go

CREATE procedure [dbo].[qconn_endline_rework]
(
	@VAP		VARCHAR(20),
	@SVAP		VARCHAR(20),
	@ISSPL		VARCHAR(10),
	@PTNO		VARCHAR(20),
	@USERID		NVARCHAR(50),
	@SCANDT		Datetime,
	@AUTHOR		NVARCHAR(50),
	@SHIFT		VARCHAR(15),
	@Qty		int,
	@RCVPL		VARCHAR(10),
	@Reject		bit = 0,
	@ElqcSeq	int = 0,
	@result varchar(10) = 'Successful' output
)
as
set nocount on
begin try
	declare @mono varchar(20);
	 /* Get MONo By PTNo */
    select @mono = mono from Laying_PT (NOLOCK) where PTNo = @ptno

	select @VAP = settings from wip_settings  where code = '@AssyPack'
	declare @testcondpass varchar(10), @tmpscandt varchar(20)
	select @testcondpass = status, @tmpscandt = transdt from endlineqcrfid where ptno = @ptno and seq = @elqcseq
	if @testcondpass = 'CONDPASS'
		begin
			set @scandt = @tmpscandt
		end
	if @testcondpass != 'CONDPASS'
		begin
			update endlineqcrfid set fixeduserid = @userid, fixeddt = getdate(), status = 'PASSED' , rejecttype = 'REWORK'
			where ptno = @ptno and seq = @elqcseq
			
			--Select 'Successful', @elqcseq as error
			--exec qconn_process_output_summary_v3 @ptno = @ptno
		end
	Select 'Successful', @elqcseq as error
    --EXEC [dbo].[prdScanWIPSP_MOD2_new] @VAP, @SVAP, @RCVPL, @PTNo, @USERID, @SCANDT, @AUTHOR, @SHIFT, @ISSPL, @QTY, @Reject, @ElqcSeq
	--exec usp_wip_pre_process_report @reportName =  'Process Shipment Monitoring v2', @moNo = @mono


end try
begin catch
    select error_message();
end catch
go

CREATE  PROCEDURE usp_transfer_line
--declare
		@id bigint = '34081',
		@transferToLine varchar(10) ='L09',
		@transferQty int = 151,
		@planStart datetime = '08/31/2023', --07:30:00
		@createdBy varchar(20) ='admin'
AS

begin tran TRAN_CHANGE_LINE
IF OBJECT_ID(N'TEMPDB..#TMP_RESULTS') IS NOT NULL DROP TABLE #TMP_RESULTS
CREATE TABLE #TMP_RESULTS
(
	code VARCHAR(20),
	description VARCHAR(100),
	description2 VARCHAR(100),
	planStart datetime,
)

--SET PLAN START TO DEFAULT 7:30
IF(select FORMAT(@planStart,'HH'))  = '00'
BEGIN
	-- Adding 07:30:00 to the date
		SET @planStart = DATEADD(HOUR, 7, DATEADD(MINUTE, 30, @planStart))
END

declare @planQty int, @origPlanQty int, @mono varchar(20), @line varchar(20), @boNo int, @mfgLoc varchar(10), @sbuId int,
			  @smv numeric(12,4), @prodType varchar(12), @moQty int, @cusDelDt date, @prodMonth date,
				@transId varchar(50),
				@insetId varchar(50),
				@transDate date = getdate(),
				@originPlanStart datetime

set @transId = newid()
set @insetId = @transId
select @id = id, @planQty= Plan_Qty, @origPlanQty= Plan_Qty, @mono = MONo, @line= LINE, @sbuId=sbu_id, @mfgLoc= Mfg_Loc ,
		@smv = smv, @prodType =Prd_Typ, @moQty = MO_Qty, @cusDelDt = MO_Cus_Del_Dt,  @prodMonth = Prod_Month,
		@originPlanStart = Plan_Start, @boNo = BONo
from BO_Hdr where id = @id

--CHECK IF ID EXISTS
if not EXISTS( select 1 from BO_Hdr where id = @id)
BEGIN
	INSERT INTO #TMP_RESULTS(code, description,description2, planStart)
	SELECT code =  'error', description = 'id ' +convert(varchar(10),@id) + ' does not exists.', null, null
	GOTO err
	return
END
--CHECK IF SAME LINE AND SAME QTY
/*if (@transferToLine = @line and @transferQty = @planQty)
BEGIN
	INSERT INTO #TMP_RESULTS(code, description)
	SELECT code =  'error', description = 'id ' +convert(varchar(10),@id) + ' cannot insert the same planQty and same transfer qty and the same line.'
	GOTO err
	return
END*/

declare @fullTransfer bit = 0
declare @durationSeconds INT = 0

--select @origPlanQty , @transferQty. Update Plan start if full trasnfer
if(@origPlanQty = @transferQty)
BEGIN
	SET @fullTransfer = 1
	select @durationSeconds = datediff(second, Plan_Start, Plan_Finish) from BO_Hdr where id = @id
	UPDATE BO_Hdr set Plan_Finish = dateadd(second, @durationSeconds, @planStart), Plan_Start = @planStart where id = @id
END

SET @planQty = @planQty - @transferQty

-- IF full transfer and same line. NO NEED UPDATE THE Line
IF(@fullTransfer = 1 )
BEGIN
	update BO_Hdr set Plan_Qty = @transferQty,
		Line = case when @line != @transferToLine  then  @transferToLine else @line end,
		Updated_By = 'DragDrop', Time_Updated = getdate()
	where id = @id
END
ELSE
BEGIN
	-- UPDATE planQty for the origin
	update BO_Hdr set Plan_Qty = @planQty,  Updated_By = 'DragDrop', Time_Updated = getdate() where id = @id

	--INSERT NEW
	select @boNo= max(bono) + 1 from BO_Hdr where MONo = @mono

	INSERT into BO_Hdr(MONo, Line, BONo,  Plan_Qty, Plan_Start, Plan_Finish, smv, Prd_Typ, MO_Qty, MO_Cus_Del_Dt, Prod_Month,
										 Trans_Dt, Trans_Id, insert_id,  active, sbu_id, Mfg_Loc, Created_By, Time_Created)
	SELECT @mono, @transferToLine, @bono, @transferQty, @planStart, @planStart, @smv, @prodType, @moQty, @cusDelDt, @prodMonth,
				@transDate, @transId, @insetId, 1, @sbuId, @mfgLoc, @createdBy, timeCreated = getdate()

	if(@@ERROR > 0)
	BEGIN
		INSERT INTO #TMP_RESULTS(code, description,description2, planStart)
		SELECT code =  'error', description = 'id ' +convert(varchar(10),@id) + ' cannot insert data to bo_hdr.', null, null
		goto err
		RETURN
	END
END

--DELETE IN ZERO REMAINING
--DELETE FROM BO_Hdr where id = @id and Plan_Qty = 0

if(@line = @transferToLine)
BEGIN
	INSERT INTO #TMP_RESULTS(code, description, description2, planStart)
-- 	SELECT code = @line , description = 'From line ' + @line, description2 = 'Remaining plan qty ' +  + convert(varchar(10),@planQty), @originPlanStart  UNION
	SELECT code = @transferToLine ,description =  'To line ' +  @transferToLine, description2 = 'Transfer Qty ' + convert(varchar(10),@transferQty), @planStart
END
ELSE
BEGIN
	INSERT INTO #TMP_RESULTS(code, description, description2, planStart)
	SELECT code = @line , description = 'From line ' + @line, description2 = 'Remaining plan qty ' +  + convert(varchar(10),@planQty), @originPlanStart  UNION
	SELECT code = @transferToLine ,description =  'To line ' +  @transferToLine, description2 = 'Transfer Qty ' + convert(varchar(10),@transferQty), @planStart
END

select * from  #TMP_RESULTS
COMMIT TRAN TRAN_CHANGE_LINE

RETURN
err:
select * from  #TMP_RESULTS
ROLLBACK TRAN TRAN_CHANGE_LINE
go

--exec prdDownloadOB '15419001001'
CREATE PROCEDURE [dbo].[prdDownloadOB]
--declare
	@MONo varchar(20) = ''
AS
--SET @MONo = '15419001001'

BEGIN
		declare @sbu_id int = 1
		declare @moid bigint

		select @moid  = id from mo_hdr where mono = @MONo
		declare @styleNo varchar(20)
		declare @totalStyleCount int
		select distinct  @styleNo = style_code from ob_upload where mono = @MONo

		--1. Check in mono and style exists
		if(not exists(select 1 from mo_hdr where mono =@mono and @styleNo = @styleNo ))
			BEGIN
				select 'error' as 'code', 'Mono or style does not exist' as 'description'
				RETURN
			END

		--1. Check if multiple styles uploaded
		select @totalStyleCount =  count(distinct style_code) from ob_upload where mono = @mono
		if(@totalStyleCount >=2 )
		BEGIN
				select 'error' as 'code', 'Multiple style detected' as 'description'
				RETURN
		END

		----- INSERT INTO StyleAnalysisHdr Table -----
		INSERT INTO Style_Analysis_Hdr(Style, Desc1, Desc2, Created_By,time_Created)
		SELECT DISTINCT Style_code, Style_Description,Style_Description,Created_By,GETDATE()
			FROM ob_upload
			WHERE Style_code NOT IN (SELECT Style_Code FROM Style_Analysis_Hdr)
			AND MONo = @MONo

		----- INSERT INTO FeatureAnalysisHdr Table -----
		--INSERT INTO FeatureAnalysisHdr(Feature, Desc1, Desc2, CreatedBy,CreatedDt)
		--	SELECT DISTINCT Feature, FeatureDesc, FeatureDesc, CreatedBy,GETDATE()
		--	FROM TmpOB
		--	WHERE Feature NOT IN (SELECT Feature FROM FeatureAnalysisHdr)
		--	AND MONo = @MONo


		----- INSERT INTO StyleAnalysisDet Table -----
		INSERT INTO Style_Analysis_Det(Style, Feature , Desc1, Deleted, Created_By,Time_Created)
		SELECT DISTINCT Style_code, Feature_code,Feature_Description, 0, Created_By, GETDATE()
		FROM ob_upload
		WHERE Style_code+Feature_code NOT IN (SELECT Style+Feature FROM Style_Analysis_Det)
		AND MONo = @MONo

		----- UPDATE, INSERT & DELETE FROM OperationsLibrary TABLE -----
		-- Update data in OperationsLibrary using ob_upload
		UPDATE Operations
		SET VAP = A.VAP,
		SVAP = A.SVAP,
		SAM = A.smv,
		Target_Output = isnull(60/NULLIF(a.smv, 0),0),  --A.smv, --isnull(A.Target_Output,0),
		Difficulty = A.Difficulty,
		Time_Updated = getdate(),
		Updated_By = A.Created_By  ,
		Sps_Machines_Cd = A.Machine_Code,
		Escalation = (SELECT ISNULL(Escalation,0) FROM Control_File),
		Style = A.style_code
		FROM ob_upload A
		WHERE ISNULL(A.VAP,'')+ISNULL(A.SVAP,'')+A.Operation_code+A.Feature_code+A.Style_code = ISNULL(Operations.VAP,'')+ISNULL(Operations.SVAP,'')+Operations.Operation+Operations.Feature+Operations.Style
		AND A.MONo = @MONo

		-- Insert data from ob_upload to OperationsLibrary
		INSERT INTO Operations(Operation, Desc1, Desc2, VAP, SVAP, SAM
		, Target_Output, Cost, Difficulty, Created_By,Sps_Machines_Cd,Escalation,Style,Feature)
		SELECT Operation_code, Operation_Desc, Operation_Desc, VAP, SVAP, smv
		,isnull(60/NULLIF(smv, 0),0) --, isnull(Target_Output,0)
		, isnull(Cost,0), Difficulty, Created_By,machine_code,(SELECT ISNULL(Escalation,0) FROM Control_File)
		,Style_code,Feature_code--,price
			FROM ob_upload
			WHERE Operation_code+Style_code+Feature_code NOT IN (SELECT Operation+Style+Feature FROM Operations)
			AND MONo = @MONo

		----- INSERT INTO FeatureAnalysisDet Table -----
		--INSERT INTO FeatureAnalysisDet(Feature, Operation, VAP, SVAP, CreatedBy,CreatedDt)
		--	SELECT DISTINCT Feature, Operation, VAP, SVAP, CreatedBy,GETDATE()
		--		FROM TmpOB
		--		WHERE Feature+Operation NOT IN (SELECT Feature+Operation FROM FeatureAnalysisDet)
		--		AND MONo  = @MONo

		----- UPDATE, INSERT & DELETE FROM OB TABLE -----
		-- Update data in OB using ob_upload
		UPDATE OB
		SET VAP = A.VAP,
		SVAP = A.SVAP,
		--SAM = A.SAM,
		smv = a.smv,
		Target_Output = isnull(60/ NULLIF(a.smv, 0),0), --a.smv, --A.Target_Output,
		Difficulty = A.Difficulty,
		SEQ = A.Operation_Seq,
		Split = A.Split,
		Time_Updated = GETDATE(),
		Updated_By = A.Created_By,
		machine = A.machine_code,
		Escalation = (SELECT ISNULL(Escalation,0) FROM Control_File)
		,price_per_pc = price
		FROM ob_upload A
		WHERE A.MONo+ISNULL(A.Feature_code, '')+ISNULL(A.Operation_code, '') = OB.MONo+ISNULL(OB.Feature, '')+ISNULL(OB.Operation, '')
		AND A.MONo = @MONo
		DECLARE @btWBT	AS BIT
		SET @btWBT = 0

		/*  remarks by donel value is already 0
		IF EXISTS (SELECT TOP 1 'x' FROM MO_Hdr WHERE MONo = @MONo)
		Begin
		--Set @btWBT = 1
		--SELECT TOP 1 @btWBT = ISNULL(WBT,0) FROM OB WHERE MONo = @MONo
		Select @btWBT = ISNULL(WBT,0) From Mfg_Locs Where Mfg_Loc = (select top 1 Mfg_Loc from MO_Hdr Where MONo = @MONo) And Deleted = 0
		--select @btWBT = ISNULL(WBT,0) from ControlFile
		End
		*/
		-- Insert data into OB from TmpOB

		--INSERT INTO OB(MONo,Feature, Operation,VAP,SVAP,SAM,SAM2,TargetOutput,Cost,Difficulty,Active,StyleNo,Escalation,Seq,Split,WBT,CreatedBy,CreatedDt,SpsMachinesCd)
		--	SELECT MONo,t.Feature, t.Operation,t.VAP,t.SVAP,t.SAM,t.SAM,t.TargetOutput,t.Cost,t.Difficulty,1,t.Style,o.Escalation,t.OperationSeq, t.Split,@btWBT, t.CreatedBy,GETDATE(),t.SpsMachinesCd
		--		FROM TmpOB t INNER JOIN Operations o ON t.Operation = o.Operation AND t.Feature = o.Feature AND t.Style = o.Style
		--		WHERE MONo+ISNULL(t.Feature, '')+ISNULL(t.Operation, '') NOT IN (SELECT MONo+ISNULL(Feature, '')+ISNULL(Operation, '') FROM OB)
		--		AND MONo = @MONo

		DELETE  FROM OB WHERE MONo = @MONo
		AND FEATURE IN (SELECT Part_Cd FROM MO_SVAP_Part WHERE MONo = OB.MONo)
		--AND Feature NOT IN (SELECT PartCd FROM WIPScanPart WHERE MONo = OB.MONo)
		-- remarks by donel AND Operation NOT IN (SELECT Operation FROM WorkersOutputDet WHERE MONo = OB.MONo)

		DELETE FROM OB_GROUP_OPERATIONS WHERE MONo = @MONO
		AND FEATURE IN (SELECT Part_Cd FROM MO_SVAP_Part WHERE MONo = OB_GROUP_OPERATIONS.MONo)
		--AND Feature NOT IN (SELECT PartCd FROM WIPScanPart WHERE MONo = OBGROUPOPERATIONS.MONo)
		--remarks by donel AND Operation NOT IN (SELECT Operation FROM WorkersOutputDet WHERE MONo = OBGROUPOPERATIONS.MONo)

		DELETE FROM MO_SVAP_Part
		FROM MO_SVAP_Part
		WHERE MONo = @MONo
		--AND PartCd NOT IN (SELECT FEATURE FROM OB WHERE MONo = @MONo)
		--AND PartCd NOT IN (SELECT PartCd FROM WIPScanPart WHERE MONo = MOSVAPPart.MONo)


		INSERT INTO OB(sbu_id,MONo, mo_id, Feature, Operation,VAP,SVAP,smv,smv2,Target_Output,price_per_pc,Difficulty,Active,Style_No,Escalation,Seq,Split,WBT
		,Created_By,Time_Created,machine,Remarks, feature_desc, operation_desc,downloaded_by, downloaded_date)
		SELECT @sbu_id,MONo, @moid, t.Feature_code, t.Operation_code,t.VAP,t.SVAP,t.smv,t.smv
		,isnull(60/NULLIF(t.smv, 0),0)  --t.smv --,t.Target_Output
		,t.price,t.Difficulty,1,t.Style_code,o.Escalation,t.Operation_Seq, t.Split,@btWBT
		, t.Created_By,GETDATE(),t.machine_code,t.Remarks,t.feature_description, t.operation_desc, t.created_by, t.time_created
			FROM ob_upload t INNER JOIN Operations o ON t.Operation_code = o.Operation AND t.Feature_code = o.Feature AND t.Style_code = o.Style
			WHERE MONo+ISNULL(t.Operation_code, '') NOT IN (SELECT MONo+ISNULL(Operation, '') FROM OB WHERE MONO = @MONO)
			AND MONo = @MONo


		-- Insert data into OBSpareBT from ob_upload

		INSERT INTO OB_Spare_BT (MONo, Feature, Spare_BT, Created_By,Time_Created)
		SELECT DISTINCT MONo, Feature_code, 0, Created_By, GETDATE()
			FROM ob_upload
			WHERE MONo+Feature_code NOT IN (SELECT MONo+Feature FROM OB_Spare_BT WHERE MONO = @MONO)
			AND MONo = @MONo

		-- Insert data into OBSMVHdr table FROM OB
		--DECLARE	@dtEff		DATETIME
		--INSERT INTO OBSMVHdr(MONo, EffDt, Seq, CreatedBy, CreatedDt)
		--	SELECT TOP 1 ob.MONo, CONVERT(VARCHAR(10),GETDATE(),101), 1, ob.CreatedBy, GETDATE() FROM OB ob WHERE ob.MONo = @MONo AND ob.MONo NOT IN (SELECT obs.MONo FROM OBSMVHdr obs WHERE obs.MONo = @MONo)
		--SELECT TOP 1 @dtEff = EffDt FROM OBSMVHdr WHERE MONo = @MONo


		If Exists (Select 'x' From Control_File Where ISNULL(AutoSMVAprvl,0) = 1)
		Begin
		INSERT INTO OB_SMV_Det(sbu_id,MONo, Eff_Dt, Operation, smv, Created_By, Time_Created,Feature,Style, Approved_By, Approved_dt)
			SELECT @sbu_id,@MONo, getdate()--CONVERT(VARCHAR(10),ob.Eff_Dt,101)
			, ob.Operation_code, ob.smv, ob.Created_By, GETDATE(), Feature_code, Style_code,'System', GETDATE() FROM ob_upload ob WHERE ob.MONo = @MONo AND CAST(ob.MONo AS VARCHAR) + CAST(ob.Operation_code AS VARCHAR)
				NOT IN (SELECT CAST(obs.MONo AS VARCHAR) + CAST(obs.Operation AS VARCHAR) FROM  OB_SMV_Det obs WHERE obs.MONo = @MONo)
		End
		Else
		Begin
		INSERT INTO OB_SMV_Det(sbu_id,MONo, Eff_Dt, Operation, smv, Created_By, Time_Created,Feature,Style)
		SELECT @sbu_id,@MONo, getdate() --CONVERT(VARCHAR(10),ob.Eff_Dt,101)
		, ob.Operation_code, ob.smv, ob.Created_By, GETDATE(), Feature_code, Style_code FROM ob_upload ob WHERE ob.MONo = @MONo AND CAST(ob.MONo AS VARCHAR) + CAST(ob.Operation_code AS VARCHAR)
			NOT IN (SELECT CAST(obs.MONo AS VARCHAR) + CAST(obs.Operation AS VARCHAR) FROM  OB_SMV_Det obs WHERE obs.MONo = @MONo)
		End


		DELETE  FROM MO_SVAP_Part WHERE MONo = @MONo



		--AND PartCd NOT IN (SELECT FEATURE FROM OB WHERE MONo = @MONo)
		--AND VAP+SVAP+PartCd NOT IN (SELECT VAP+SVAP+PartCd FROM WIPScanPart WHERE MONo = @MONo)

		--INSERT LOAD OFF OPERATION



		INSERT INTO MO_SVAP_Part(MONo,Seq,Part_Cd,VAP,SVAP,Deleted,Created_By,Time_Created)
			SELECT DISTINCT  X.MONO,X.SEQ,Feature,X.VAP,X.SVAP,0,'system',GETDATE()
			FROM MO_VAP_SVAP X
			OUTER APPLY (
				SELECT m_SVAP.VAP,m_SVAP.code,GVAP FROM
				m_SVAP
				INNER JOIN m_VAP ON m_SVAP.VAP = m_VAP.code
				WHERE GVAP IN
				(
				SELECT GVAP
				FROM MO_VAP_SVAP A
				WHERE A.MONo = @MONO
				AND A.VAP = X.VAP
				AND Load_On = 1
				)
				--AND [Check_point] = 0
			) CHK
			INNER JOIN (
							SELECT MONO,Feature,GVAP,IssGVAP FROM
							(
							SELECT DISTINCT TOP 100 PERCENT dbo.OB.MONo, dbo.OB.Feature, dbo.OB.Seq, dbo.OB.VAP, dbo.OB.SVAP, dbo.OB.smv, dbo.m_SVAP.GVAP
							,LAG(dbo.m_SVAP.GVAP, 1,'') OVER (PARTITION BY OB.Feature ORDER BY OB.Feature, OB.Seq) AS IssGVAP
							FROM     dbo.OB INNER JOIN
												dbo.m_SVAP ON dbo.OB.SVAP = dbo.m_SVAP.code AND dbo.OB.VAP = dbo.m_SVAP.VAP
							WHERE  (dbo.OB.MONo = @MONO) ORDEr BY OB.Feature, OB.Seq
							) x
							WHERE IssGVAP <> ''
						) PART  ON X.MONO = PART.MONO AND PART.GVAP = CHK.GVAP AND PART.ISSGVAP = X.GVAP
			WHERE X.MONO = @MONO
			--AND X.VAP = 'ICUT-GLU'
			AND Load_Off = 1 AND X.MONO+Feature+X.VAP+X.SVAP NOT IN (SELECT MONO+Part_Cd+VAP+SVAP FROM MO_SVAP_Part WHERE MONo = @MONO)

		--INSERT LOAD ON OPERATION


		INSERT INTO MO_SVAP_Part(MONo,Seq,Part_Cd,VAP,SVAP,Deleted,Created_By,Time_Created)
			SELECT DISTINCT X.MONO,X.SEQ,FEATURE,X.VAP,X.SVAP,0,'system',GETDATE()
			FROM MO_VAP_SVAP X
			OUTER APPLY (
				SELECT m_SVAP.VAP,m_SVAP.code as SVAP,ISNULL(GVAP,'CUT') AS GVAP FROM
				m_SVAP
				INNER JOIN m_VAP ON m_SVAP.VAP = m_VAP.code
				WHERE GVAP IN
				(
				SELECT GVAP
				FROM MO_VAP_SVAP A
				WHERE A.MONo = @MONO
				AND A.VAP = X.VAP
				AND Load_Off = 1
				)
				--AND [Check_point] = 0
			) CHK
			INNER JOIN (
							SELECT MONO,Feature,GVAP,IssGVAP FROM
							(
							SELECT DISTINCT TOP 100 PERCENT dbo.OB.MONo, dbo.OB.Feature, dbo.OB.Seq, dbo.OB.VAP, dbo.OB.SVAP, dbo.OB.smv, dbo.m_SVAP.GVAP
							,LAG(dbo.m_SVAP.GVAP, 1,'CUT') OVER (PARTITION BY OB.Feature ORDER BY OB.Feature, OB.Seq) AS IssGVAP
							FROM     dbo.OB INNER JOIN
												dbo.m_SVAP ON dbo.OB.SVAP = dbo.m_SVAP.code AND dbo.OB.VAP = dbo.m_SVAP.VAP
							WHERE  (dbo.OB.MONo = @MONO) ORDEr BY OB.Feature, OB.Seq
							) x
						) PART  ON X.MONO = PART.MONO AND PART.GVAP = X.GVAP AND ISNULL(PART.ISSGVAP,'CUT') = ISNULL(CHK.GVAP,'CUT')
			WHERE X.MONO = @MONO
			AND Load_On = 1 AND X.MONO+Feature+X.VAP+X.SVAP NOT IN (SELECT MONO+Part_Cd+VAP+SVAP FROM MO_SVAP_Part WHERE MONo = @MONO)



			INSERT INTO MO_SVAP_Part(MONo,Seq,Part_Cd,VAP,SVAP,Deleted,Created_By,Time_Created)
			SELECT A.MONO,A.SEQ,FEATURE,VAP,SVAP,0,'system',GETDATE() FROM MO_VAP_SVAP A
			OUTER APPLY
			(
			SELECT DISTINCT FEATURE
			from OB where mono = @MONO
			AND Feature NOT IN (
			select DISTINCT PART_CD from mo_svap_part where mono = @MONO  AND VAP = 'BIN-INIT'
			)
			) AS PART
			WHERE MONO = @MONO
			AND VAP = 'BIN-INIT'
			AND ISNULL(FEATURE,'') <> ''


			UPDATE MO_VAP_SVAP SET ACTIVE = 0
			WHERE MONO =  @MONO
			AND VAP+SVAP NOT IN
			(
			SELECT DISTINCT VAP+SVAP
			FROM
			MO_SVAP_PART
			WHERE MONO = @MONO
			)
			AND  SEQ2 <> (SELECT TOP 1 SEQ2 FROM MO_VAP_SVAP WHERE MONO = @MONO AND GVAP = 'SEW' AND LOAD_OFF = 1 ORDER BY SEQ2 DESC)


			UPDATE MO_VAP_SVAP SET ACTIVE = 1
			WHERE MONO =  @MONO
			AND VAP+SVAP IN
			(
			SELECT DISTINCT VAP+SVAP
			FROM
			MO_SVAP_PART
			WHERE MONO = @MONO
			)
			AND  SEQ2 <> (SELECT TOP 1 SEQ2 FROM MO_VAP_SVAP WHERE MONO = @MONO AND GVAP = 'SEW' AND LOAD_OFF = 1 ORDER BY SEQ2 DESC)

		IF EXISTS(SELECT * FROM Control_File WHERE ISNULL(AUTOWSSetUP,0) = 1)
		BEGIN

		INSERT INTO OB_Group_Hdr(sbu_id,MONo,Group_Name,VAP,SVAP,Deleted,Created_By,Time_Created)
		SELECT DISTINCT @sbu_id,MONo,OB.VAP+'-'+OB.SVAP,OB.VAP,OB.SVAP,0,'system',GETDATE() FROM OB
		INNER JOIN m_VAP ON OB.VAP = m_VAP.code
		WHERE MONO = @MONo AND MONo+OB.VAP+OB.SVAP NOT IN
		(SELECT MONo+VAP+SVAP FROM OB_Group_Hdr WHERE MONo = @MONo AND VAP = OB.VAP AND SVAP = OB.SVAP)


		INSERT INTO OB_Group_Operations(sbu_id,MONo,Group_Name,Operation,First_Opn,Last_Opn,For_Print,Deleted,Created_By,Time_Created,Seq,Feature,Style,Factory_SMV,Split)
		SELECT DISTINCT @sbu_id,MONo,OB.VAP+'-'+OB.SVAP,OB.Operation,0,0,0,0,'system',GETDATE(),Seq,Feature,Style_No,0,0
		FROM OB
		INNER JOIN m_VAP ON OB.VAP = m_VAP.code
		WHERE MONO = @MONo
		AND OB.VAP+'-'+OB.SVAP+Operation NOT IN (SELECT Group_Name+Operation FROM OB_Group_Operations WHERE MONo = @MONo)


		IF NOT EXISTS(SELECT MONo,Group_Name,Operation,Seq
			FROM OB_Group_Operations A
			WHERE MONo = @MONo
			AND Seq IN (SELECT MIN(Seq) FROM OB_Group_Operations WHERE MONo = A.MONO AND Group_Name = A.Group_Name)
			AND First_Opn = 1)
		BEGIN
			UPDATE A SET A.First_Opn = 1
			--SELECT MONo,GroupName,Operation,Seq
			FROM OB_Group_Operations A
			WHERE MONo = @MONo
			AND Seq IN (SELECT MIN(Seq) FROM OB_Group_Operations WHERE MONo = A.MONO AND Group_Name = A.Group_Name)
			AND First_Opn = 0

			UPDATE A SET A.Last_Opn = 1
			--SELECT MONo,GroupName,Operation,Seq
			FROM OB_Group_Operations A
			WHERE MONo = @MONo
			AND Seq IN (SELECT MAX(Seq) FROM OB_Group_Operations WHERE MONo = A.MONO AND Group_Name = A.Group_Name)
			AND Last_Opn = 0
		END
		END

		--CHECK IF ALREADY HAS LAY
		--RE-INSERT NEW PART IF EXIST IN WIPSCANPART
		IF EXISTS(SELECT 'X' FROM LAYING_HDR WHERE MONo = @MONo AND Status = 'G')
		BEGIN
					DECLARE @LAY NVARCHAR(20)
					DECLARE @NOOFLAY INT
					DECLARE @COUNTER INT = 1

					DECLARE @LAYLIST TABLE
					(
						ROWNO INT,
						LAYNO NVARCHAR(20)
					)

					INSERT INTO @LAYLIST
					SELECT ROW_NUMBER() OVER (PARTITION BY MONO ORDER BY LAYNO) AS ROWNO, LayNo
					FROM Laying_Hdr WHERE MONo = @MONo
					AND Status = 'G'

					SELECT @NOOFLAY = COUNT(*) FROM @LAYLIST

					WHILE @COUNTER <= @NOOFLAY
					BEGIN

					SELECT @LAY = LAYNO FROM @LAYLIST WHERE ROWNO = @COUNTER

					/*Insert Into WIP_Scan_Part(Rec_Id,MONo,LayNo,PTNo,Load_Type,Seq,VAP,SVAP,Part_Cd,Qty,Created_By,Time_Created,Work_Section,Time_Updated,Scan_Dt,Authorized_By,Day_Night_Shft)
					Select
						NEWID(),
						Laying_PT.MONo,
						LAYING_PT.LayNo,
						PTNo,
						1 as LoadType,
						1 as Seq,
						'BIN-INIT',
						'BIN-INIT',
						Part_Cd,
						Qty,
						Laying_PT.Time_Created,
						GETDATE(),
						Laying_Hdr.Created_By,
						NULL,
						Laying_PT.Time_Created,
						NULL,
						'D'--remarks by donel (SELECT TOP 1 Day_Night_Shft FROM WIP_Scan WHERE MONo = @MONo AND Lay_No = Laying_PT.Lay_No)
					From Laying_PT
					INNER JOIN MO_SVAP_PART ON Laying_PT.MONo = MO_SVAP_PART.MONo
					INNER JOIN Laying_Hdr ON Laying_PT.MONo = Laying_Hdr.MONo AND Laying_PT.LayNo = Laying_Hdr.LayNo
					Where Laying_PT.MONo = @MONo AND VAP = 'BIN-INIT'
					AND LAYING_PT.LayNo = @Lay AND PTNo+Part_Cd NOT IN (SELECT PTNo+Part_Cd FROM WIP_Scan_Part WHERE WIP_Scan_Part.mo_id = @moid AND LayNo = @LAY)*/

					Insert Into WIP_Scan_Part(pt_id, Load_Type,Seq,VAP,SVAP,feature,issued_qty,Created_By,Time_Created,work_section_id,Time_Updated,Scan_Dt,Authorized_By,Day_Night_Shft) --Rec_Id, MONo, LayNo, PTNo, remove Mar 27, 2023. Eduard
					Select
						--NEWID(),
						--Laying_PT.MONo,
						--LAYING_PT.LayNo,
						--PTNo,
						pt_id = Laying_PT.id,
						1 as LoadType,
						1 as Seq,
						'BIN-INIT',
						'BIN-INIT',
						Part_Cd,
						Qty,
						Laying_PT.Time_Created,
						GETDATE(),
						Laying_Hdr.Created_By,
						NULL,
						Laying_PT.Time_Created,
						NULL,
						'D'--remarks by donel (SELECT TOP 1 Day_Night_Shft FROM WIP_Scan WHERE MONo = @MONo AND Lay_No = Laying_PT.Lay_No)
					From Laying_PT
					INNER JOIN MO_SVAP_PART ON Laying_PT.MONo = MO_SVAP_PART.MONo
					INNER JOIN Laying_Hdr ON Laying_PT.MONo = Laying_Hdr.MONo AND Laying_PT.LayNo = Laying_Hdr.LayNo
					Where Laying_PT.MONo = @MONo AND VAP = 'BIN-INIT'
					AND LAYING_PT.LayNo = @Lay AND PTNo NOT IN (SELECT PTNo FROM WIP_Scan_Part WHERE WIP_Scan_Part.mo_id = @moid) --replace by Eduard. i cannot see the lay No. Mar 27. 2023
					--AND LAYING_PT.LayNo = @Lay AND PTNo+Part_Cd NOT IN (SELECT PTNo+Part_Cd FROM WIP_Scan_Part WHERE WIP_Scan_Part.mo_id = @moid AND LayNo = @LAY)


					SET @COUNTER = @COUNTER + 1

					END
		END

			-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			----Sync OB to other MO per style
			--			Declare @Style varchar(50)
			--			Declare @MOPerStyle varchar(50)
			--			Select Distinct @Style = Style From TmpOB Where MONo = @MONo

			--			Declare PerStyle Cursor For
			--						Select Distinct
			--							MONO
			--						From OB
			--						Where StyleNo = @Style
			--			Open PerStyle
			--			Fetch Next From PerStyle Into @MOPerStyle
			--			While @@FETCH_STATUS = 0
			--			Begin

			--						-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			--						--delete records that does exists from the source MO
			--							Delete From OBSMVHdr Where MONo = @MONo
			--							Delete From OBSMVDet Where MONo = @MOPerStyle And Operation Not In (Select Operation From OBGroupOperations Where MONo = @MOPerStyle)
			--							Delete From OB Where MONo = @MOPerStyle And Operation Not In (Select Operation From OBGroupOperations Where MONo = @MOPerStyle)
			--						-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			--						-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			--						--insert new record from the source MO
			--							INSERT INTO OB(MONo,Feature, Operation,VAP,SVAP,SAM,SAM2,TargetOutput,Cost,Difficulty,Active,StyleNo,Escalation,Seq,Split,WBT,CreatedBy,CreatedDt,SpsMachinesCd)
			--								SELECT @MOPerStyle,t.Feature, t.Operation,t.VAP,t.SVAP,t.SAM,t.SAM,t.TargetOutput,t.Cost,t.Difficulty,1,t.Style,o.Escalation,t.OperationSeq, t.Split,@btWBT, t.CreatedBy,GETDATE(),t.SpsMachinesCd
			--									FROM TmpOB t INNER JOIN Operations o ON t.Operation = o.Operation AND t.Feature = o.Feature AND t.Style = o.Style
			--									WHERE MONo+ISNULL(t.Feature, '')+ISNULL(t.Operation, '') NOT IN (SELECT MONo+ISNULL(Feature, '')+ISNULL(Operation, '') FROM OB)
			--									AND MONo = @MONo
			--									And t.Operation Not In (Select Operation From OB Where MONo = @MOPerStyle)

			--							INSERT INTO OBSMVDet(MONo, EffDt, Operation, SAM, CreatedBy, CreatedDt,Feature,Style)
			--								SELECT @MONo, CONVERT(VARCHAR(10),ob.EffDt,101), ob.Operation, ob.SAM, ob.CreatedBy, GETDATE() ,Feature,Style
			--								FROM TmpOB ob WHERE ob.MONo = @MONo AND CAST(ob.MONo AS VARCHAR) + CAST(ob.Operation AS VARCHAR)
			--									NOT IN (SELECT CAST(obs.MONo AS VARCHAR) + CAST(obs.Operation AS VARCHAR) FROM  OBSMVDet obs WHERE obs.MONo = @MOPerStyle)

			--						If Exists (Select 'x' From EPFWorkerOp Where MONo = @MOPerStyle)
			--						Begin
			--							IF Object_Id ('tempdb..#tmpOBSMVDet') Is Not Null Drop Table #tmpOBSMVDet
			--							Select MONo,EffDt,Operation,SAM,CreatedBy,CreatedDt,RevisedBy,RevisedDt,ApprovedBy,ApprovedDt
			--							Into #tmpOBSMVDet
			--							From OBSMVDet
			--							Where MONo = @MONo
			--								And Operation In (Select a.Operation from OBSMVDet a
			--													Inner Join EPFWorkerOp b On a.MONo = b.MONo And a.Operation = b.Operation And a.EffDt > b.EffDt
			--													Where a.MONo = @MOPerStyle
			--												 )
			--							--Select * From #tmpOBSMVDet
			--							Update a
			--								Set a.EffDt = b.EffDt, a.RevisedBy = a.CreatedBy, RevisedDt = Getdate()
			--							From OBSMVDet a
			--							Inner Join #tmpOBSMVDet b On a.Operation = b.Operation
			--							Where a.MONo = @MOPerStyle
			--						End
			--						Else
			--						Begin
			--							IF Object_Id ('tempdb..#tmpOB2') Is Not Null Drop Table #tmpOB2
			--							Select MONo,Feature,Operation,Seq,Split,VAP,SVAP,SAM,TargetOutput,Cost,Active,AddedOpn,Difficulty,Remarks,StyleNo,SAM2,Escalation,WBT,
			--											Deleted,CreatedBy,CreatedDt,UpdatedBy,UpdatedDt,Approved,ApprovedBy,ApprovedDt
			--							Into #tmpOB2
			--							From OB
			--							Where MONo = @MONo
			--							--Select * From WorkersOutputDet Where MONo = @MONo And Operation Not In (Select Operation From OBSMVDet Where MONo = @MONo)
			--							--Select * From #tmpOB
			--							Update a
			--								Set a.Escalation = b.Escalation, a.SAM = b.SAM, a.SAM2 = b.SAM2, a.Seq = b.Seq, a.Split = b.Split, a.UpdatedBy = a.CreatedBy, UpdatedDt = Getdate()
			--							From OB a
			--							Inner Join #tmpOB2 b ON a.Operation = b.Operation
			--							Where a.MONo = @MOPerStyle

			--							IF Object_Id ('tempdb..#tmpOBSMVDet2') Is Not Null Drop Table #tmpOBSMVDet2
			--							Select MONo,EffDt,Operation,SAM,CreatedBy,CreatedDt,RevisedBy,RevisedDt,ApprovedBy,ApprovedDt
			--							Into #tmpOBSMVDet2
			--							From OBSMVDet
			--							Where MONo = @MONo
			--							--Select * From #tmpOBSMVDet
			--							Update a
			--								Set a.EffDt = b.EffDt, a.SAM = b.SAM, a.RevisedBy = a.CreatedBy, RevisedDt = Getdate()
			--							From OBSMVDet a
			--							Inner Join #tmpOBSMVDet2 b On a.Operation = b.Operation
			--							Where a.MONo = @MOPerStyle
			--						End

			--			Fetch Next From PerStyle Into @MOPerStyle

			--			End
			--			Close PerStyle
			--			Deallocate PerStyle
		--update mo_status in mo_hdr
		update mo_hdr set mo_status = 'OB' where mono = @mono

		--UPDATE NEXT CHECKPOINT
		update a
		set next_check_point = (select top  1 svap from ob b where a.mono = b.mono and a.feature = b.feature and seq > a.seq order by b.feature, b.seq )
			,next_ob_id = (select top  1 id from ob b where a.mono = b.mono and a.feature = b.feature and seq > a.seq order by b.feature, b.seq )
		from ob a
		where mono=@MONo


	-- update first_operation. updated May 26, 2023
	-- select a.id, a.seq, a.svap, a.next_check_point, a.first_opn, b.last_opn
	update a set first_opn = 1
	from OB a
	inner join (
		select mo_id, svap, next_check_point , first_opn= min(seq) , last_opn= max(seq)
		from ob
		where
						mo_id = @moid
		and next_check_point is not null
			and svap not in ('ASSY')
		group by mo_id, svap, next_check_point
	) b on a.mo_id = b.mo_id and a.svap = b.svap and a.seq = b.first_opn

	-- update last operation. updated May 26, 2023
	--select a.id, a.seq, a.svap, a.next_check_point, a.first_opn, a.last_opn
	update a set last_opn = 1
	from OB a
	inner join (
		select mo_id, svap, next_check_point , first_opn= min(seq) , last_opn= max(seq)
		from ob
		where
						mo_id = @moid
		and next_check_point is not null
			and svap not in ('ASSY')
		group by mo_id, svap, next_check_point
	) b on a.mo_id = b.mo_id and a.svap = b.svap and a.seq = b.last_opn


		-- update last last_opn_seq. added May 26, 2023
		update a set last_opn_seq = b.seq + .01
		from OB a
			inner join (
									select * from ob where first_opn = 1
								 ) b on a.mo_id = b.mo_id and a.svap = b.svap and a.vap = b.vap
		WHERE a.mono = @MONo
		and a.last_opn = 1
/* remarks by Donel 7/5/2023
		if not exists(select 1 from mo_vap_svap where mo_id = @moid  )
		BEGIN
			INSERT INTO mo_vap_svap( mo_id, mono, svap, next_check_point, vap, seq)
			select mo_id, @MONo, svap, next_check_point, vap, seq
			from (
				select *, min(seq)over(partition by svap, next_check_point) seq2
				from (
					select mo_id, svap, next_check_point, svap+'-'+next_check_point as vap, seq
					from OB
					WHERE mo_id = @moid
					and (first_opn = 1  )
					and next_check_point is not null
					UNION ALL
					select mo_id, svap, next_check_point, svap+'-'+next_check_point as vap,  last_opn_seq
					from OB
					WHERE mo_id = @moid
					and (first_opn = 1 or last_opn = 1)
					and next_check_point is not null
					and last_opn_seq - floor(last_opn_seq) > 0
				) a
				WHERE svap != 'ASSY'
			) A
			WHERE seq = seq2
			order by seq
		END
*/
---- modified by Donel 7/5/2023
--declare @mono varchar(20) = '15442601004', @moid int
--set @moid = (select id from mo_hdr where mono = @mono)
	delete from mo_vap_svap where mono = @mono
	insert into mo_vap_svap (seq, mo_id, gvap, next_check_point, vap,load_on, load_off, svap , mono, seq2)
	select 1 as seq, @moid as moid, gvap as gvap, vap as next_check_point,vap , load_on, load_off ,svap_code as svap, @mono as mono,1
	from m_svap where vap = 'BIN-INIT'

	insert into mo_vap_svap (seq, mo_id, gvap, next_check_point, vap,load_on, load_off, svap , mono, seq2)
	select seq = 1 + row_number()over(order by a.sortno,a.seq2,a.gvap,a.next_check_point, a.svap  ),
	a.mo_id, a.gvap as gvap, a.next_check_point, vap
					,a.load_on, a.load_off,  svap, a.mono, a.seq2
	from
			(
			select
			a.mo_id, b.gvap as gvap, a.next_check_point, a.svap+'-'+a.next_check_point as vap
					,b.load_on, b.load_off, b.svap_code as svap, a.mono, a.seq as seq2
			,sortno = (select sort_no from m_tmp_process_sort where process = a.svap )
			from OB a
			inner join m_svap b on b.vap = a.svap+'-'+a.next_check_point
			WHERE a.mo_id = @moid
			and (a.first_opn = 1  )
			and a.next_check_point is not null
			) a
	order by a.sortno,seq2--,a.gvap
	,a.next_check_point, a.svap

	--insert AssyPack
	declare @vap varchar(30) = '', @ctr int
	set @vap = (select settings from wip_settings where code = '@AssyPack')
	if NOT exists (select top 1 mono from mo_vap_svap where mono = @mono and vap = @vap)
		begin
			set @ctr = (select max(seq) from mo_vap_svap where mono = @mono )
			--select @ctr
			insert into mo_vap_svap (seq, mo_id, gvap, next_check_point, vap,load_on, load_off, svap , mono, seq2)
			select @ctr + row_number()over(order by a.svap_code asc) as seq,
			@moid as moid, gvap as gvap, vap as next_check_point,vap , load_on, load_off ,svap_code as svap, @mono as mono,1
			from m_svap a where a.vap = @vap
			order by svap_code asc
			
		end

---- modified by Donel 7/5/2023
		select 'success' as 'code', 'Successful' as 'description'

END
go




-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[qconn_delete_rejects_list] 
@ptno varchar(30), @prodline varchar(10),  @datefrom varchar(10) = ''
	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

   /*
	declare @ptno varchar(30), @prodline varchar(10),  @dateinspected varchar(10) = ''
	set @ptno = '401200050189'
	set @prodline = 'L15'
	set @dateinspected = '10/16/2021'
	*/
	declare  @ioline varchar(200), @mono varchar(20)
	select @mono = (select top 1 mono from laying_pt where ptno = @ptno)
	set @ioline = isnull( (select STUFF((select  ',' +  iOLn from MO_Det aa inner join IO_Det bb on aa.Item_No = bb.Item_No where aa.MONo = @mono FOR XML PATH('')), 1, 1, '') ),'')

	select --id = (row_number() over (order by a.ptno, a.seq)),
	a.seq as id,
	a.ptno, a.seq, a.prodline
	,case when b.ptno is NULL then '1' else '' end as 'Goodrft'
	,case when b.rejecttype in ('REWORK') then '1' else '' end as 'Rework'
	,case when b.ptno is not NULL then '1' else '' end as 'Reject'
	,isnull(b.NewRFID,'') as 'TagRFID'
	,a.CreatedBy as  'InspectedBy', a.CreatedDt as 'InspectedDate', isnull(b.FixedUserID,'') as 'FixedBy', isnull(convert(varchar(30),b.fixeddt),'') as 'FixedDate' 
	,@ioline as ioline
	from endlineqchdr a
	inner join endlineqcrfid b on b.ptno = a.ptno and b.seq = a.seq and b.status in ('REJECT','CONDPASS') --and b.cpapproveddt is null
	where a.ptno = @ptno 
	and a.prodline = (case when @prodline != '' then @prodline else a.prodline end )
	and convert(date,a.createddt,101) = (case when @datefrom != '' then @datefrom else convert(date,a.CreatedDt,101)  end )
	order by a.ptno, a.seq


END


go



CREATE procedure [dbo].[qconn_delete_rejects_process]
	@fromptno varchar(20), @strseq varchar(200), @userid varchar(30) = ''
	
as
begin try
	begin
		declare @actions varchar(20), @codestatus varchar(20)
		set @actions = 'Delete_Rejects'
		set @codestatus = 'AVAILABLE'
		declare @sql1 nvarchar(max)  
		set @sql1 ='begin transaction ' 
		+ ' Insert into endlineqchdr_transfer_logs select ptno,seq,ProdLine,Reject,GarmentCount,CreatedBy,CreatedDt,UpdatedBy,UpdatedDt '
        + ',Authorized,OldPTNo,OldSeq,getdate(),''' + @userid + '''' + ', ''' + @actions + '''' + 'from endlineqchdr where ptno = ''' + @fromptno + '''' + 'and seq in ' + @strseq 
		+ ' Insert into endlineqcdet_transfer_logs select *,getdate() from endlineqcdet where ptno = ''' + @fromptno + '''' + 'and seq in ' + @strseq 
		+ ' Insert into endlineqcrfid_transfer_logs select *,getdate() from endlineqcrfid where ptno = ''' + @fromptno + '''' + 'and seq in ' + @strseq 
		
		+ ' update qconn_tag set status = ''' + @codestatus + '''' + ' where code in (select newrfid from endlineqcrfid where ptno = ''' + @fromptno + '''' + 'and seq in ' + @strseq  + ')'

		+ ' Delete endlineqchdr '
		--+ ', prodline = case when @newprodline = ''''' + ' then a.prodline else ''' + @newprodline + '''' + ' end '
		+  ' where ptno = ''' + @fromptno + '''' + 'and seq in ' + @strseq 
		+ ' Delete endlineqcdet '  
		+  ' where ptno = ''' + @fromptno + '''' + 'and seq in ' + @strseq 
		+ ' Delete endlineqcrfid '  
		+  ' where ptno = ''' + @fromptno + '''' + 'and seq in ' + @strseq 
		+ ' select ''Successful'', 0 as Error '
		+ ' commit transaction '
		--+ ' rollback transaction '
		--select * from endlineqchdr where ptno = '401200000012' and seq in @seq
		exec sp_Executesql @sql1
		exec qconn_process_output_summary_v3 @ptno = @fromptno
		
	end
end try
begin catch
    select error_message();
end catch


go


-- =============================================
-- select * from SourceERP
-- =============================================
create PROCEDURE [dbo].[ordSyncIOMatDL]
	-- Add the parameters for the stored procedure here
--	@SrcERP		varchar(10),
	@sbu_id int = 1,
	@UserId		NVARCHAR(50),
	@IONo		varchar(20) = null
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRY

	DECLARE @RecId AS varchar(100)
	DECLARE @LastRunTime AS Datetime
	DECLARE @CurrRunTime AS Datetime
	DECLARE @SrcERP AS VARCHAR(20) = 'DL'
			
	Set @RecId = NEWID()

	 INSERT INTO [dbo].[stg_SyncLog]([Recid],[RunTime],[CreatedBy],[Remarks])
     VALUES(@RecId, getdate(), @UserId, 'ordSynIOMatDL - Initialize')


	if isnull(@IONo,'') = ''
	BEGIN

		--DECLARE @CurrRunTime AS Datetime, @LastRunTime AS Datetime, @SrcERP AS VARCHAR(20) = 'DL'
		--declare @sbu_id int = 1, @RecId AS varchar(100) = newid()

		Select @CurrRunTime = SrvDt from [Link_DLXSRV].[XDB].[dbo].[iMAPPSInterface_GetDate_vw]

		--UPDATE dbo.InterfaceMatRT SET PrevRuntime = LastRunTime where ServerName = @SrcERP
		
		SELECT top 1 @LastRunTime = isnull(Last_RunTime,getdate()) From dbo.m_Interface_Mat_RT where sbu_id = @sbu_id and Server_Name = @SrcERP
		--Select @CurrRunTime, @LastRunTime

		--Select * from InterfaceMatRT
		--UPDATE dbo.InterfaceMatRT SET LastRunTime = @CurrRunTime where ServerName = @SrcERP	

		Select distinct MONo AS IONo into #IOMatUpdate from [Link_DLXSRV].[XDB].[dbo].[iMAPPSMatTrack_vw] Where UpdatedDt >= @LastRunTime
		and MfgLoc in (Select Mfg_Loc from dbo.m_Interface_Mfg_Loc_RT Where Server_Name = @SrcERP)

		
		--Select * from #IOMatUpdate
		--Select MONo FROM [Link_DLXSRV].[XDB].[dbo].[iMAPPSMatTrack_vw] Where MONo in (Select IONo from #IOMatUpdate)
		--delete from IOMatLst Where IONo in (Select IONo from #IOMatUpdate)

		Update dbo.stg_SyncLog set Remarks = 'ordSynIOMatDL - Insert IO Materials.', TimeFinish = getdate() Where RecId = @RecId
			WHILE 1=1
				BEGIN
					Select top 1 @IONo = IONo from #IOMatUpdate

					delete from IO_Mat_List Where IONo = @IONo

					WaitFor DELAY '00:00:00:01'
					INSERT INTO [dbo].[IO_Mat_List]
							([IONo]
							,[UV]
							,[Mat_No]
							,[Mat_Desc]
							,[Mat_Typ_Grp]
							,[Mat_Typ_Grp_Desc]
							,[Mat_Grp]
							,[Mat_Grp_Desc]
							,[Mat_Typ]
							,[Mat_Typ_Desc]
							,[In_Post_Dt]
							,[In_Tran_ETA_Dt]
							,[Time_Created]
							,[Created_By]
							,[CONo]
							,[Ex_Mill_Dt]
							,[Process]
							,[Plant_Avail_Dt]
							,[In_Avail_Qty]
							,[Season]
							,Comp_ETA
							,ETA_Fty
							,ETA_HK
							,ID_Qty
							,[ID_Act_Rcv_Dt]
							,[MR_Dt]
							,[PR_Dt]
							,[PO_Dt]
							,[TP_Dt]
							--,[TODt]
							,[ETA_Dt]
							,[GIMR_Iss_Max_Dt]
							,[GIMR_Iss_Dt]
							,[MR_Qty]
							,[PR_Qty]
							,[PO_Qty]
							,[PA_Qty]
							,[Iss_Prod_Qty]
							,[Reqd_Qty]
							,[Old_Mat_No]
							,[Color]
							,[Tot_Qty]
							,[Tot_Test_Qty]
							,[ReOrder_Qty]
							,[Base_UOM]
							,[Mat_Specs_EN]
							,[Mat_Specs_CN]
							,[LETA_Fty]
							,[Country_Cd]
							,[Dlv_Qty]
							,[Order_UOM]
							,[ETA_Fty_DLL]
							,[PONo], Mat_Type_EN, Mat_Type_CN, Depart_Ind,[Mat_Color_EN])
					SELECT [MONo]
							,[MONo]
							,[MatNo]
							,[DescEN]
							,[MatTyp]
							,[MatTyp]
							,[MatTyp]
							,[MatTyp]
							,[MatTyp]
							,[MatTyp]
							,ETADt
							,ETADt
							,getdate()
							,@UserId
							,MONo
							,ETADt
							,ProcessCd
							,ETADt
							,POQty+IssProdQty
							,SeasonCd
							,CompETA
							,ETAFty
							,ETAHK
							,IDQty
							,[IDActRcvDt]
							,[MRDt]
							,[PRDt]
							,[PODt]
							,[TPDt]
							--,[TODt]
							,[ETADt]
							,[GIMRIssDtMax]
							,[GIMRIssDt]
							,[MRQty]
							,[PRQty]
							,[POQty]
							,[PAQty]
							,[IssProdQty]
							,[ReqdQty]
							,[OldMatNo]
							,[Color]
							,[TotQty]
							,[TotTestQty]
							,[ReOrderQty]
							,[BaseUOM]
							,[MatSpecsEN]
							,[MatSpecsCN]
							,[LatestETAFty]
							,[CountryCd]
							,[DlvQty]
							,[OrderUOM]
							,[ETAFtyDLL]
							,[PONo], MatTypeEN, MatTypCN, DepartInd,[MatColorEN]
						FROM [Link_DLXSRV].[XDB].[dbo].[iMAPPSMatTrack_vw]
						--Where MONo in (Select IONo from #IOMatUpdate)
						Where MONo = @IONo


					delete from #IOMatUpdate Where IONo = @IONo

					IF (Select isnull(Count(1),0) from #IOMatUpdate) = 0 BREAK
				END
			--END
		UPDATE dbo.m_Interface_Mat_RT SET Last_RunTime = @CurrRunTime, Prev_Runtime = @LastRunTime where sbu_id = @sbu_id and Server_Name = @SrcERP	
	END
/*	ELSE
	BEGIN
		delete from IOMatLst Where IONo = @IONo

		Update dbo.SyncLog set Remarks = 'ordSynIOMatDL - Insert IO Materials.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[IOMatLst]
				([IONo]
				,[UV]
				,[MatNo]
				,[MatDesc]
				,[MatTypGrp]
				,[MatTypGrpDesc]
				,[MatGrp]
				,[MatGrpDesc]
				,[MatTyp]
				,[MatTypDesc]
				,[InPostDt]
				,[InTranETADt]
				,[CreatedDt]
				,[CreatedBy]
				,[CONo]
				,[ExMillDt]
				,[Process]
				,[PlantAvailDt]
				,[InAvailQty]
				,[Season]
				,CompETA
				,ETAFty
				,ETAHK
				,IDQty
				,[IDActRcvDt]
				,[MRDt]
				,[PRDt]
				,[PODt]
				,[TPDt]
				--,[TODt]
				,[ETADt]
				,[GIMRIssMaxDt]
				,[GIMRIssDt]
				,[MRQty]
				,[PRQty]
				,[POQty]
				,[PAQty]
				,[IssProdQty]
				,[ReqdQty]
				,[OldMatNo]
				,[Color]
				,[TotQty]
				,[TotTestQty]
				,[ReOrderQty]
				,[BaseUOM]
				,[MatSpecsEN]
				,[MatSpecsCN]
				,[LETAFty]
				,[CountryCd]
				,[DlvQty]
				,[OrderUOM]
				,[ETAFtyDLL]
				,[PONo], MatTypeEN, MatTypeCN, DepartInd,[MatColorEN])
		SELECT [MONo]
				,[MONo]
				,[MatNo]
				,[DescEN]
				,[MatTyp]
				,[MatTyp]
				,[MatTyp]
				,[MatTyp]
				,[MatTyp]
				,[MatTyp]
				,ETADt
				,ETADt
				,getdate()
				,@UserId
				,MONo
				,ETADt
				,ProcessCd
				,ETADt
				,POQty+IssProdQty
				,SeasonCd
				,CompETA
				,ETAFty
				,ETAHK
				,IDQty
				,[IDActRcvDt]
				,[MRDt]
				,[PRDt]
				,[PODt]
				,[TPDt]
				--,[TODt]
				,[ETADt]
				,[GIMRIssDtMax]
				,[GIMRIssDt]
				,[MRQty]
				,[PRQty]
				,[POQty]
				,[PAQty]
				,[IssProdQty]
				,[ReqdQty]
				,[OldMatNo]
				,[Color]
				,[TotQty]
				,[TotTestQty]
				,[ReOrderQty]
				,[BaseUOM]
				,[MatSpecsEN]
				,[MatSpecsCN]
				,[LatestETAFty]
				,[CountryCd]
				,[DlvQty]
				,[OrderUOM]
				,[ETAFtyDLL]
				,[PONo], MatTypeEN, MatTypCN, DepartInd,[MatColorEN]
			FROM [Link_DLXSRV].[XDB].[dbo].[iMAPPSMatTrack_vw]
			Where MONo = @IONo

	END
	*/
	Update dbo.stg_SyncLog set Remarks = 'ordSynIOMatDL - Completed.', TimeFinish = getdate() Where RecId = @RecId
	
	END TRY
	
	BEGIN CATCH
		IF (@@TRANCOUNT > 0)
		--SELECT 1 AS ERROR_MSG
			--SELECT ERROR_MESSAGE() AS ERROR_MSG
			Update dbo.stg_SyncLog set Remarks = left('ordSynIOMatDL - ' + ERROR_MESSAGE(),2000), TimeFinish = getdate() Where Recid = @RecId
			--ROLLBACK TRANSACTION	
	END CATCH	
	
END

go


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[qconn_display_condpass]
	-- Add the parameters for the stored procedure here
	@search varchar(20) = '',
	@datefrom varchar(10) = NULL,
	@dateto varchar(10) = NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	if @datefrom is NULL
		BEGIN
			if @search = 'ALL'
				begin
					select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
					a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as inspector, a.transdt
					,b.mono, b.color, d.styleno as style
					,case	when a.cpstatus = 0 or a.cpstatus is NULL then 'For Approval'
							when a.cpstatus = 1 then 'Approved / For Confirmation'
							when a.cpstatus = 2 then 'Confirmed'
					end as Status, a.qty, a.remarks, a.parts
					,a.CPApprovedUserID, a.CPApprovedDt
					,a.CPConfirmedUserID, a.CPConfirmedDt, isnull(a.CPConfirmedQty,0) as CPConfirmedQty
					,d.ioline, d.custstyle
					from endlineqcrfid a --with(index(endlineqcrfid_status))
					inner join layingpt b on b.ptno = a.ptno
					inner join mohdr c on c.mono = b.mono

					inner join
						(select hdr.MONo, hdr.StyleNo, dtl.CustColor as Color, concat(hdr.IONO, '-', hdr.SplitNo) as ioLine, a.custStyle from MOHdr (nolock) hdr
							inner join (select distinct MONo, CustColor from MODet (nolock) where Qty > 0) dtl on hdr.MONo = dtl.MONo
							left outer join (select IONo,custStyle from IOHdr ) a on a.iono = hdr.iono
						) d on b.MONo = d.mono


					where status = 'CONDPASS'
				end
			else
				if @search = 'ForApproval'
					begin
						select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
							a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as inspector, a.transdt
							,b.mono, b.color, d.styleno as style
							,case	when a.cpstatus = 0 or a.cpstatus is NULL then 'For Approval'
									when a.cpstatus = 1 then 'Approved / For Confirmation'
									when a.cpstatus = 2 then 'Confirmed'
							end as Status, a.qty, a.remarks, a.parts
							,a.CPApprovedUserID, a.CPApprovedDt
							,a.CPConfirmedUserID, a.CPConfirmedDt, isnull(a.CPConfirmedQty,0) as CPConfirmedQty
							,d.ioline, d.custstyle
							from endlineqcrfid a --with(index(endlineqcrfid_status))
							inner join layingpt b on b.ptno = a.ptno
							inner join mohdr c on c.mono = b.mono

							inner join
								(select hdr.MONo, hdr.StyleNo, dtl.CustColor as Color, concat(hdr.IONO, '-', hdr.SplitNo) as ioLine, a.custStyle from MOHdr (nolock) hdr
									inner join (select distinct MONo, CustColor from MODet (nolock) where Qty > 0) dtl on hdr.MONo = dtl.MONo
									left outer join (select IONo,custStyle from IOHdr ) a on a.iono = hdr.iono
								) d on b.MONo = d.mono

						where status = 'CONDPASS' and cpstatus = 0
					end

				else
					if @search = 'Approved' or @search = 'ForConfirmation'
						begin
							select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
								a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as inspector, a.transdt
								,b.mono, b.color, d.styleno as style
								,case	when a.cpstatus = 0 or a.cpstatus is NULL then 'For Approval'
										when a.cpstatus = 1 then 'Approved / For Confirmation'
										when a.cpstatus = 2 then 'Confirmed'
								end as Status, a.qty, a.remarks, a.parts
								,a.CPApprovedUserID, a.CPApprovedDt
								,a.CPConfirmedUserID, a.CPConfirmedDt, isnull(a.CPConfirmedQty,0) as CPConfirmedQty
								,d.ioline, d.custstyle
								from endlineqcrfid a --with(index(endlineqcrfid_status))
								inner join layingpt b on b.ptno = a.ptno
								inner join mohdr c on c.mono = b.mono
								inner join
									(select hdr.MONo, hdr.StyleNo, dtl.CustColor as Color, concat(hdr.IONO, '-', hdr.SplitNo) as ioLine, a.custStyle from MOHdr (nolock) hdr
										inner join (select distinct MONo, CustColor from MODet (nolock) where Qty > 0) dtl on hdr.MONo = dtl.MONo
										left outer join (select IONo,custStyle from IOHdr ) a on a.iono = hdr.iono
									) d on b.MONo = d.mono

								where status = 'CONDPASS' and cpstatus = 1
							end
					else
						if @search = 'Confirmed'
							begin
								select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
									a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as inspector, a.transdt
									,b.mono, b.color, d.styleno as style
									,case	when a.cpstatus = 0 or a.cpstatus is NULL then 'For Approval'
											when a.cpstatus = 1 then 'Approved / For Confirmation'
											when a.cpstatus = 2 then 'Confirmed'
									end as Status, a.qty, a.remarks, a.parts
									,a.CPApprovedUserID, a.CPApprovedDt
									,a.CPConfirmedUserID, a.CPConfirmedDt, isnull(a.CPConfirmedQty,0) as CPConfirmedQty
									,d.ioline, d.custstyle
									from endlineqcrfid a --with(index(endlineqcrfid_status))
									inner join layingpt b on b.ptno = a.ptno
									inner join mohdr c on c.mono = b.mono

									inner join
										(select hdr.MONo, hdr.StyleNo, dtl.CustColor as Color, concat(hdr.IONO, '-', hdr.SplitNo) as ioLine, a.custStyle from MOHdr (nolock) hdr
											inner join (select distinct MONo, CustColor from MODet (nolock) where Qty > 0) dtl on hdr.MONo = dtl.MONo
											left outer join (select IONo,custStyle from IOHdr ) a on a.iono = hdr.iono
										) d on b.MONo = d.mono

								where status = 'CONDPASS' and cpstatus = 2
							end

						else
							if @search = 'Partial'
								begin
									select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
										a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as inspector, a.transdt
										,b.mono, b.color, d.styleno as style
										,case	when a.cpstatus = 0 or a.cpstatus is NULL then 'For Approval'
												when a.cpstatus = 1 then 'Approved / For Confirmation'
												when a.cpstatus = 2 then 'Confirmed'
										end as Status, a.qty, a.remarks, a.parts
										,a.CPApprovedUserID, a.CPApprovedDt
										,a.CPConfirmedUserID, a.CPConfirmedDt, isnull(a.CPConfirmedQty,0) as CPConfirmedQty
										,d.ioline, d.custstyle
										from endlineqcrfid a --with(index(endlineqcrfid_status))
										inner join layingpt b on b.ptno = a.ptno
										inner join mohdr c on c.mono = b.mono

										inner join
											(select hdr.MONo, hdr.StyleNo, dtl.CustColor as Color, concat(hdr.IONO, '-', hdr.SplitNo) as ioLine, a.custStyle from MOHdr (nolock) hdr
												inner join (select distinct MONo, CustColor from MODet (nolock) where Qty > 0) dtl on hdr.MONo = dtl.MONo
												left outer join (select IONo,custStyle from IOHdr ) a on a.iono = hdr.iono
											) d on b.MONo = d.mono

									where status = 'CONDPASS' and cpstatus = 1 and (a.qty - a.CPConfirmedQty <> 0 )
								end
		
		END -- if datefrom is null
	else
		BEGIN  --
			if @search = 'ALL'
				begin
					select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
					a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as inspector, a.transdt
					,b.mono, b.color, d.styleno as style
					,case	when a.cpstatus = 0 or a.cpstatus is NULL then 'For Approval'
							when a.cpstatus = 1 then 'Approved / For Confirmation'
							when a.cpstatus = 2 then 'Confirmed'
					end as Status, a.qty, a.remarks, a.parts
					,a.CPApprovedUserID, a.CPApprovedDt
					,a.CPConfirmedUserID, a.CPConfirmedDt, isnull(a.CPConfirmedQty,0) as CPConfirmedQty
					,d.ioline, d.custstyle
					from endlineqcrfid a --with(index(endlineqcrfid_status))
					inner join layingpt b on b.ptno = a.ptno
					inner join mohdr c on c.mono = b.mono

					inner join
						(select hdr.MONo, hdr.StyleNo, dtl.CustColor as Color, concat(hdr.IONO, '-', hdr.SplitNo) as ioLine, a.custStyle from MOHdr (nolock) hdr
							inner join (select distinct MONo, CustColor from MODet (nolock) where Qty > 0) dtl on hdr.MONo = dtl.MONo
							left outer join (select IONo,custStyle from IOHdr ) a on a.iono = hdr.iono
						) d on b.MONo = d.mono


					where status = 'CONDPASS' and cast(a.transdt as date) between @datefrom and @dateto
				end
			else
				if @search = 'ForApproval'
					begin
						select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
							a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as inspector, a.transdt
							,b.mono, b.color, d.styleno as style
							,case	when a.cpstatus = 0 or a.cpstatus is NULL then 'For Approval'
									when a.cpstatus = 1 then 'Approved / For Confirmation'
									when a.cpstatus = 2 then 'Confirmed'
							end as Status, a.qty, a.remarks, a.parts
							,a.CPApprovedUserID, a.CPApprovedDt
							,a.CPConfirmedUserID, a.CPConfirmedDt, isnull(a.CPConfirmedQty,0) as CPConfirmedQty
							,d.ioline, d.custstyle
							from endlineqcrfid a --with(index(endlineqcrfid_status))
							inner join layingpt b on b.ptno = a.ptno
							inner join mohdr c on c.mono = b.mono

							inner join
								(select hdr.MONo, hdr.StyleNo, dtl.CustColor as Color, concat(hdr.IONO, '-', hdr.SplitNo) as ioLine, a.custStyle from MOHdr (nolock) hdr
									inner join (select distinct MONo, CustColor from MODet (nolock) where Qty > 0) dtl on hdr.MONo = dtl.MONo
									left outer join (select IONo,custStyle from IOHdr ) a on a.iono = hdr.iono
								) d on b.MONo = d.mono

						where status = 'CONDPASS' and cpstatus = 0 and cast(a.transdt as date) between @datefrom and @dateto
					end

				else
					if @search = 'Approved' or @search = 'ForConfirmation'
						begin
							select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
								a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as inspector, a.transdt
								,b.mono, b.color, d.styleno as style
								,case	when a.cpstatus = 0 or a.cpstatus is NULL then 'For Approval'
										when a.cpstatus = 1 then 'Approved / For Confirmation'
										when a.cpstatus = 2 then 'Confirmed'
								end as Status, a.qty, a.remarks, a.parts
								,a.CPApprovedUserID, a.CPApprovedDt
								,a.CPConfirmedUserID, a.CPConfirmedDt, isnull(a.CPConfirmedQty,0) as CPConfirmedQty
								,d.ioline, d.custstyle
								from endlineqcrfid a --with(index(endlineqcrfid_status))
								inner join layingpt b on b.ptno = a.ptno
								inner join mohdr c on c.mono = b.mono
								inner join
									(select hdr.MONo, hdr.StyleNo, dtl.CustColor as Color, concat(hdr.IONO, '-', hdr.SplitNo) as ioLine, a.custStyle from MOHdr (nolock) hdr
										inner join (select distinct MONo, CustColor from MODet (nolock) where Qty > 0) dtl on hdr.MONo = dtl.MONo
										left outer join (select IONo,custStyle from IOHdr ) a on a.iono = hdr.iono
									) d on b.MONo = d.mono

								where status = 'CONDPASS' and cpstatus = 1 and cast(a.CPApprovedDt as date) between @datefrom and @dateto
							end
					else
						if @search = 'Confirmed'
							begin
								select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
									a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as inspector, a.transdt
									,b.mono, b.color, d.styleno as style
									,case	when a.cpstatus = 0 or a.cpstatus is NULL then 'For Approval'
											when a.cpstatus = 1 then 'Approved / For Confirmation'
											when a.cpstatus = 2 then 'Confirmed'
									end as Status, a.qty, a.remarks, a.parts
									,a.CPApprovedUserID, a.CPApprovedDt
									,a.CPConfirmedUserID, a.CPConfirmedDt, isnull(a.CPConfirmedQty,0) as CPConfirmedQty
									,d.ioline, d.custstyle
									from endlineqcrfid a --with(index(endlineqcrfid_status))
									inner join layingpt b on b.ptno = a.ptno
									inner join mohdr c on c.mono = b.mono

									inner join
										(select hdr.MONo, hdr.StyleNo, dtl.CustColor as Color, concat(hdr.IONO, '-', hdr.SplitNo) as ioLine, a.custStyle from MOHdr (nolock) hdr
											inner join (select distinct MONo, CustColor from MODet (nolock) where Qty > 0) dtl on hdr.MONo = dtl.MONo
											left outer join (select IONo,custStyle from IOHdr ) a on a.iono = hdr.iono
										) d on b.MONo = d.mono

								where status = 'CONDPASS' and cpstatus = 2 and cast(a.CPConfirmedDt as date) between @datefrom and @dateto
							end

						else
							if @search = 'Partial'
								begin
									select id = (row_number() over (order by a.prodline,a.ptno, a.seq)),
										a.ptno, a.seq, a.prodline as line, a.newrfid as rfid, a.userid as inspector, a.transdt
										,b.mono, b.color, d.styleno as style
										,case	when a.cpstatus = 0 or a.cpstatus is NULL then 'For Approval'
												when a.cpstatus = 1 then 'Approved / For Confirmation'
												when a.cpstatus = 2 then 'Confirmed'
										end as Status, a.qty, a.remarks, a.parts
										,a.CPApprovedUserID, a.CPApprovedDt
										,a.CPConfirmedUserID, a.CPConfirmedDt, isnull(a.CPConfirmedQty,0) as CPConfirmedQty
										,d.ioline, d.custstyle
										from endlineqcrfid a --with(index(endlineqcrfid_status))
										inner join layingpt b on b.ptno = a.ptno
										inner join mohdr c on c.mono = b.mono

										inner join
											(select hdr.MONo, hdr.StyleNo, dtl.CustColor as Color, concat(hdr.IONO, '-', hdr.SplitNo) as ioLine, a.custStyle from MOHdr (nolock) hdr
												inner join (select distinct MONo, CustColor from MODet (nolock) where Qty > 0) dtl on hdr.MONo = dtl.MONo
												left outer join (select IONo,custStyle from IOHdr ) a on a.iono = hdr.iono
											) d on b.MONo = d.mono

									where status = 'CONDPASS' and cpstatus = 1 and (a.qty - a.CPConfirmedQty <> 0 ) and cast(a.CPApprovedDt as date) between @datefrom and @dateto
								end
		
		END
END

go




create PROCEDURE [dbo].[stg_ordUpdateDiffMO_CPMO]
(
	@MONO		VARCHAR(50),
	@USERID		NVARCHAR(50)
)
--exec [ordUpdateDiffMO_CP] 'system'
AS

SET NOCOUNT ON 
	
BEGIN TRY

	--Update Req Duration to Orig Req Duration for Active/Activated
	Update MO_Events Set Req_Duration = CASE WHEN m.Req_Duration = 0 THEN m.Orig_Req_Duration ELSE m.Req_Duration END, Active = 1
	--SELECT m.MONo, m.Event_Seq, m.VAP, m.Req_Duration, m.Orig_Req_Duration
	FROM     dbo.MO_Events AS m 
	INNER JOIN dbo.Event_SVAP AS e ON m.Event_Seq = e.Event_Seq 
	INNER JOIN	dbo.MO_VAP_SVAP AS v ON e.SVAP = v.SVAP AND e.VAP = v.VAP AND m.MONo = v.MONo
	WHERE isnull(v.Active,0) = 1 AND
	 (ISNULL(m.Active, 0) = 0) 
	AND m.MONo = @MONO 
--'7523490001'

	--Update MOEvents Set ReqDuration = CASE WHEN moe.ReqDuration = 0 THEN moe.OrigReqDur ELSE moe.ReqDuration END, Active = 1
	----Select moe.MONo, moe.EventSeq, moe.VAP, moe.ReqDuration, moe.OrigReqDur, mov.GVAP 
	--from MOEvents moe inner join 
	--(
	--Select distinct MONo, GVAP from MOVAPSVAP where Active = 1 --and MONo = @SelMO
	--) mov on moe.MONo = mov.MONo and moe.VAP = mov.GVAP
	--where moe.Active = 0 --and moe.ReqDuration = 0 --and isnull(moe.OrigReqDur,0) > 0
	--and moe.MONo = @MONO
	--and moe.MONo = (Select distinct MONo from MOVAPSVAP Where MONo = @MONO)

	--Update Req Duration to 0 for In-Active/Deactivated
	Update MO_Events Set Active = 0, Req_Duration = 0
	--Select distinct m.MONo, m.EventSeq, m.VAP, m.ReqDuration, m.OrigReqDur 
	from MO_Events m left outer join
	(
	SELECT DISTINCT m.MONo, m.Event_Seq
	FROM     dbo.MO_Events AS m with (nolock) 
	INNER JOIN dbo.Event_SVAP AS e with (nolock) ON m.Event_Seq = e.Event_Seq 
	INNER JOIN dbo.MO_VAP_SVAP AS v with (nolock) ON e.SVAP = v.SVAP AND e.VAP = v.VAP AND m.MONo = v.MONo
	WHERE isnull(v.Active,0) = 1
	) e on m.MONo = e.MONo and m.Event_Seq = e.Event_Seq
	Where e.MONo is null and isnull(m.VAP,'') <> ''
	AND isnull(m.Active,0) = 1
	AND m.MONo = @MONO --'7523490001'
	--Update MOEvents Set ReqDuration = 0, Active = 0 
	----Select moe.MONo, moe.EventSeq, moe.VAP, moe.ReqDuration, moe.OrigReqDur, mov.GVAP 
	--from MOEvents moe Left outer join 
	--(
	--Select distinct MONo, GVAP from MOVAPSVAP where Active = 1 --and MONo = @SelMO
	--) mov on moe.MONo = mov.MONo and moe.VAP = mov.GVAP
	--where moe.VAP is not null
	--and mov.GVAP is null
	--and moe.Active = 1
	--and moe.MONo = @MONO
	--and moe.MONo = (Select distinct MONo from MOVAPSVAP Where MONo = @MONO)

	SELECT 0 AS [STATUS], 'UPDATED' AS ERROR_MSG


END TRY
BEGIN CATCH
	SELECT ERROR_MESSAGE()
END CATCH

--select * from MOEvents Where MONo = '42013456013'
--select Distinct MONo from MOEvents Where POStart is null and ReqStart is null and MONo in (Select distinct Mono from MODet Where PODDt > '10/1/2017') 
--and MONo in (Select distinct MOno from BOHdr)


go



-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[qconn_display_delete_rejects_history]
	@search varchar(20)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	if @search = 'delete_rejects'
		begin
			select id = (row_number() over (order by a.ptno, a.seq, b.transdt))
			,a.prodline, b.newrfid as tagrfid, c.mono, c.color, d.ioline
					, a.ptno, a.seq, b.transdt as inspecteddt, b.userid as inspectedby
					,a.lasttransferdt as deleteddt, a.transferby as deletedby
			from endlineqchdr_transfer_logs a  
			left outer join endlineqcrfid_transfer_logs b  on b.ptno = a.ptno and b.seq = a.seq
			inner join laying_pt c on c.ptno = a.ptno
			inner join (select MONo, IONo, concat(IONO, '-', Split_No) as ioline from MO_Hdr (nolock)) d on d.mono = c.MONo
			where a.action = @search
			order by a.ptno, a.seq
		end
	else
		begin
			select id = (row_number() over (order by a.ptno, a.seq, b.transdt))
			,a.prodline, b.newrfid as tagrfid, c.mono, c.color, d.ioline
					, a.ptno, a.seq, b.transdt as inspecteddt, b.userid as inspectedby
					,a.lasttransferdt as deleteddt, a.transferby as deletedby
			from endlineqchdr_transfer_logs a  
			left outer join endlineqcrfid_transfer_logs b  on b.ptno = a.ptno and b.seq = a.seq
			inner join laying_pt c on c.ptno = a.ptno
			inner join (select MONo, IONo, concat(IONO, '-', Split_No) as ioline from MO_Hdr (nolock)) d on d.mono = c.MONo
			where a.action = 'x'
			order by a.ptno, a.seq
		end

		

END


go

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create PROCEDURE [dbo].[qconn_force_complete] 
	-- Add the parameters for the stored procedure here
	@mono varchar(20),
	@order_status varchar(20) = ''
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    update a set force_complete = case when @order_status = 'SHORTSHIPPED' then 1 else 0 end
	from qconn_output_detail_scan_v3 a
	where a.mono = @mono


END
go

create PROCEDURE [dbo].[prdValidateTmpOBBeforeUpload]  
	@MONo varchar(20)  
AS
BEGIN
	
	--update Seq, Split No if operation exists in OBGroupOperations
	--UPDATE tmpOB 
	--	SET OperationSeq = o.Seq, split = o.Split
	--	FROM tmpob t INNER JOIN OBGroupOperations o ON o.mono = t.MONo AND o.Operation = t.Operation 
	--	WHERE t.mono = @MONo
	
	IF  EXISTS (SELECT 'x' FROM ob_upload t INNER JOIN OB_Group_Operations o ON t.MONo = o.MONo AND t.Operation_code = o.Operation WHERE t.MONo =  @MONo )
	BEGIN
		SELECT DISTINCT '0', '99' as ErrCode, 'The following operations already exist in Work Section Set-up ' AS ErrDesc, t.MONo, t.Operation_code FROM ob_upload t INNER JOIN OB_Group_Operations o ON t.MONo = o.MONo AND t.Operation_code = o.Operation WHERE t.MONo =  @MONo 
		RETURN
	END

	SELECT 1

END
go




CREATE procedure [dbo].[qconn_endline_condpass_status]
(
	@PTNO		VARCHAR(20),
	@SEQ		integer,
	@STATUS		varchar(20),
	@USERNAME		NVARCHAR(50)
	--@result varchar(10) = 'Successful' output
)
as
set nocount on
declare @VAP varchar(50), @SVAP varchar(30) = 'ISS', @SCANDT datetime = getdate(), @qty integer
, @RCVPL varchar(10), @ISSPL varchar(10) = '', @Reject bit = 0
--declare @Inspected_by varchar(50), @Inspected_Dt datetime

--	begin try
		if @STATUS = 'APPROVED'
			begin
				--select @VAP = settings from wip_settings  where code = '@AssyPack'
				--select @QTY = qty, @RCVPL = prodline from endlineqcrfid where ptno = @ptno and seq = @seq 
				--set @ISSPL = @RCVPL
				
				--begin transaction
				update endlineqcrfid set cpApprovedUserId = @USERNAME, cpApprovedDt = @SCANDT, cpStatus = 1
				where ptno = @ptno and seq = @seq and status = 'CONDPASS' and cpstatus = 0
				--commit transaction
				--declare @Inspected_by varchar(50), @Inspected_Dt datetime
				--select @Inspected_by = userid, @Inspected_Dt = transdt from endlineqcrfid where ptno = @ptno and seq = @seq
				--update wipscan set createdby = @Inspected_by, scandt = @Inspected_Dt 
				--where ptno = @ptno and qcseq = @seq
				--exec qconn_process_output_summary_v3 @ptno = @ptno
			end
		else
			begin
				declare @cpconfirmedqty int, @totalconfirmedqty int, @cpQty int, @cpStatus int
				set @cpconfirmedqty = cast(@STATUS as integer)
				select @totalconfirmedqty = isnull(cpconfirmedqty,0) + @cpconfirmedqty , @cpQty = Qty
				from endlineqcrfid where ptno = @ptno and seq = @seq and status = 'CONDPASS'
				if @totalconfirmedqty <= @cpQty
					begin
						update endlineqcrfid set CPConfirmedUserID = case when CPConfirmedUserID is NULL then @USERNAME + ' {' + cast(@cpconfirmedqty as varchar(4)) + '}' else CPConfirmedUserID + ' / ' + @USERNAME + ' {' + cast(@cpconfirmedqty as varchar(4)) + '}'  end
						, cpConfirmedDt = @SCANDT
						, cpStatus = case when @totalconfirmedqty < @cpQty then 1 else 2 end
						, CPConfirmedQty = isnull(CPConfirmedQty,0) + @cpconfirmedqty
						where ptno = @ptno and seq = @seq and status = 'CONDPASS' and cpstatus = 1
					end
				
			end


/*	end try
begin catch
    select error_message();
end catch
*/


go

CREATE FUNCTION DAYSADDNOWK(@addDate AS DATE, @numDays AS INT)
RETURNS DATETIME
AS
BEGIN
    WHILE @numDays>0
    BEGIN
       SET @addDate=DATEADD(d,1,@addDate)
       --IF DATENAME(DW,@addDate)='saturday' SET @addDate=DATEADD(d,1,@addDate)
       IF DATENAME(DW,@addDate)='sunday' SET @addDate=DATEADD(d,1,@addDate)

       SET @numDays=@numDays-1
    END

    RETURN CAST(@addDate AS DATETIME)
END
go


CREATE procedure [dbo].[qconn_endline_percentile] (
    @line as varchar(10) = null,
    @year as int = null,
    @month as int = null,
    @percentage as float = null
)
as
begin
    set nocount on
    set @year = ISNULL(@year, year(GETDATE()))
    set @percentage = ISNULL(@percentage, 5)

    select row_number() over (order by prodline, dtmonth, dtyear) as id, prodline, dtmonth, dtyear, rejects, inspected, rejects / (inspected * 1.0) * 100 as percentage from
    (select a.WorkSection as ProdLine, month(a.ScanDt) as dtmonth, year(ScanDt) as dtyear, sum(Qty) as inspected
         , isnull((select count(1) from EndLineQCRFID where
        ProdLine = a.WorkSection and month(TransDt) = month(a.ScanDt) and year(TransDt)=year(a.ScanDt)
        group by ProdLine, month(TransDt), year(TransDt)), 0) as rejects
    from WIPScan a
    where VAP = 'assy-ppck'
    group by a.WorkSection, month(a.ScanDt), year(ScanDt))a
    where rejects / (inspected * 1.0) * 100 <= @percentage and dtyear = @year and dtmonth = isnull(@month, dtmonth)
        and ProdLine = isnull(@line, ProdLine)
    order by dtyear, dtmonth, ProdLine
end
go

--exec usp_get_plan_finish @planStart = '2023-12-01 07:00:00', @mono = '13572801001', @line = 'L01', @planQty = '300', @prodType = 'XBODY'
CREATE PROCEDURE usp_get_plan_finish
  @planStart datetime = null,
  @mono varchar(20) =  '14723301001',
  @line varchar(20) = 'L01',
  @planQty int = 1750,
  @prodType varchar(20) = 'BUS'
AS
/*declare @planStart datetime
declare @mono varchar(20) =  '14723301001'
declare @line varchar(20) = 'L01'
declare @prodType varchar(20) = 'BUS'
*/
if( @planStart is  null )
  select @planStart = max(Plan_Finish) from BO_Hdr where Line =  @line

SELECT A5.*,
      new_plan_finish =
        case when excess_minutes > 0 then
            dateadd(minute, excess_minutes, dateadd(hh, shedule_to_start,
                                                    dbo.DAYSADDNOWK(plan_finished, 1) --dateadd(day, 1, convert(datetime,convert(date,plan_finished)))
            ))
        else
          plan_finished
        end,
      last_bono = isnull((select max(convert(int,BONo)) from BO_Hdr where MONo = @mono),0),
      planned_qty = isnull((select sum(Plan_Qty) from BO_Hdr where MONo = @mono),0),
      mo_qty = (select sum(qty) from mo_det where MONo = @mono),
      mo_no = @mono
FROM
(
    SELECT *, (DATEPART(HOUR, plan_finished ) * 60) + DATEPART(MINUTE, plan_finished ) -
              (DATEPART(HOUR, shedule_to_finish ) * 60) + DATEPART(MINUTE, shedule_to_finish ) as excess_minutes
    FROM (
        -- 3. Plan Finish Computation
        select top 1 *, period_target + difference as target_output , target_per_hr = floor(period_target / 8),
            floor((period_target + difference) / floor(period_target / 8) * 60) as minutes_to_finish,
            (period_target + difference) / floor(period_target / 8) as hour_to_finish,
            plan_finished = dateadd(minute, plan_start_min + floor((period_target + difference) / floor(period_target / 8) * 60) ,  dbo.DAYSADDNOWK(plan_start , period -1  )),
            shedule_to_start = 7, --FIXED 7AM IN
            shedule_to_finish = '01/01/1900 16:00' --FIXED 16:00 OUT
        from (
          -- 2. get the the per day target base on learning curve, smv and manpower
            select A2.*,
                period_target = ceiling(manpower*working_minutes/smv*efficiency),
                running_target = sum(ceiling(manpower*working_minutes/smv*efficiency))over(order by period),
                plan_qty = @planQty,
                difference = @planQty-sum(ceiling(manpower*working_minutes/smv*efficiency))over(order by period),
                plan_start =  @planStart,
                plan_start_min = (DATEPART(HOUR, @planStart ) * 60) + DATEPART(MINUTE, @planStart)
            FROM (
              --1. Get the learning curve
              select code, period = period , efficiency,
                  manpower = (select  top 1 manpower from ImappsV2.dbo.m_line_mp where line_code =a.line_code and eff_date<=@planStart order by eff_date desc ),
                  working_minutes = 480,
                  smv = (select  plansmv from mo_hdr where mono = @mono )   --smv = (select  plansmv from mo_hdr where mono = '13572801001' )  , (select  plansmv from mo_hdr where mono = @mono )
              from view_learning_curve a
              where line_code = @line  and code = @prodType --line_code = 'L01'  and code = 'XBODY'
              --where line_code = 'M01'  and code = 'LLG'

            ) A2
        ) A3
        where plan_qty <running_target
        --order by period
    ) A4
) A5
go







CREATE PROCEDURE [dbo].[plnPopulateMOETA]
@sbu_id int = 1

AS

SET NOCOUNT ON

BEGIN TRY
	--BEGIN TRAN
		--declare @sbu_id int = 1
		TRUNCATE TABLE DBO.MO_MAT_ETA

		----- FOR Leather
		INSERT INTO DBO.MO_MAT_ETA (sbu_id,MONO, LATEST_ETA, Mat_Typ, Mat_No, Mat_Desc)
		SELECT DISTINCT @sbu_id,
			M.MONo
			,CASE WHEN MAX(COALESCE(Plant_Avail_Dt, '12/31/2099')) = '12/31/2099' THEN NULL ELSE MAX(Plant_Avail_Dt) END as LATEST_ETA
			,'Leather'
			,CASE WHEN EXISTS(SELECT 'x' FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Leather' and Plant_Avail_Dt IS NULL)
				THEN (SELECT TOP 1 Mtrl_No FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Leather' and Plant_Avail_Dt IS NULL)
				ELSE (SELECT TOP 1 Mtrl_No FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Leather' ORDER BY Plant_Avail_Dt DESC)
			 END as Mtrl_No
			,CASE WHEN EXISTS(SELECT 'x' FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Leather' and Plant_Avail_Dt IS NULL)
				THEN (SELECT TOP 1 Mat_Desc FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Leather' and Plant_Avail_Dt IS NULL)
				ELSE (SELECT TOP 1 Mat_Desc FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Leather' ORDER BY Plant_Avail_Dt DESC)
			 END as Mat_Desc
		FROM 
			dbo.MO_Mat_List_vw M
		WHERE
			Mat_Typ = 'Leather'
			--and MONO = '45014489006'
		GROUP BY M.MONo

		----- FOR ACCESSORIES
		INSERT INTO DBO.MO_MAT_ETA (sbu_id,MONO, LATEST_ETA, Mat_Typ, Mat_No, Mat_Desc)
		SELECT DISTINCT @sbu_id,
			M.MONo
			,CASE WHEN MAX(COALESCE(Plant_Avail_Dt, '12/31/2099')) = '12/31/2099' THEN NULL ELSE MAX(Plant_Avail_Dt) END as LATEST_ETA
			,'Textile'
			,CASE WHEN EXISTS(SELECT 'x' FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Textile' and Plant_Avail_Dt IS NULL)
				THEN (SELECT TOP 1 Mtrl_No FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Textile' and Plant_Avail_Dt IS NULL)
				ELSE (SELECT TOP 1 Mtrl_No FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Textile' ORDER BY Plant_Avail_Dt DESC)
			 END as Mtrl_No
			,CASE WHEN EXISTS(SELECT 'x' FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Textile' and Plant_Avail_Dt IS NULL)
				THEN (SELECT TOP 1 Mat_Desc FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Textile' and Plant_Avail_Dt IS NULL)
				ELSE (SELECT TOP 1 Mat_Desc FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Textile' ORDER BY Plant_Avail_Dt DESC)
			 END as Mat_Desc
		FROM 
			dbo.MO_Mat_List_vw M
		WHERE
			Mat_Typ = 'Textile'
			--and MONO = '45014489006'
		GROUP BY M.MONo

		INSERT INTO DBO.MO_MAT_ETA (sbu_id,MONO, LATEST_ETA, Mat_Typ, Mat_No, Mat_Desc)
		SELECT DISTINCT @sbu_id,
			M.MONo
			,CASE WHEN MAX(COALESCE(Plant_Avail_Dt, '12/31/2099')) = '12/31/2099' THEN NULL ELSE MAX(Plant_Avail_Dt) END as LATESTETA
			,'Hardware'
			,CASE WHEN EXISTS(SELECT 'x' FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Hardware' and Plant_Avail_Dt IS NULL)
				THEN (SELECT TOP 1 Mtrl_No FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Hardware' and Plant_Avail_Dt IS NULL)
				ELSE (SELECT TOP 1 Mtrl_No FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Hardware' ORDER BY Plant_Avail_Dt DESC)
			 END as Mtrl_No
			,CASE WHEN EXISTS(SELECT 'x' FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Hardware' and Plant_Avail_Dt IS NULL)
				THEN (SELECT TOP 1 Mat_Desc FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Hardware' and Plant_Avail_Dt IS NULL)
				ELSE (SELECT TOP 1 Mat_Desc FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Hardware' ORDER BY Plant_Avail_Dt DESC)
			 END as Mat_Desc
		FROM 
			dbo.MO_Mat_List_vw M
		WHERE
			Mat_Typ = 'Hardware'
			--and MONO = '45014489006'
		GROUP BY M.MONo

		----- FOR ACCESSORIES
		INSERT INTO DBO.MO_MAT_ETA (sbu_id,MONO, LATEST_ETA, Mat_Typ, Mat_No, Mat_Desc)
		SELECT DISTINCT @sbu_id,
			M.MONo
			,CASE WHEN MAX(COALESCE(Plant_Avail_Dt, '12/31/2099')) = '12/31/2099' THEN NULL ELSE MAX(Plant_Avail_Dt) END as LATESTETA
			,'Zipper'
			,CASE WHEN EXISTS(SELECT 'x' FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Zipper' and Plant_Avail_Dt IS NULL)
				THEN (SELECT TOP 1 Mtrl_No FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Zipper' and Plant_Avail_Dt IS NULL)
				ELSE (SELECT TOP 1 Mtrl_No FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Zipper' ORDER BY Plant_Avail_Dt DESC)
			 END as Mtrl_No
			,CASE WHEN EXISTS(SELECT 'x' FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Zipper' and Plant_Avail_Dt IS NULL)
				THEN (SELECT TOP 1 Mat_Desc FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Zipper' and Plant_Avail_Dt IS NULL)
				ELSE (SELECT TOP 1 Mat_Desc FROM dbo.MO_Mat_List_vw WHERE MONo = M.MONo and Mat_Typ = 'Zipper' ORDER BY Plant_Avail_Dt DESC)
			 END as Mat_Desc
		FROM 
			dbo.MO_Mat_List_vw M
		WHERE
			Mat_Typ = 'Zipper'
			--and MONO = '45014489006'
		GROUP BY M.MONo

	--COMMIT TRAN
END TRY
BEGIN CATCH
	--ROLLBACK TRAN
END CATCH


go



CREATE procedure [dbo].[qconn_endline_report_top5_defects]
	@datefrom varchar(10), @dateto varchar(10)
	, @topN varchar(2) = '5'
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
--declare @datefrom date, @dateto date, @topnN integer = 4
	--set @datefrom = '01/01/2022'
	--set @dateto = '12/31/2023'
	IF OBJECT_ID(N'tempdb..##Tempdefectlist ') IS NOT NULL
		BEGIN
			DROP TABLE ##Tempdefectlist 
		END

	IF OBJECT_ID(N'tempdb..##Tempdefectlist_1 ') IS NOT NULL
		BEGIN
			DROP TABLE ##Tempdefectlist_1 
		END

		create table ##Tempdefectlist ( tranyear integer, tranmonth integer, defecttype varchar(50), desc1 nvarchar(200), defectcount int, maxtransdt datetime );
		create table ##Tempdefectlist_1 ( tranyear integer, tranmonth integer, defecttype varchar(50), desc1 nvarchar(200), defectcount int, maxtransdt datetime );


		insert into ##Tempdefectlist  
		select  year(a.transdt) as tran_year, month(a.transdt) as tran_month,  max(b.defecttype) as defecttype, c.desc1, count(1) as 'defect_count', max(transdt)
		from endlineqcrfid a
		inner join endlineqcdet b on b.ptno = a.ptno and b.seq = a.seq
		inner join defecttypes c on c.defecttype = b.defecttype
		where cast(a.transdt as date) between @datefrom and @dateto
		group by year(a.transdt),month(a.transdt), desc1--, b.defecttype, c.desc1
		--order by year(a.transdt),month(a.transdt), 'defect_count' desc

--select * from ##Tempdefectlist order by desc1  

	DECLARE 
		@tranyear integer, 
		@tranmonth   integer;

	DECLARE cursor_year_month CURSOR
	FOR 
	select tranyear, tranmonth from ##Tempdefectlist
	group by tranyear, tranmonth
	order by tranyear, tranmonth;

	OPEN cursor_year_month;

	FETCH NEXT FROM cursor_year_month INTO 
		@tranyear, 
		@tranmonth;

	WHILE @@FETCH_STATUS = 0
		BEGIN
			
			insert into ##Tempdefectlist_1
			select top 5 *
			--tranyear, tranmonth
			--,max(defecttype), desc1 as description, sum(defectcount) as 'defectcnt', max(maxtransdt) 
			from ##Tempdefectlist

			where tranyear = @tranyear and tranmonth = @tranmonth
			--group by tranyear, tranmonth, desc1
			order by defectcount desc 
		 
			FETCH NEXT FROM cursor_year_month INTO 
				@tranyear, 
				@tranmonth;
		END;

	CLOSE cursor_year_month;

	DEALLOCATE cursor_year_month;

	select id = (row_number() over (order by tranyear, tranmonth)),
	tranyear, tranmonth, FORMAT(maxtransdt,'MMM') as tranmonthname
	--,defecttype
	, desc1 as defecttype
	, defectcount from ##Tempdefectlist_1
	order by tranyear, tranmonth, defectcount desc

END
--and b.defecttype = 'FPK018'

--select * from endlineqcdet where createddt between '01/01/2023' and '01/31/2023' and defecttype = 'FPK018'
--order by 

--select * from defecttypes


go

CREATE PROCEDURE usp_save_planning_v2_with_validate
	--declare
		@mfgLoc varchar(10) = 'TARLAC',
		@mono varchar(11) ='',
		@line varchar(4) = '',
		@bono int = 0,
		@planStart datetime = null,
		@planQty integer = null ,
		@id BIGINT = 0,
		@createdBy varchar(20) ='',
		@sbuId int =  1,
		@isAutoAssignedPlanStart bit = 0,
		@isAutoPlanBalance bit = 0,
		@transId varchar(50) = ''
AS

	declare @prodType varchar(10), @prodMonth date, @moQty int, @custDelDt date,  @timeCreated datetime = getdate()
	declare  @active bit = 1
	declare @next_mo_plan_start datetime
	declare @insertId varchar(50)= newid()

	declare @moId bigint
	declare @mfgLocId integer
	declare @moPlannedQty integer = 0
	declare @moQtyPLanBalance int = 0
	declare @planBalance INTEGER

	if @transId = ''
			SET @transId = newid()

	IF OBJECT_ID(N'TEMPDB..#TMP_RESULTS') IS NOT NULL DROP TABLE #TMP_RESULTS
	CREATE TABLE #TMP_RESULTS
	(
		code VARCHAR(20),
		description VARCHAR(100),
		next_mo_plan_start datetime
	)

	BEGIN TRAN SAVE_PLANNING_V2_TRANS

		--IF EDIT
  if(@id > 0 )
	BEGIN
    select @mono = MONo, @line = line, @planQty = Plan_Qty, @sbuId = sbu_id, @mfgLoc = Mfg_Loc from BO_Hdr where id = @id

		if(datepart(hour, @planStart)) = 0 and @planStart is not null
		BEGIN
			SET @planStart =  dateadd(minute, 450,  cast ( CAST(@planStart as date) as  datetime ))
		END
		IF( @planStart is null )
		BEGIN
			SELECT  @planStart = dateadd(minute,1, max(plan_start)) from BO_Hdr where MONo = @mono
		END

	--DELETE THE DATA
		select @insertId = insert_id, @bono = BONo from BO_Hdr where id = @id
		--delete from BO_Hdr where id = @id
		delete from BO_Daily_Target where insert_id = @insertId and MONo = @mono
		--delete from BO_Daily_Target where MONo = @mono and BONo = @bono
	END

	-- GET ADDITIONAL MONO INFO
	select @moId = id, @prodType = prod_type, @prodMonth = prod_month, @moQty = (select sum(qty) from mo_det where mo_id = a.id ), @custDelDt=  cus_del_dt
	from mo_hdr a where mono = @mono

	--VALIDATE
	SELECT @mfgLocId  = id from m_mfg_locs where code = @mfgLoc
	select @moQty = isnull(sum(qty),0) from mo_det where mono = @mono and qty > 0
	select @moPlannedQty = isnull(sum(Plan_Qty),0) from BO_Hdr where MONo = @mono and id != @id;

	SET @moQtyPLanBalance = @moQty -  (@moPlannedQty + @planQty)

	--SET THE NEW PLAN BALANCE FROM THE MO QTY LESS PLANNED
	IF(@isAutoPlanBalance = 1 OR @planQty is null )
		BEGIN
			SET @planBalance  = (@moQty-@moPlannedQty)
		END

	IF ( @moPlannedQty = @moQty )
		BEGIN
			INSERT INTO #TMP_RESULTS (code, description, next_mo_plan_start)
			select code = 'error 1 ' + @mono , description = 'this mono is already zero balance. MoPlanned:' +  convert(varchar(20), @moPlannedQty) + ' vs moQty: ' +  convert(varchar(20), @moQty),return_value =null
			GOTO err;
			RETURN
		END

	-- VALIDATE. CHECK THE BALANCE
	IF (@moQtyPLanBalance < 0 )
		BEGIN
			INSERT INTO #TMP_RESULTS (code, description, next_mo_plan_start)
			select code = 'error 2 ' + @mono, description = 'please set your plan qty to ' + convert(varchar(12), @moQtyPLanBalance  ),return_value =null
			GOTO err;
			RETURN
		END

/*	if (EXISTS(select 1 from BO_Hdr where MONo = @mono and Line = @line and @planStart between Plan_Start and Plan_Finish  ))
		BEGIN
			SELECT 'error 3' as code, 'mono ' + @mono + ' with plan start ' + convert(varchar(20),@planStart) + ' and line '+ @line + ' is already exists.' as description,return_value =null
			return
		END
*/
	IF ( @planBalance = 0 )
		BEGIN
			INSERT INTO #TMP_RESULTS (code, description, next_mo_plan_start)
			select code = 'error 4 ' + @mono, description = 'no more balance to plan! total planned qty is ' + convert(varchar(12), @moPlannedQty),return_value =null
			GOTO err;
			RETURN
		END

	IF(NOT EXISTS(select top 1 1 from  dbo.m_line_mp where line_code=@line and eff_date<=@planStart order by eff_date desc))
		BEGIN
			INSERT INTO #TMP_RESULTS (code, description, next_mo_plan_start)
			select code = 'error 5 ' + @mono, description = 'Line manpower settings with effective date '
																					 + convert(varchar(20), @planStart) +' on line '+convert(varchar(20),@line) +' not found. '
															,return_value =null
			GOTO err;
			RETURN
		END

	IF(NOT EXISTS(select * from m_line_lc where code =@prodType and line_code =@line))
		BEGIN
			INSERT INTO #TMP_RESULTS (code, description, next_mo_plan_start)
			select code = 'error 6 ' + @mono, description = 'Learning curve settings with prod type '+convert(varchar(20),@prodType) +' and line '+convert(varchar(20),@line) +' not found.' ,return_value =null
			GOTO err;
			RETURN
		END

	IF( EXISTS(select 1 from mo_hdr where mono = @mono and plansmv <= 1 ))
		BEGIN
			INSERT INTO #TMP_RESULTS (code, description, next_mo_plan_start)
			select code = 'error 7  ' + @mono, description = 'Plan smv is less than or equal to 1.' , return_value =null
			GOTO err;
			RETURN
		END

	SET @insertId = newid()
	
	--INSERT INTO BO_HDR
	if(@id = 0)
	BEGIN
		
		--GET BONO AND next Plan start
		select top 1  @bono = bono, @next_mo_plan_start = next_mo_plan_start
		from AllocateDailyTarget(@mono, @line, @planQty, @planStart, 0)
		order by plan_start desc
			
		--INSERT INTO DAILY TARGET
		insert into BO_Daily_Target(MONo, BONo, Line, Mfg_Loc, plan_start, plan_finish, smv,  Date, Qty, original_daily_target, learning_curve, Trans_Id, sbu_id, active, Created_By, Time_Created, insert_id)
		select mono, @bono, line, @mfgLoc, plan_start, plan_finish, smv,  plan_start, daily_target_base_on_duration, daily_target, efficiency, @TransId as trans_id, @sbuId, @active, @createdBy, @timeCreated, @insertId
		from AllocateDailyTarget(@mono, @line, @planQty, @planStart, 0)

		insert into bo_hdr(id, MONo, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Plan_Start, Plan_Finish, Prd_Typ, Prod_Month, MO_Qty, MO_Cus_Del_Dt, Trans_Id, Trans_Dt, sbu_id, active, total_output_qty, Created_By, Time_Created, insert_id )
		select @id, MONo, BONo, @mfgLoc, Line, Plan_Qty = sum(daily_target_base_on_duration), SMV, Plan_Start = min(Plan_Start), Plan_Finish = max(Plan_Finish),
			@prodType, @prodMonth, @moQty, @custDelDt, @TransId, Trans_Dt =getdate(), @sbuId, @active, total_output_qty = 0, @createdBy, @timeCreated, @insertId
		from AllocateDailyTarget(@mono, @line, @planQty,  @planStart, 0)
		GROUP BY MONo, BONo, Line,SMV
	END
	ELSE
	BEGIN
		--UPDATE INTO BO_HDR
		declare @planStartx datetime
		declare @planFinishx datetime
		select @planStartx = min(Plan_Start), @planFinishx = max(Plan_Finish)
		from AllocateDailyTarget(@mono, @line, @planQty,  @planStart, 0)
		GROUP BY MONo, BONo, Line,SMV
		
		--INSERT INTO DAILY TARGET
		insert into BO_Daily_Target(MONo, BONo, Line, Mfg_Loc, plan_start, plan_finish, smv,  Date, Qty, original_daily_target, learning_curve, Trans_Id, sbu_id, active, Created_By, Time_Created, insert_id)
		select mono, @bono, line, @mfgLoc, plan_start, plan_finish, smv,  plan_start, daily_target_base_on_duration, daily_target, efficiency, @TransId as trans_id, @sbuId, @active, @createdBy, @timeCreated, @insertId
		from AllocateDailyTarget(@mono, @line, @planQty, @planStart, 0)

		update BO_Hdr set Plan_Start = @planStartx, Plan_Finish = @planFinishx, Trans_Id = @TransId, Trans_Dt = getdate(), insert_id = @insertId
		WHERE id = @id
	END


	--INSERT INTO BO_Learn_Curve
	DELETE FROM BO_Learn_Curve where MONo = @mono and BONo = @bono and Line = @line and sbu_id = @sbuId
	insert into BO_Learn_Curve(MONo, BONo, Line, Learn_Curve, Period_01, Period_02, Period_03, Period_04, Period_05, Period_06, Period_07, Period_08, Period_09, Period_10,
															Period_11, Period_12, Period_13, Period_14, Period_15, Period_16, Period_17, Period_18, Period_19, Period_20,
															Period_21, Period_22, Period_23, Period_24, Period_25, Period_26, Period_27, Period_28, Period_29, Period_30,
															Created_By, Time_Created, Updated_By, Trans_Id, Trans_Dt, Mfg_Loc, active, sbu_id, insert_id)
	select top 1 MONo = @mono, BONo = @bono, Line = @line, Learn_Curve, Period_01, Period_02, Period_03, Period_04, Period_05, Period_06, Period_07, Period_08, Period_09, Period_10,
															Period_11, Period_12, Period_13, Period_14, Period_15, Period_16, Period_17, Period_18, Period_19, Period_20,
															Period_21, Period_22, Period_23, Period_24, Period_25, Period_26, Period_27, Period_28, Period_29, Period_30,
															Created_By, Time_Created, Updated_By, @transId, @timeCreated, @mfgLoc, active, sbu_id, @insertId
	from m_line_lc
	WHERE line_code = @line and code = @prodType

	INSERT INTO #TMP_RESULTS (code, description, next_mo_plan_start)
	SELECT 'success' as code, description = 'successfully saved ' + @mono, return_value =  @next_mo_plan_start

IF(EXISTS(SELECT * FROM #TMP_RESULTS where code like 'error%'))
BEGIN
    GOTO err;
    RETURN
END

select * from  #TMP_RESULTS
COMMIT TRAN SAVE_PLANNING_V2_TRANS
return

err:
select * from  #TMP_RESULTS
ROLLBACK TRAN SAVE_PLANNING_V2_TRANS
go




CREATE PROCEDURE [dbo].[stg_ordUpdateMO_CP]
(
	@MONo		VARCHAR(50),
	@USERID		NVARCHAR(50)
)
--exec [ordUpdateMO_CPPo] '114799696','system'
--Select * from MOevents Where MONo = '42009005002'
AS

SET NOCOUNT ON 
	
BEGIN TRY

		--Update BO Events
		Exec stg_plnUpdateBObyMO_CPSew @MONo, @USERID
		Exec stg_plnUpdateMO_CP @MONo, @USERID

		--Update only the MOEvents
		EXEC stg_plnUpdateMO_CPPo @MONo, @USERID

		SELECT 0 AS [STATUS], 'UPDATED' AS ERROR_MSG

END TRY
BEGIN CATCH
	SELECT ERROR_MESSAGE()
END CATCH


go





CREATE procedure [dbo].[qconn_endline_report_top5_defects_lines]
	@datefrom varchar(10), @dateto varchar(10)
	, @topN varchar(2) = '5'
	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
--declare @datefrom date, @dateto date, @topnN integer = 4
	--set @datefrom = '01/01/2022'
	--set @dateto = '12/31/2023'
	IF OBJECT_ID(N'tempdb..##Tempdefectlist_lines ') IS NOT NULL
		BEGIN
			DROP TABLE ##Tempdefectlist_lines 
		END

	IF OBJECT_ID(N'tempdb..##Tempdefectlist_lines_1 ') IS NOT NULL
		BEGIN
			DROP TABLE ##Tempdefectlist_lines_1 
		END

		create table ##Tempdefectlist_lines ( tranyear integer, tranmonth integer, defectcount int, maxtransdt datetime, prodline varchar(50) );
		create table ##Tempdefectlist_lines_1 ( tranyear integer, tranmonth integer, defectcount int, maxtransdt datetime, prodline varchar(50) );

	 
		insert into ##Tempdefectlist_lines  
		select  year(a.transdt) as tran_year, month(a.transdt) as tran_month, count(1) as 'defect_count', max(transdt), prodline
		from endlineqcrfid a
		inner join endlineqcdet b on b.ptno = a.ptno and b.seq = a.seq
		inner join defecttypes c on c.defecttype = b.defecttype
		where cast(a.transdt as date) between @datefrom and @dateto
		group by year(a.transdt),month(a.transdt), prodline--, b.defecttype, c.desc1
			--order by year(a.transdt),month(a.transdt), 'defect_count' desc
	

--select * from ##Tempdefectlist order by desc1  

	DECLARE 
		@tranyear integer, 
		@tranmonth   integer;

	DECLARE cursor_year_month CURSOR
	FOR 
	select tranyear, tranmonth from ##Tempdefectlist_lines
	group by tranyear, tranmonth
	order by tranyear, tranmonth;

	OPEN cursor_year_month;

	FETCH NEXT FROM cursor_year_month INTO 
		@tranyear, 
		@tranmonth;

	WHILE @@FETCH_STATUS = 0
		BEGIN
			
			insert into ##Tempdefectlist_lines_1
			select top 5 *
			--tranyear, tranmonth
			--,max(defecttype), desc1 as description, sum(defectcount) as 'defectcnt', max(maxtransdt) 
			from ##Tempdefectlist_lines

			where tranyear = @tranyear and tranmonth = @tranmonth
			--group by tranyear, tranmonth, desc1
			order by defectcount desc 
		 
			FETCH NEXT FROM cursor_year_month INTO 
				@tranyear, 
				@tranmonth;
		END;

	CLOSE cursor_year_month;

	DEALLOCATE cursor_year_month;

	select id = (row_number() over (order by tranyear, tranmonth)),
	tranyear, tranmonth, FORMAT(maxtransdt,'MMM') as tranmonthname
	--,defecttype
	--, desc1 as defecttype
	, defectcount,prodline from ##Tempdefectlist_lines_1
	order by tranyear, tranmonth, defectcount desc

END
--and b.defecttype = 'FPK018'

--select * from endlineqcdet where createddt between '01/01/2023' and '01/31/2023' and defecttype = 'FPK018'
--order by 

--select * from defecttypes


go

CREATE FUNCTION [dbo].[fn_ConsecutiveNumbers]
(
    @start int,
    @end  int
) RETURNS TABLE
RETURN

select top 100 percent 
    x268435456.X
    | x16777216.X
    | x1048576.X
    | x65536.X
    | x4096.X
    | x256.X
    | x16.X
    | x1.X
    + @start
     X
from
(VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15)) as x1(X)
join
(VALUES (0),(16),(32),(48),(64),(80),(96),(112),(128),(144),(160),(176),(192),(208),(224),(240)) as x16(X)
on x1.X <= @end-@start and x16.X <= @end-@start
join
(VALUES (0),(256),(512),(768),(1024),(1280),(1536),(1792),(2048),(2304),(2560),(2816),(3072),(3328),(3584),(3840)) as x256(X)
on x256.X <= @end-@start
join
(VALUES (0),(4096),(8192),(12288),(16384),(20480),(24576),(28672),(32768),(36864),(40960),(45056),(49152),(53248),(57344),(61440)) as x4096(X)
on x4096.X <= @end-@start
join
(VALUES (0),(65536),(131072),(196608),(262144),(327680),(393216),(458752),(524288),(589824),(655360),(720896),(786432),(851968),(917504),(983040)) as x65536(X)
on x65536.X <= @end-@start
join
(VALUES (0),(1048576),(2097152),(3145728),(4194304),(5242880),(6291456),(7340032),(8388608),(9437184),(10485760),(11534336),(12582912),(13631488),(14680064),(15728640)) as x1048576(X)
on x1048576.X <= @end-@start
join
(VALUES (0),(16777216),(33554432),(50331648),(67108864),(83886080),(100663296),(117440512),(134217728),(150994944),(167772160),(184549376),(201326592),(218103808),(234881024),(251658240)) as x16777216(X)
on x16777216.X <= @end-@start
join
(VALUES (0),(268435456),(536870912),(805306368),(1073741824),(1342177280),(1610612736),(1879048192)) as x268435456(X)
on x268435456.X <= @end-@start
WHERE @end >=
    x268435456.X
    | isnull(x16777216.X, 0)
    | isnull(x1048576.X, 0)
    | isnull(x65536.X, 0)
    | isnull(x4096.X, 0)
    | isnull(x256.X, 0)
    | isnull(x16.X, 0)
    | isnull(x1.X, 0)
    + @start
  order by 1
go



CREATE PROCEDURE [dbo].[prdGetCalendarWeekDayDetSP] (@SBU_ID int, @UserID nvarchar(50))

AS  

BEGIN  
    
	SELECT
		Calendar as Calendar_Cd
		,Week_Name
		,Week_Day 
		,GUID as GUID
		,Time_From
		,Time_To
		,Time_Created
		,Created_By 
		,Time_Updated 
		,Updated_By 
	FROM 
		Calendar_Week_Day_Det
	ORDER BY 
		Calendar
		,Week_Day
		,Time_From
  
END


go

--select newid()
--select sum(qty) from mo_det where mono = '13572801001'
/*
exec usp_save_planning @mfgLoc= 'TARLAC',  @mono= '13133001001', @lineNo = 'L02',  @planQty= 200, @id = 0, @createdBy = 'Eduard', @sbuId = 1, @transId = '1AF314A5-E5D8-423A-B984-D53D6C66A197'
select * from bo_hdr where id = '31604'
*/ --31604, 31647
--exec usp_recalculate_planning @id = 31594, @createdBy = 'Eduard', @sbuId = 1
CREATE PROCEDURE usp_recalculate_planning
--declare
    @mfgLoc varchar(10) = 'TARLAC',
    @mono varchar(11) ='',
    @lineNo varchar(4) = '',
    @planStart datetime = null,
    @planQty integer = null ,
    @id BIGINT = 0,
    @createdBy varchar(20) ='',
    @sbuId int =  1,
    @isAutoAssignedPlanStart bit = 0,
    @isAutoPlanBalance bit = 0,
    @transId varchar(50) =  ''
AS

if @transId = ''
    set @transId = newid()

/*
SET @id = 31604
SET @sbuId  =  1
set @createdBy  =  'Eduard'
SET @isAutoAssignedPlanStart  = 0
*/

/*set @mono  = '13133001001'
set @lineNo = 'L02'
SET @mfgLoc   = 'TARLAC'
SET @planQty = 100
SET @isAutoAssignedPlanStart = 1
SET @isAutoPlanBalance = 1
SET @transId = newid()*/


declare @MAX_SCHEDULED_TIME_FINISH int = 15 --3PM. SET SOON
declare @planBalance INTEGER
declare @previosPlanBalance INTEGER
declare @dailyTarget INTEGER
declare @minutesTarget numeric(12,6) = 0
declare @actualPlanQty integer = 0
declare @TotalPlanQty integer = 0
declare @periodStart integer
declare @newPlanStart datetime
declare @planFinish datetime
declare @mfgLocId integer
declare @moId bigint


declare @efficiency numeric(4,2)
declare @manpower int
declare @workingMinutes int
declare @smv numeric(4,2)
declare @planStartMinutes integer = 0
declare @sheduleFinishBase datetime
declare @planStartBase datetime
declare @duration integer
-- declare @transId UNIQUEIDENTIFIER
declare @bono int
declare @timeCreated datetime = getdate()
declare @prodType varchar(20)
declare @prodMonth varchar(20)
declare @cusDelDt varchar(20)
declare @moQty int
declare @nextWorkingDate datetime
declare @moPlannedQty integer = 0
declare @moQtyPLanBalance int = 0

-- SET @mono = '13133001001'
-- SET @planQty = 500
-- SET @lineNo = 'L01'
-- SET @planStart = '2023-12-11 07:00:00.000'

declare @dateToCheck date = getdate()
declare @tempDate datetime = @dateToCheck
declare @DEFAULT_DATETIME datetime = dateadd(hour,7, @tempDate )

-- VALIDATE. CHECK THE BALANCE
IF NOT EXISTS( select 1 from BO_Hdr where id = @id )
BEGIN
  select code = 'error', description = 'Please pass the id to re calculate'
  RETURN
END

--SELECT THE PLAN ID AND GET THE QTY THEY ORIGINALY PLANNED AND RE PLAN EVERYTHING DUE TO POSSIBLE CHANGE OT DAILY TARGET
SELECT @planQty = Plan_Qty, @bono = BONo, @planStart = Plan_Start, @mono = MONo, @mfgLoc = @mfgLoc, @lineNo = Line
FROM BO_Hdr where id =  @id

-- calculate daily ouytput first
exec usp_allocate_daily_output @transId= @transId, @selMono = @mono,  @mgfLoc = 'TARLAC', @isRecalculate= 0, @userId = 'System'

--SET @isAutoAssignedPlanStart = 1
--GET THE PREVIOUS PLAN FINISH FOR THAT MO AND LINE exlude that ID
IF(@isAutoAssignedPlanStart = 1  )
BEGIN
  select @planStart = isnull(dateadd(minute, 1, max(Plan_Finish)), @DEFAULT_DATETIME ) from BO_Hdr where Line = @lineNo   and id != @id  and Plan_Start < @planStart
END
ELSE
BEGIN
  if (datepart(hh, @planStart) = 0 )
    SET @planStart = dateadd(hour,7, @planStart ) -- get the start of the day
END

--select @planStart test, @isAutoAssignedPlanStart, @planQty return

--BACKUP THE bo_hdr_hist DATA
INSERT INTO bo_hdr_hist (MONo, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Eff, EATM, Plan_Start, Plan_Finish, Actual_Start, Actual_Finish,
  Plant_Color, Prd_Typ, Prd_Typ2, Dif, Plant, MO_Qty, MO_Cus_Del_Dt, Completed, Created_By, Time_Created, Updated_By,
  Time_Updated, Completed_Remarks, Trans_Id, Trans_Dt, Process, Prod_Month, CP_No, active, sbu_id, code,
  description, total_planned_qty, total_output_qty)
SELECT MONo, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Eff, EATM, Plan_Start, Plan_Finish, Actual_Start, Actual_Finish,
  Plant_Color, Prd_Typ, Prd_Typ2, Dif, Plant, MO_Qty, MO_Cus_Del_Dt, Completed, Created_By, Time_Created, Updated_By,
  Time_Updated, Completed_Remarks, Trans_Id, Trans_Dt, Process, Prod_Month, CP_No, active, sbu_id, code,
  description, total_planned_qty, total_output_qty
FROM bo_hdr
WHERE MONo = @mono and BONo = @bono and Line = @lineNo

--BACKUP THE bo_daily_target_hist DATA
INSERT INTO bo_daily_target_hist(MONo, BONo, Line, date, Qty, Created_By, Time_Created, Updated_By, Time_Updated, Trans_Id, Trans_Dt,
  Mfg_Loc, sbu_id, Mfg_Loc_id, mo_id, plan_start, plan_finish, seq, smv, original_daily_target, actual_output_qty)
SELECT MONo, BONo, Line, date, Qty, Created_By, Time_Created, Updated_By, Time_Updated, Trans_Id, Trans_Dt,
  Mfg_Loc, sbu_id, Mfg_Loc_id, mo_id, plan_start, plan_finish, seq, smv, original_daily_target, actual_output_qty
from BO_Daily_Target
WHERE MONo = @mono and BONo = @bono and Line = @lineNo

-- THEN DELETE TO GIVE WAY TO THE NEW CALCUALTED DATA

-- IF EDITING and HAS ID PASSED. DELETE THE DATA
if(@id > 0)
BEGIN
--     declare @lineToDelete varchar(4)
--     select @mono = mono, @bono=bono, @lineToDelete= Line from BO_Hdr where id = @id
    delete from BO_Daily_Target where MONo = @mono and BONo = @bono and Mfg_Loc = @mfgLoc and Line = @lineNo
--     delete from BO_Hdr where id = @id
END

SET @planBalance = isnull(@planQty,0)
SET @periodStart = 1
SET @newPlanStart = @planStart

SELECT @mfgLocId  = id from m_mfg_locs where code = @mfgLoc
SELECT @moId = id, @prodType = prod_type, @prodMonth = prod_month, @cusDelDt = cus_del_dt from mo_hdr where mono = @mono
SELECT @moQty = isnull(sum(qty),0) from mo_det where mono = @mono and qty > 0
SELECT @moPlannedQty = isnull(sum(Plan_Qty),0) from BO_Hdr where MONo = @mono;
SET @moQtyPLanBalance = @moQty -  (@moPlannedQty + @planQty)

/*IF ( @moPlannedQty = @moQty )
BEGIN
  select code = 'error', description = 'this mono is already zero balance.'
  RETURN
END

-- VALIDATE. CHECK THE BALANCE
IF ( @moPlannedQty+@planBalance > @moQty )
BEGIN
  select code = 'error', description = 'please set your plan qty to ' + convert(varchar(12), @moQty-@moPlannedQty  )
  RETURN
END
*/

if (EXISTS(select 1 from BO_Hdr where MONo = @mono and Line = @lineNo and @planStart between Plan_Start and Plan_Finish and id != @id  ))
BEGIN
   SELECT 'error' as code, 'mono ' + @mono + ' with plan start ' + convert(varchar(20),@planStart) + ' and line '+ @lineNo + ' is already exists.' as description
    return
END

IF ( @planBalance = 0 )
BEGIN
  select code = 'error', description = 'no more balance to plan! total planned qty is ' + convert(varchar(12), @moPlannedQty)
  RETURN
END

IF(NOT EXISTS(select top 1 1 from  dbo.m_line_mp where line_code=@lineNo and eff_date<=@planStart order by eff_date desc))
BEGIN
  select code = 'error', description = 'Line manpower settings with effective date '
                                       + convert(varchar(20), @planStart) +' on line '+convert(varchar(20),@lineNo) +' not found. '
  RETURN
END

IF(NOT EXISTS(select * from m_line_lc where code =@prodType and line_code =@lineNo))
BEGIN
  select code = 'error', description = 'Learning curve settings with prod type '+convert(varchar(20),@prodType) +' and line '+convert(varchar(20),@lineNo) +' not found.'
  RETURN
END

BEGIN TRAN RECALCULATE_PLANNING_TRANS
--LOOP UNTIL NO BALANCE LEFT
while(@planBalance > 0)
-- while (@periodStart <= 5 )
BEGIN

    SET @sheduleFinishBase = dateadd(hour, @MAX_SCHEDULED_TIME_FINISH,'1900-01-01 00:00')
    SET @planStartBase = '1900-01-01 ' + format(@newPlanStart,'HH:mm')
    -- GET THE DURATION FROM PLAN START TO END OF SCHEDULE
    SET @duration = datediff(minute,@planStartBase, @sheduleFinishBase)

    SELECT
        @periodStart = period,
        @dailyTarget = manpower*working_minutes/smv*efficiency,
        @minutesTarget = (manpower*working_minutes/smv*efficiency)/working_minutes,
        @efficiency = efficiency,
        @manpower = manpower,
        @workingMinutes = working_minutes,
        @smv =smv,
        --@actualPlanQty = case when @planBalance >= @dailyTarget then @dailyTarget else @planBalance end,
        @planStartMinutes = (DATEPART(HOUR, @newPlanStart ) * 60) + DATEPART(MINUTE, @newPlanStart ),
        --1. PCS = TARGET QTY PER MINUTE TIMES REMAINING MINUTES OF THE DAY
        @actualPlanQty = ((manpower*working_minutes/smv*efficiency)/working_minutes) * @duration
    FROM (
        --1. Get the learning curve
        select code, period = period , efficiency,
            manpower = (select  top 1 manpower from ImappsV2.dbo.m_line_mp
                        where line_code =a.line
                        and eff_date<= @newPlanStart order by eff_date desc ),
            working_minutes = 480,
            smv = (select  plansmv from mo_hdr where mono = @mono )
        from view_mo_bo_learning_curve a
        where  line  = @lineNo  and mono = @mono and bono = @bono --and code = @prodType
        AND period = @periodStart
    ) A2

    --select @planStartMinutes planStartMinutes, @manpower manpower, @smv smv, @dailyTarget dailyTarget, @efficiency as efficiency

    if(@efficiency = 0)
    BEGIN
      select code = 'error', description = 'No setup efficiency on line ' + convert(varchar(20),@lineNo) +' with period ' + convert(varchar(20), @periodStart) +
      ' and prod type ' + @prodType
      goto err
      RETURN
    END

    --PCS = PLAN BALANCE
    --DURATION = now base on the REMAINING BALANCE
    IF(@planBalance <= @actualPlanQty)
    BEGIN
        SET @actualPlanQty = @planBalance
        SET @duration = @planBalance/@minutesTarget
    END

    SET @planBalance = @planBalance - @actualPlanQty
    SET @TotalPlanQty = @TotalPlanQty + @actualPlanQty

  -- TEMPORARY STORE THE PREVIOUS BALANCE
    SET @previosPlanBalance = @planBalance

    --IF PLAN BALANCE > 0. MEANS COMPLETE PLAN = TARGET. BUT WE NEED TO CONSIDER WHAT TIME IT STARTED TO PLAN.
    SET @planFinish =  dateadd(minute, @duration, @newPlanStart ) -- working_minutes = 540, 480 = 8 hours + 60 = 1 hours Break

  --CHECK VALUE HERE
     /*select @periodStart as periodStart, @planBalance as planBalance,@previosPlanBalance as previosPlanBalance, @TotalPlanQty TotalPlanQty,  @planQty planQty, @actualPlanQty as actualPlanQty,
            @duration as duration, @planStartBase planStartBase, @sheduleFinishBase sheduleFinishBase, @newPlanStart as newPlanStart,
            @nextWorkingDate nextWorkingDate, @planFinish as planFinish, originalDailyTarget = @dailyTarget*/

    --INSERT THE DAILY TARGET HERE
    INSERT INTO BO_Daily_Target(MONo, BONo, Line, Date, smv, seq, plan_start, plan_finish, Qty, original_daily_target,
                                Trans_Id, Trans_Dt, Mfg_Loc, sbu_id, Mfg_Loc_id, mo_id, Created_By, Time_Created )

    SELECT mono = @mono, bono = @bono, line_no = @lineNo, newPlanStart = @newPlanStart, smv= @smv, periodStart = @periodStart, newPlanStart = @newPlanStart, planFinish = @planFinish,
          actualPlanQty = @actualPlanQty, dailyTarget = @dailyTarget,
      transId = @transId, Trans_Dt = getdate(), mfgLoc = @mfgLoc, sbuId = @sbuId, mfgLocId = @mfgLocId, moId = @moId, createdBy=@createdBy, timeCreated= @timeCreated

    SET @nextWorkingDate  = dbo.getNextWorkingDate(@planFinish)

    -- GET NEXT DAY OR CONTINUE
    SET @newPlanStart = case when datepart(hour,@planFinish) >= @MAX_SCHEDULED_TIME_FINISH
      then @nextWorkingDate else  dateadd(minute, 1, @planFinish) end

    SET @periodStart = @periodStart + 1

END

--STEP 2: Summarize the data
-- DELETE FROM BO_Hdr where id = @id
--INSERT INTO BO_Hdr(sbu_id, MONo, MO_Qty, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Plan_Start, Plan_Finish, Prd_Typ, MO_Cus_Del_Dt, Prod_Month, Created_By, Time_Created, Trans_Id, active, total_planned_qty)
declare @maxPlanStart datetime
declare @maxPlanFinish datetime
declare @totalQty int

SELECT   @totalQty = sum(Qty), @maxPlanStart =  min(plan_start), @maxPlanFinish = max(plan_finish)
FROM BO_Daily_Target
WHERE MONo = @mono and Trans_Id = @transId

UPDATE BO_Hdr set Plan_Start =  @maxPlanStart, Plan_Finish = @maxPlanFinish, Plan_Qty = @totalQty, SMV = @smv, Trans_Id = @transId
WHERE id = @id

SELECT 'success' as code, 'succesfull planned!' as description, plan_finish = @planFinish

COMMIT TRAN RECALCULATE_PLANNING_TRANS
return

err:
ROLLBACK TRAN RECALCULATE_PLANNING_TRANS
go





CREATE procedure [dbo].[qconn_endline_report_top5_defects_styles]
	@datefrom varchar(10), @dateto varchar(10)
	, @topN varchar(2) = '5'
	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
--declare @datefrom date, @dateto date, @topnN integer = 4
	--set @datefrom = '01/01/2022'
	--set @dateto = '12/31/2023'
	IF OBJECT_ID(N'tempdb..##Tempdefectlist_style ') IS NOT NULL
		BEGIN
			DROP TABLE ##Tempdefectlist_style 
		END

	IF OBJECT_ID(N'tempdb..##Tempdefectlist_style_1 ') IS NOT NULL
		BEGIN
			DROP TABLE ##Tempdefectlist_style_1 
		END

		create table ##Tempdefectlist_style ( tranyear integer, tranmonth integer, defectcount int, maxtransdt datetime, styleno varchar(50) );
		create table ##Tempdefectlist_style_1 ( tranyear integer, tranmonth integer, defectcount int, maxtransdt datetime, styleno varchar(50) );

	 
		insert into ##Tempdefectlist_style  
		select  year(a.transdt) as tran_year, month(a.transdt) as tran_month, count(1) as 'defect_count', max(transdt), e.style_no
		from endlineqcrfid a
		inner join endlineqcdet b on b.ptno = a.ptno and b.seq = a.seq
		inner join defecttypes c on c.defecttype = b.defecttype
		inner join laying_pt d on a.ptno = d.ptno
		inner join mo_hdr e on e.mono = d.mono
		where cast(a.transdt as date) between @datefrom and @dateto
		group by year(a.transdt),month(a.transdt), e.style_no


--select * from ##Tempdefectlist order by desc1  

	DECLARE 
		@tranyear integer, 
		@tranmonth   integer;

	DECLARE cursor_year_month CURSOR
	FOR 
	select tranyear, tranmonth from ##Tempdefectlist_style
	group by tranyear, tranmonth
	order by tranyear, tranmonth;

	OPEN cursor_year_month;

	FETCH NEXT FROM cursor_year_month INTO 
		@tranyear, 
		@tranmonth;

	WHILE @@FETCH_STATUS = 0
		BEGIN
			
			insert into ##Tempdefectlist_style_1
			select top 5 *
			from ##Tempdefectlist_style
			where tranyear = @tranyear and tranmonth = @tranmonth
			--group by tranyear, tranmonth, desc1
			order by defectcount desc 
		 
			FETCH NEXT FROM cursor_year_month INTO 
				@tranyear, 
				@tranmonth;
		END;

	CLOSE cursor_year_month;

	DEALLOCATE cursor_year_month;

	select id = (row_number() over (order by tranyear, tranmonth)),
	tranyear, tranmonth, FORMAT(maxtransdt,'MMM') as tranmonthname
	, defectcount,styleno from ##Tempdefectlist_style_1
	order by tranyear, tranmonth, defectcount desc

END
--and b.defecttype = 'FPK018'

--select * from endlineqcdet where createddt between '01/01/2023' and '01/31/2023' and defecttype = 'FPK018'
--order by 

--select * from defecttypes


go

create function [dbo].[fn_GenerateNumbers]
(   
    @start int,
    @end  int
) returns table
return

with 
b0 as (select n from (values (0),(0x00000001),(0x00000002),(0x00000003),(0x00000004),(0x00000005),(0x00000006),(0x00000007),(0x00000008),(0x00000009),(0x0000000A),(0x0000000B),(0x0000000C),(0x0000000D),(0x0000000E),(0x0000000F)) as b0(n)),
b1 as (select n from (values (0),(0x00000010),(0x00000020),(0x00000030),(0x00000040),(0x00000050),(0x00000060),(0x00000070),(0x00000080),(0x00000090),(0x000000A0),(0x000000B0),(0x000000C0),(0x000000D0),(0x000000E0),(0x000000F0)) as b1(n)),
b2 as (select n from (values (0),(0x00000100),(0x00000200),(0x00000300),(0x00000400),(0x00000500),(0x00000600),(0x00000700),(0x00000800),(0x00000900),(0x00000A00),(0x00000B00),(0x00000C00),(0x00000D00),(0x00000E00),(0x00000F00)) as b2(n)),
b3 as (select n from (values (0),(0x00001000),(0x00002000),(0x00003000),(0x00004000),(0x00005000),(0x00006000),(0x00007000),(0x00008000),(0x00009000),(0x0000A000),(0x0000B000),(0x0000C000),(0x0000D000),(0x0000E000),(0x0000F000)) as b3(n)),
b4 as (select n from (values (0),(0x00010000),(0x00020000),(0x00030000),(0x00040000),(0x00050000),(0x00060000),(0x00070000),(0x00080000),(0x00090000),(0x000A0000),(0x000B0000),(0x000C0000),(0x000D0000),(0x000E0000),(0x000F0000)) as b4(n)),
b5 as (select n from (values (0),(0x00100000),(0x00200000),(0x00300000),(0x00400000),(0x00500000),(0x00600000),(0x00700000),(0x00800000),(0x00900000),(0x00A00000),(0x00B00000),(0x00C00000),(0x00D00000),(0x00E00000),(0x00F00000)) as b5(n)),
b6 as (select n from (values (0),(0x01000000),(0x02000000),(0x03000000),(0x04000000),(0x05000000),(0x06000000),(0x07000000),(0x08000000),(0x09000000),(0x0A000000),(0x0B000000),(0x0C000000),(0x0D000000),(0x0E000000),(0x0F000000)) as b6(n)),
b7 as (select n from (values (0),(0x10000000),(0x20000000),(0x30000000),(0x40000000),(0x50000000),(0x60000000),(0x70000000)) as b7(n))

select s.n
from (
    select
          b7.n
        | b6.n
        | b5.n
        | b4.n
        | b3.n
        | b2.n
        | b1.n
        | b0.n
        + @start
         n
    from b0
    join b1 on b0.n <= @end-@start and b1.n <= @end-@start
    join b2 on b2.n <= @end-@start
    join b3 on b3.n <= @end-@start
    join b4 on b4.n <= @end-@start
    join b5 on b5.n <= @end-@start
    join b6 on b6.n <= @end-@start
    join b7 on b7.n <= @end-@start
) s
where @end >= s.n
go







CREATE PROCEDURE [dbo].[prdGetMoDetSP] (@Mfg_Loc varchar(50), @UserID nvarchar(50))  

AS  

BEGIN  

	--SELECT TOP 10 * FROM MOHdr
	--SELECT TOP 10 * FROM BOHdr
	--SELECT TOP 10 CONVERT(VARCHAR(50),CPODt,21) as CPODt,* FROM MODet WHERE PODDt IS NOT NULL

	----FOR TESTING PURPOSE
--DECLARE @Mfg_Loc varchar(50), @UserID nvarchar(50)
--SET @Mfg_Loc = '2'
--SET @UserID = 'aj'

	SELECT 
		D.MONo
		--,D.ItemNo
		,D.CPO_No
		--,D.CPOItem
		--,D.CPODt
		--,D.CustStyle
		--,D.CustDesc
		--,D.CustColor
		--,D.CustSize
		--,D.CustDest
		--,D.ShipToCust
		--,D.StyleNo
		--,D.Color
		--,D.Size
		--,D.Dest
		--,D.Qty
		--,D.DlvDt
		--,D.PSDDt
		--,D.LPDDt
		--,D.SoldToCust
		--,D.BillToCust
		--,D.ShipMode
		--,D.GarmQty
		--,D.CMPrice
		--,D.ActQty
		--,D.Priority
		--,D.CONo
		,D.POD_Dt
		--,D.Remarks
		--,D.Webbing		
		--,D.CreatedBy
		--,D.CreatedDt
		--,D.UpdatedBy
		--,D.UpdatedDt
	FROM 
		MO_Det D
		LEFT OUTER JOIN MO_Hdr M on D.MONo = M.MONo
	WHERE
		--B.MONo IS NULL AND	
		M.Mfg_Loc = @Mfg_Loc
		AND M.active = 0
		--AND Completed = 0
		AND ISNULL(M.PlanSMV,0)	> 0
	GROUP BY
		D.MONo
		--,D.ItemNo
		,D.CPO_No
		--,D.CPOItem
		--,D.CPODt
		--,D.CustStyle
		--,D.CustDesc
		--,D.CustColor
		--,D.CustSize
		--,D.CustDest
		--,D.ShipToCust
		--,D.StyleNo
		--,D.Color
		--,D.Size
		--,D.Dest
		--,D.Qty
		--,D.DlvDt
		--,D.PSDDt
		--,D.LPDDt
		--,D.SoldToCust
		--,D.BillToCust
		--,D.ShipMode
		--,D.GarmQty
		--,D.CMPrice
		--,D.ActQty
		--,D.Priority
		--,D.CONo
		,D.POD_Dt
		--,D.Remarks
		--,D.Webbing		
		--,D.CreatedBy
		--,D.CreatedDt
		--,D.UpdatedBy
		--,D.UpdatedDt


END
go

--exec usp_get_plan_finish @planStart = '2023-12-05 10:47:00.000', @mono = '13572801001', @line = 'L01', @planQty = '94', @prodType = 'XBODY'
CREATE PROCEDURE usp_get_plan_finish_with_same_style
  @planStart datetime = null,
  @mono varchar(20) =  '14723301001',
  @line varchar(20) = 'L01',
  @planQty int = 1750,
  @prodType varchar(20) = 'BUS'
AS
/*declare @planStart datetime
declare @mono varchar(20) =  '14723301001'
declare @line varchar(20) = 'L01'
declare @prodType varchar(20) = 'BUS'
*/
if( @planStart is  null )
  select @planStart = max(Plan_Finish) from BO_Hdr where Line =  @line

SELECT A5.*,
    new_plan_finish =
        case when excess_minutes > 0 then
            dateadd(minute, excess_minutes, dateadd(hh, shedule_to_start,
                                                    dbo.DAYSADDNOWK(plan_finished, 1) --dateadd(day, 1, convert(datetime,convert(date,plan_finished)))
            ))
        else
          plan_finished
        end,
      last_bono = isnull((select max(convert(int,BONo)) from BO_Hdr where MONo = @mono),0),
      planned_qty = isnull((select sum(Plan_Qty) from BO_Hdr where MONo = @mono),0),
      mo_qty = (select sum(qty) from mo_det where MONo = @mono),
      mo_no = @mono
FROM
(
    SELECT *, (DATEPART(HOUR, plan_finished ) * 60) + DATEPART(MINUTE, plan_finished ) -
              (DATEPART(HOUR, shedule_to_finish ) * 60) + DATEPART(MINUTE, shedule_to_finish ) as excess_minutes
    FROM (
        -- 3. Plan Finish Computation
        select top 1 *, period_target + difference as target_output , target_per_hr = floor(period_target / 8),
            floor((period_target + difference) / floor(period_target / 8) * 60) as minutes_to_finish,
            (period_target + difference) / floor(period_target / 8) as hour_to_finish,
            plan_finished = dateadd(minute, plan_start_min + floor((period_target + difference) / floor(period_target / 8) * 60) ,  dbo.DAYSADDNOWK(plan_start , period -1 )), -- EXCLUDE SUNDAY
            shedule_to_start = 7, --FIXED 7AM IN
            shedule_to_finish = '01/01/1900 16:00' --FIXED 16:00 OUT
        from (
          -- 2. get the the per day target base on learning curve, smv and manpower
            select A2.*,
                period_target = ceiling(manpower*working_minutes/smv*efficiency),
                running_target = sum(ceiling(manpower*working_minutes/smv*efficiency))over(order by period),
                plan_qty = @planQty,
                difference = @planQty-sum(ceiling(manpower*working_minutes/smv*efficiency))over(order by period),
                plan_start =  @planStart,
                plan_start_min = (DATEPART(HOUR, @planStart ) * 60) + DATEPART(MINUTE, @planStart)
            FROM (
              --1. Get the learning curve
                select A.code, period = b.n , a.efficiency, a.manpower, working_minutes, a.smv
                from (
                    select top 1  *,
                      manpower = (select  top 1 manpower from ImappsV2.dbo.m_line_mp where line_code =a.line_code and eff_date<=@planStart order by eff_date desc ),
                      working_minutes = 480, --DEFAULT 8 HOURS
                      smv = (select  plansmv from mo_hdr where mono = @mono )
                    from view_learning_curve a
                    where line_code = @line  and code = @prodType --line_code = 'L01'  and code = 'XBODY' --where line_code = @line  and code = @prodType
                    order by efficiency desc -- GET MAX EFFICIENCY
                ) A
                CROSS JOIN
                  ( select n, row_number()over(order by n) row_number from  dbo.fn_GenerateNumbers(1, 100) ) B --MAX 100 DAYS TO PLAN and GET THE MAX EFFICIENCY IF THE NEXT STYLE IS THE SAME
              --where line_code = @line  and code = @prodType
            ) A2
        ) A3
        where plan_qty <running_target
        --order by period
    ) A4
) A5
go

--exec prdGetMoSP @MfgLoc='TARLAC', @startdisplay = 1, @User= '', @noOfRecords = 100
CREATE PROCEDURE [dbo].[prdGetMoSP] (@MfgLoc varchar(50), @User nvarchar(50),@startdisplay bigint = 1, @noOfRecords bigint = 100)
AS
BEGIN

	--SELECT TOP 10 * FROM MOHdr
	--SELECT TOP 10 * FROM BOHdr
	--SELECT TOP 10 CONVERT(VARCHAR(50),CPODt,21) as CPODt,* FROM MODet WHERE PODDt IS NOT NULL
	--SELECT * FROM MODet WHERE MONo = '790015601'


	----FOR TESTING PURPOSE
	--DECLARE @MfgLoc varchar(50), @User nvarchar(50)
	--SET @MfgLoc = 'TARLAC'
	--SET @User = 'aj'

	DECLARE @MLoc varchar(50)
	SET @MLoc = @MfgLoc

	DECLARE @LevelNo INT
	SELECT @LevelNo = Level_No FROM m_Mfg_Locs WHERE code = @MLoc


	INSERT INTO BO_Time_stamp(Mfg_Loc,Process,User_Id,[Time_stamp])
	VALUES(@MLoc,'Loading MO',@User,getdate())

	IF @LevelNo = 2 --Plant
	BEGIN
		SELECT  distinct
			I.Season as Season
			,(SELECT TOP 1 Sold_To_Cust FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0 ORDER BY Dlv_Dt) as [Sold_To_Cust]
			,M.MONo as MONo
			,M.IONo as IONo
			,(SELECT TOP 1 CPO_No FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) as 'CPO_No'
			,M.Split_No as Split_No
			,M.Remarks as Remarks
			,(SELECT TOP 1 Color FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) as Color
			,(SELECT TOP 1 Dest FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) as Destination
			,ISNULL((SELECT SUM(ISNULL(Qty,0)) FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo),0) as Qty
			,ISNULL((SELECT SUM(ISNULL(Qty,0)) FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo),0)-ISNULL((SELECT SUM(ISNULL(Plan_Qty,0)) FROM BO_Hdr WITH(NOLOCK) WHERE MONo = M.MONo),0) as Rem_Qty
			,CASE WHEN ISNULL((SELECT TOP 1 SMV FROM BO_Hdr WITH(NOLOCK) WHERE MONo = M.MONo),0) > 0 THEN ISNULL((SELECT TOP 1 SMV FROM BO_Hdr WITH(NOLOCK) WHERE MONo = M.MONo),0) ELSE ISNULL(M.PlanSMV,0) END as Plan_SMV
			,0 as Eff --DEFAULT TO 0 TO AVOID RECALC
			,CASE WHEN (SELECT count('x') FROM (SELECT distinct CPO_No, POD_Dt FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) A) > 1 THEN '...' ELSE (SELECT TOP 1 CPO_No FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) END as MO_Det
			,(SELECT TOP 1 Dlv_Dt FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0 ORDER BY Dlv_Dt) as Cus_Del_Dt
			,M.Rev_Ex_Fty_Dt as Req_Ex_Fty_Dt
			,getdate()-60 as ESS_Dt
			--,(SELECT TOP 1 POD_Dt-2 FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) as LSF_Dt
			,(SELECT TOP 1 dateadd(day, -2, convert(date, POD_Dt))  FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) as LSF_Dt

			,(SELECT TOP 1 Board_Color FROM m_Prod_Type WITH(NOLOCK) WHERE Prod_Type = M.Prod_Type) as Prod_Board_Color
			,M.Transit_Days as Transit_Days
			,M.Prod_Days as Prod_Days
			,M.Req_Prod_Start as Req_Prod_Start
			,M.Main_Mat_Lead as Main_Mat_Lead
			,M.Sub_Mat_Lead as Sub_Mat_Lead
			,M.Style_No as Style_Cd
			,M.Prod_Type as Prod_Type
			,M.Plant as Plant_Cd
			,M.Board_Color as Board_Color --'Color [A=255, R=127, G=17, B=6]' as BoardColor --
			,M.Created_By as Created_By
			,M.Time_Created as Time_Created
			,M.Updated_By as Updated_By
			,M.Time_Updated as Time_Updated
			,CASE WHEN B.BONo IS NOT NULL THEN 1 ELSE 0 END AS BO_Exist
			--,CASE WHEN (SELECT TOP 1 Compare_Val FROM m_mfg_locs WITH(NOLOCK) WHERE code = @MLoc) = 'StyleNo' THEN M.Style_No ELSE M.IONo END AS Compare_Val
			,null as MaterialDt
			,(SELECT TOP 1 POD_Dt FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) as POD_Dt
			,M.Prod_Month as Prod_Month
			,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH(NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Leather') as Mat_Leather_ETA
			,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH(NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Textile') as Mat_Tex_ETA
			,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH(NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Hardware') as Mat_Hrd_ETA
			,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH(NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Zipper') as Mat_Zip_ETA
			,CASE WHEN ISNULL((SELECT TOP 1 DATEDIFF(dd,Plan_Start,Actual_Start) FROM MO_Events WITH(NOLOCK) WHERE MONo = M.MONo and Actual_Start IS NOT NULL ORDER BY Plan_Start DESC),0) > 0
				THEN (SELECT TOP 1 DATEADD(dd, DATEDIFF(dd,A.Plan_Start,A.Actual_Start) , B.Plan_Start)--B.Plan_Start + DATEDIFF(dd,A.Plan_Start,A.Actual_Start)
						FROM MO_Events A WITH(NOLOCK) inner join MO_Events B WITH(NOLOCK) on A.MONo = B.MONo WHERE A.MONo = M.MONo and A.Actual_Start IS NOT NULL and B.VAP = 'SEW' ORDER BY A.Plan_Start DESC) ELSE NULL END as CP_Date

			--,ISNULL((SELECT TOP 1 Delays FROM iMAPPS.dbo.MOCODelaysvw WITH(NOLOCK) WHERE MONo = M.MONo),0) as PreDelay
			,PreDelay = 0
			----,CASE WHEN EXISTS(SELECT TOP 1 'x' FROM iMAPPS.dbo.StyleImage WHERE StyleNo = M.StyleNo and Img01 IS NOT NULL) THEN '...' ELSE '' END as [Image]
			,'' as [Image]
			,(SELECT TOP 1 IO_Ln FROM IO_Det WITH(NOLOCK) WHERE Item_No = (SELECT TOP 1 Item_No FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0)) as IO_Ln
		FROM
			IO_Hdr I WITH(NOLOCK)
			INNER JOIN MO_Hdr M WITH(NOLOCK) on I.IONo = M.IONo
			LEFT OUTER JOIN BO_Hdr B WITH(NOLOCK) on M.MONo = B.MONo

		WHERE
			----M.MfgLoc = @MLoc
			----AND
			M.Active = 1
			AND M.Plan_Completed = 0
			AND M.MO_Status NOT IN ('Complete','Cancelled')
			AND ISNULL(M.PlanSMV,0)	> 0
			AND I.Order_Type_id IN (2,4,3)--('IO','SO','SC')
			AND M.mono in (select distinct mono from MO_Mat_ETA) --tempora
			--AND ISNULL(M.SubOut,0) = 0
			----AND B.ActualFinish IS NULL
			--AND M.MONO = '15749901003'
		GROUP BY
			I.Season
			,M.MONo
			,M.IONo
			,M.Split_No
			,M.Remarks
			,M.Mfg_Loc
			,M.PlanSMV
			,M.Rev_Ex_Fty_Dt
			,M.Prod_Type
			,M.Transit_Days
			,M.Prod_Days
			,M.Req_Prod_Start
			,M.Main_Mat_Lead
			,M.Sub_Mat_Lead
			,M.Style_No
			,M.Plant
			,M.Board_Color
			,M.Created_By
			,M.Time_Created
			,M.Updated_By
			,M.Time_Updated
			,B.BONo
			,M.Prod_Month

		order by I.Season
			,M.MONo, M.IONo, M.Split_No
			--OFFSET @startdisplay ROWS FETCH NEXT @noOfRecords ROWS ONLY
	END

/*
	IF @LevelNo = 3 --VAPS i.e. CUTTING, HT, EMBR etc
	BEGIN
		SELECT distinct
			M.MONo as MONo
			,M.IONo as IONo
			,(SELECT TOP 1 CPONo FROM iMAPPS.dbo.MODet WHERE MONo = M.MONo and Qty > 0) as CPONo
			,M.SplitNo as SplitNo
			,M.Remarks as Remarks
			,(SELECT TOP 1 Color FROM iMAPPS.dbo.MODet WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) as Color
			,(SELECT TOP 1 Dest FROM iMAPPS.dbo.MODet WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) as Destination
			,ISNULL(SUM(B.PlanQty),0) as Qty
			,ISNULL(SUM(B.PlanQty),0)-ISNULL((SELECT SUM(ISNULL(PlanQty,0)) FROM iMAPPS.dbo.BOHdr WITH(NOLOCK) WHERE MONo = M.MONo and MfgLoc = @MLoc),0) as RemQty
			,B.SMV AS PlanSMV
			,0 as Eff --DEFAULT TO 0 TO AVOID RECALC
			,CASE WHEN (SELECT count('x') FROM (SELECT distinct CPONo, PODDt FROM iMAPPS.dbo.MODet WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) A) > 1 THEN '...' ELSE (SELECT TOP 1 CPONo FROM iMAPPS.dbo.MODet WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) END as MODet
			,(SELECT TOP 1 DlvDt FROM iMAPPS.dbo.MODet WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0 ORDER BY DlvDt) as CusDelDt
			,M.RevExFtyDt as ReqExFtyDt
			,getdate()-60 as ESSDt
			,(SELECT TOP 1 DATEADD(dd, DATEDIFF(dd, 0, PlanStart), 0)-1 FROM iMAPPS.dbo.BOHdr WITH(NOLOCK) WHERE MONo = M.MONo and MfgLoc = (Select TOP 1 ParentMfgLoc from MfgLocs WITH(NOLOCK) where MfgLoc = @MLoc) ORDER BY PlanStart) as LSFDt
			,(SELECT TOP 1 BoardColor FROM iMAPPS.dbo.ProdTypes WITH(NOLOCK) WHERE ProdType = M.ProdType) as ProdBoardColor
			,M.TransitDays as TransitDays
			,M.ProdDays as ProdDays
			,M.ReqProdStart as ReqProdStart
			,M.MainMatLead as MainMatLead
			,M.SubMatLead as SubMatLead
			,M.StyleNo as StyleCd
			,M.ProdType as ProdType
			,M.Plant as PlantCd
			,M.BoardColor as BoardColor --'Color [A=255, R=127, G=17, B=6]' as BoardColor --
			,M.CreatedBy as CreatedBy
			,M.CreatedDt as CreatedDt
			,M.UpdatedBy as UpdatedBy
			,M.UpdatedDt as UpdatedDt
			,1 AS BoExist
			,CASE WHEN (SELECT TOP 1 CompareVal FROM iMAPPS.dbo.MfgLocs WITH(NOLOCK) WHERE MfgLoc = @MLoc) = 'StyleNo' THEN StyleNo ELSE IONo END AS CompareVal
			,null as MaterialDt
			,(SELECT TOP 1 PODDt FROM iMAPPS.dbo.MODet WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) as PODDt
			,M.ProdMonth as ProdMonth
			,(SELECT TOP 1 LatestETA FROM MOMatETA WITH(NOLOCK) WHERE MONo = M.MONo and MatTyp = 'Leather') as MatETA
			,(SELECT TOP 1 LatestETA FROM MOMatETA WITH(NOLOCK) WHERE MONo = M.MONo and MatTyp = 'Textile') as MatTexETA
			,(SELECT TOP 1 LatestETA FROM MOMatETA WITH(NOLOCK) WHERE MONo = M.MONo and MatTyp = 'Hardware') as MatHrdETA
			,(SELECT TOP 1 LatestETA FROM MOMatETA WITH(NOLOCK) WHERE MONo = M.MONo and MatTyp = 'Zipper') as MatZipETA
			,null as CPDate
			,0 as PreDelay
			,CASE WHEN EXISTS(SELECT TOP 1 'x' FROM iMAPPS.dbo.StyleImage WITH(NOLOCK) WHERE StyleNo = M.StyleNo and Img01 IS NOT NULL) THEN '...' ELSE '' END as [Image]
			,(SELECT TOP 1 IOLn FROM iMAPPS.dbo.IODet WITH(NOLOCK) WHERE ItemNo = (SELECT TOP 1 ItemNo FROM iMAPPS.dbo.MODet WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0)) as IOLn
		FROM
			MOHdr M WITH(NOLOCK)
			INNER JOIN
			BOHdr B WITH(NOLOCK)
			on M.MONo = B.MONo and M.MfgLoc = B.MfgLoc
			inner join (Select gv.GVAP, ml.MfgLoc, gv.Duration, gv.SMV from GVAP gv WITH(NOLOCK) inner join MfgLocs ml on gv.GVAP = ml.GVAP) as G on @MLoc = G.MfgLoc
		WHERE
			M.MfgLoc IN (SELECT MfgLoc FROM MfgLocs WHERE Location IN (SELECT Location FROM MfgLocs WHERE MfgLoc IN (SELECT ParentMfgLoc FROM MfgLocs WHERE MfgLoc = @MLoc)))
			AND M.Deleted = 0
			AND ISNULL(B.SMV,0)	> 0
			AND ISNULL(M.SubOut,0) = 0
			AND M.MOStatus NOT IN ('Complete','Cancelled')
			AND M.MONo NOT IN (SELECT MONo FROM BOHdr WITH(NOLOCK) WHERE MfgLoc IN (SELECT DISTINCT A.MfgLoc FROM MfgLocs A WITH(NOLOCK) inner join MfgLocs B WITH(NOLOCK) on A.GVAP = B.GVAP WHERE
					A.Location = (SELECT TOP 1 Location FROM MfgLocs WITH(NOLOCK) WHERE MfgLoc = @MLoc)
					and A.GVAP = (SELECT TOP 1 GVAP FROM MfgLocs WITH(NOLOCK) WHERE MfgLoc = @MLoc)
					and A.MfgLoc <> @MLoc))
		GROUP BY
			M.MONo
			,M.MfgLoc
			,M.IONo
			,M.SplitNo
			,M.Remarks
			,M.ProdType
			,M.StyleNo
			,M.MONo
			,M.CusDelDt
			,M.RevExFtyDt
			,M.PlanSMV
			,M.Eff
			,M.ESSDt
			,M.LSFDt
			,M.BoardColor
			,M.StyleNo
			,M.TransitDays
			,M.ProdDays
			,M.ReqProdStart
			,M.MainMatLead
			,M.SubMatLead
			,M.Plant
			,M.BoardColor
			,M.CreatedBy
			,M.CreatedDt
			,M.UpdatedBy
			,M.UpdatedDt
			--,B.BONo
			,B.SMV
			--,B.PlanStart
			,M.ProdMonth
	END
*/

END
go

CREATE FUNCTION dbo.GetHolidayDates()
RETURNS @holiday_dates TABLE (holiday_name varchar(255), holiday_date DATE)
AS
BEGIN


  WITH cte_dates AS (
    SELECT holiday_name = description, holiday_from = date_from, holiday_to = date_to, date_from AS holiday_date
    FROM m_line_mp_exception

    UNION ALL

    SELECT holiday_name, holiday_from, holiday_to, DATEADD(day, 1, holiday_date)
    FROM cte_dates
    WHERE holiday_date < holiday_to
  )

  INSERT INTO @holiday_dates(holiday_name, holiday_date)
  SELECT holiday_name, holiday_date
  FROM cte_dates
  ORDER BY holiday_name, holiday_date

  RETURN;
END
go

CREATE procedure usp_download_asnxfga_with_delete
  @pono varchar(20) = ''
as
  --set @pono = 'POC22Q2JT0300250'

declare @poid varchar(20)
select @poid = POID from tmp.dbo.btPurchaseOrders where PONumber  = @pono


--2. delete all tables affected for orders
delete from fg_carton_allocation where carton_id in (select id from fg_carton where purchase_order_dtl_id in (select id from fg_purchase_order_dtl where purchase_order_id in (select id from fg_purchase_order where pono = @pono)))
delete from fg_carton where purchase_order_dtl_id in (select id from fg_purchase_order_dtl where purchase_order_id in (select id from fg_purchase_order where pono = @pono ))
delete from fg_purchase_order_dtl where purchase_order_id in (select id from fg_purchase_order where pono =@pono )
delete from fg_purchase_order where pono = @pono

--3. Get all the data from scanpack
-- declare @pono varchar(20) = 'POC22Q2JT0300250'
-- declare @poid varchar(20)
-- select @poid = POID from tmp.dbo.btPurchaseOrders where PONumber  = @pono

/* 4. Download Purchase Order*/
insert into ImappsV2.dbo.fg_purchase_order(
  active, created_by, sbu_id, time_created, time_updated, updated_by,
  asn_no, booking_no, code, color_desc_cn, color_desc_en, customer_order_no, delivery_seq,
  description, ex_fty_date, invoice_no, iono, order_qty, pono, rev_ex_fty_date,
  revised_style_code, ship_date, ship_mode, ship_to, ship_to_remarks, store_code, style_code, vendor, factory, buyer, status_code)
select
    active = 1, created_by ='System', sbu_id = 1, time_created = getdate(), time_updated = null , updated_by = null,
    asn_no = '', booking_no = '', code = POID, color_desc_cn = '', color_desc_en = '', customer_order_no ='', delivery_seq = '',
    description = '', ex_fty_date = '', invoice_no = '', iono = POID, order_qty =0, pono = PONumber, rev_ex_fty_date = '',
    revised_style_code = '', ship_date = null , ship_mode = null, ship_to = null , ship_to_remarks = null , store_code = '',
    style_code = '', vendor = '', factory = FacLocCode, BuyerCode, StatusCode
from tmp.dbo.btPurchaseOrders
where POID = @poid

-- 5. Download Order Details
insert into ImappsV2.dbo.fg_purchase_order_dtl(
    active, created_by, sbu_id, time_created, time_updated, updated_by,
    asn_date, asn_no, booking_no, carrier_code,  eta,
    etd, factory_loc_code, invoice_date, invoice_no, ship_date,
  shipment_code, shipper_code, split_no, purchase_order_id, POID)

select active = 1, created_by ='System', sbu_id = 1, time_created = getdate(), time_updated = null , updated_by = null,
  asn_date = b.ASNDate, asn_no = b.ASNNo, booking_no = b.BookingNo, carrier_code=b.CarrierCode,  eta = b.ETA,
  etd = b.ETD, factory_loc_code = b.FacLocCode, invoice_date = b.InvoiceDate, invoice_no = b.InvoiceNo, ship_date = b.ShipDate,
  shipment_code = b.ShipmentCode, shipper_code = b.ShipperCode, split_no = a.SplitNo,
  purchase_order_id = (select id from ImappsV2.dbo.fg_purchase_order where pono COLLATE DATABASE_DEFAULT = c.PONumber COLLATE DATABASE_DEFAULT ),
  a.POID
from tmp.dbo.btPOSplits a
left outer join  tmp.dbo.btShipments b on a.POID = b.POID and a.SplitNo = b.SplitNo
inner join tmp.dbo.btPurchaseOrders c on a.POID = c.POID
where a.POID = @poid
--and c.POID not in (select POID   COLLATE DATABASE_DEFAULT from ImappsV2.dbo.fg_purchase_order_dtl where POID = 'TWF0003250')

--6. GET Packing List First to use for cartons and carton allocations
DELETE FROM tmp.dbo.packing_list where POID = @poid
insert into tmp.dbo.packing_list(POID, SplitNo, PONumber, CartonNo, UCCNo, Style, Color, POShade, POQuality, Size, Qty, SizeSort, Packtype, Weight, AccWeight, CartonWeight, Length, Width, Height, CBM)
SELECT A.POID, b.SplitNo, A.PONumber, E.CartonNo
, E.UCCNo as UCCNo
, M.Style, M.Color, ISNULL(Y.Infocode,'') as POShade , ISNULL(Z.InfoCode,'1') as POQuality
,M.Size, F.PackedQty  AS Qty, O.SizeSort, Case When G.UserCreated = 1 then 'SLD' else UPPER(J.PackType) end as Packtype
,convert(numeric(14,6), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = M.WeightUOM and ToUOMCode = 'KG' ) * M.Weight,0))  as Weight
,convert(numeric(14,6), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = M.WeightUOM and ToUOMCode = 'KG' ) * M.AccWeight,0)) as AccWeight
,convert(numeric(14,6), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = I.WeightUOM and ToUOMCode = 'KG' ) * I.Weight,0)) as CartonWeight
,convert(numeric(12,0), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = I.DimensionUOM and ToUOMCode = 'MM') * I.Length, 0)) as Length
,convert(numeric(12,0), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = I.DimensionUOM and ToUOMCode = 'MM') * I.Width, 0)) as Width
,convert(numeric(12,0), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = I.DimensionUOM and ToUOMCode = 'MM') * I.Height, 0)) as Height
,convert(numeric(14,6), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = I.VolumeUOM and ToUOMCode = 'CR') * I.Volume,0)) as CBM
FROM (Select * FROM tmp.dbo.btPurchaseOrders Where POID = @poid ) A
INNER JOIN (Select * FROM tmp.dbo.btPOSplits Where POID = @poid  ) B ON A.POID = B.POID
LEFT JOIN (Select * FROM tmp.dbo.btShipments Where POID = @poid  ) C ON B.POID = C.POID AND B.SplitNo = C.SplitNo
LEFT JOIN (Select * FROM tmp.dbo.btCartons Where POID = @poid  ) E ON B.POID = E.POID AND B.SplitNo = E.SplitNo
LEFT JOIN (Select * FROM tmp.dbo.btCartonitems Where POID = @poid  ) F ON E.POID = F.POID AND E.SplitNo = F.SplitNo AND E.CartonNo = F.CartonNo -- for mixed cartons
LEFT JOIN (Select * FROM tmp.dbo.btSplititems Where POID = @poid  ) D ON F.POID = D.POID AND F.SplitNo = D.SplitNo  AND F.SplitItemNo = D.SplitItemNo
LEFT JOIN (Select * FROM tmp.dbo.btPackingDefinition Where POID = @poid  ) G ON F.POID = G.POID AND F.SplitNo = G.SplitNo AND F.PackDefID = G.PackDefID
LEFT JOIN (Select * FROM tmp.dbo.btPackDefItems Where POID = @poid  ) H ON F.POID = H.POID AND F.SplitNo = H.SplitNo AND F.PackDefID = H.PackDefID AND F.SplititemNo = H.SplititemNo
INNER JOIN tmp.dbo.btCartonTypes I ON E.CtnTypeCode = I.CtnTypeCode
INNER JOIN (Select * FROM tmp.dbo.btCartonTemplates Where POID = @poid  ) J ON E.POID = J.POID AND E.SplitNo = J.SplitNo AND E.CtnTmpCode = J.CtnTmpCode
LEFT JOIN (Select * FROM tmp.dbo.btProducts Where POID = @poid) M ON  D.ProductID = M.ProductID AND D.POID = M.POID
LEFT JOIN tmp.dbo.btStores N ON E.FacLocCode = N.FacLocCode AND E.StoreCode = N.StoreCode
LEFT JOIN tmp.dbo.btSizeHierarchy O ON  M.FacLocCode = O.FacLocCode AND M.Size = O.SizeCode
LEFT JOIN (Select * FROM tmp.dbo.btProductInfo Where POID = @poid  ) Y ON D.POID = Y.POID and  D.SplitNo = Y.SplitNo and  D.SplitItemNo = Y.SplitItemNo and Y.InfoQualifier = 'SHD'
LEFT JOIN (Select * FROM tmp.dbo.btProductInfo Where POID = @poid  ) Z ON D.POID = Z.POID and  D.SplitNo = Z.SplitNo and  D.SplitItemNo = Z.SplitItemNo and Z.InfoQualifier = 'QLT'
WHERE A.POID = @poid

--7. INSER INTO CARTON
insert into ImappsV2.dbo.fg_carton(active, created_by, sbu_id, time_created, time_updated, updated_by,
                                   purchase_order_id, ucc_barcode, carton_no, carton_qty,
                                   length, width, height, gross_weight, net_weight, nnw , purchase_order_dtl_id, split_no
)
select active = 1, created_by ='System', sbu_id = 1, time_created = getdate(), time_updated = null , updated_by = null,
    purchase_order_id = (select id from ImappsV2.dbo.fg_purchase_order where pono COLLATE DATABASE_DEFAULT = a.PONumber COLLATE DATABASE_DEFAULT ),
    ucc_barcode = a.UCCNo, carton_no = CartonNo, carton_qty = sum(Qty),
    length, width, height, gross_weight = 0, net_weight = 0 , nnw = 0,
    purchase_order_dtl_id = (select id from ImappsV2.dbo.fg_purchase_order_dtl where POID  COLLATE DATABASE_DEFAULT = a.POID COLLATE DATABASE_DEFAULT and split_no = a.SplitNo ),
    SplitNo
from  tmp.dbo.packing_list a
WHERE POID = @poid
group by length, width, height,a.UCCNo,CartonNo, a.PONumber, a.POID, a.SplitNo
order by a.PONumber, carton_no

--8. INSERT INTO CARTON ALLOCATION
INSERT INTO ImappsV2.dbo.fg_carton_allocation(
  active, created_by, sbu_id, time_created, time_updated, updated_by,
  color, qty, size, sku, style, upc_barcode, carton_id, split_no)

select active = 1, created_by ='System', sbu_id = 1, time_created = getdate(), time_updated = null , updated_by = null,
      color, qty, size, sku = '', style, upc_barcode = '',
      carton_id  = (SELECT ID FROM fg_carton WHERE carton_no  = A.CartonNo AND purchase_order_id   = (SELECT ID FROM fg_purchase_order WHERE CODE COLLATE DATABASE_DEFAULT = A.POID COLLATE DATABASE_DEFAULT )),
      a.SplitNo
from  tmp.dbo.packing_list a
WHERE POID = @poid

SELECT code = 'success', description = 'success'
go

CREATE FUNCTION [dbo].[fn_GetNoOfSundayUsingLoop]
(@DateFrom DATE,
@DateTo   DATE
)
RETURNS INT
AS
--declare @DateFrom DATE = '03/01/2023',
--@DateTo   DATE = '03/20/2023'
     BEGIN
         DECLARE @TotWorkingDays INT= 0;
         WHILE @DateFrom <= @DateTo
             BEGIN
                 IF DATENAME(WEEKDAY, @DateFrom) IN('Sunday')
                     BEGIN
                         SET @TotWorkingDays = @TotWorkingDays + 1;
                 END;
                 SET @DateFrom = DATEADD(DAY, 1, @DateFrom);
             END;
         RETURN @TotWorkingDays;
		 --select @TotWorkingDays
     END;
go

CREATE FUNCTION dbo.GetSundaysAndHolidaysInRange
(
    @StartDate DATE,
    @EndDate DATE
)
RETURNS @Result TABLE (DateValue DATE)
AS
BEGIN
    WITH cte AS (
        SELECT @StartDate AS DateValue
        UNION ALL
        SELECT DATEADD(day, 1, DateValue) AS DateValue
        FROM cte
        WHERE DateValue < @EndDate
    )
    INSERT INTO @Result
    SELECT DateValue
    FROM cte
    WHERE DATENAME(dw, DateValue) = 'Sunday'
        OR DateValue IN (
            SELECT holiday_date FROM dbo.GetHolidayDates() WHERE holiday_date BETWEEN @StartDate AND @EndDate
        )
    RETURN
END
go



create PROCEDURE [dbo].[prdGetBoDailyOutputSP] (@MfgLoc varchar(50), @User nvarchar(50))  

AS  

BEGIN  
    
	SELECT
		D.MONo as MONo
		,D.BONo as BONo
		,D.Line as LineCd
		,DATEADD(dd, DATEDIFF(dd, 0, D.[Date]), 0) as [Date]
		,SUM(D.Qty) as Qty
		,D.Target_Qty as Target_Qty
		--,D.CreatedBy as CreatedBy
		--,D.CreatedDt as CreatedDt
		--,D.UpdatedBy as UpdatedBy
		--,D.UpdatedDt as UpdatedDt	
	FROM 
		BO_Daily_Output D
		INNER JOIN BO_Hdr H on D.MONo = H.MONo and D.BONo = H.BONo
	WHERE
		H.Mfg_Loc = @MfgLoc AND H.Completed = 0
		AND D.Line IN (SELECT Prod_Line FROM m_Prod_Lines WHERE Mfg_Loc = @MfgLoc)	
	GROUP BY
		D.MONo
		,D.BONo
		,D.Line
		,DATEADD(dd, DATEDIFF(dd, 0, D.[Date]), 0)
		,D.Target_Qty
	ORDER BY
		D.Line 
		,D.MONo
		,D.BONo
		,DATEADD(dd, DATEDIFF(dd, 0, D.[Date]), 0)
  
END
go

CREATE PROCEDURE [dbo].[prdSyncOB] (
	@pMONo As Varchar(20) = '',
	@psMONo As Varchar(20) ='',
	@pUserId As Varchar(20) =''
)
	/*
	exec prdSyncOB '13665701002','13894901001','juvenal'
	exec prdSyncOB '13665701002','13665701002','juvenal'
	exec prdSyncOB '13665701002','13894901001','juvenal'
	*/

	--fromMono=13665701002&toMono=13665701001&toMono=13665701002&toMono=13894901001
AS

Begin

--begin transaction
			Set Nocount on
			--declare @pMONo As Varchar(20) = '', @psMONo As Varchar(20) = '', @pUserId As Varchar(20)
			Declare
			@MONo As Varchar(20) = @pMONo,
			@sMONo As Varchar(20) = @psMONo,
			@UserId As Varchar(20) = @pUserId
	
		declare @moid bigint

		select @moid  = id from mo_hdr where mono = @MONo
	
			if (select mo_status from mo_hdr where mono = @MONo) = 'OB'
				begin
					select 'OB already available for this MONo - ' + @MONo as description, 'error' as code
					return
				end
			declare @sbu_id int = 1
			--Declare @MONo As Varchar(20)
			--Declare @sMONo As Varchar(20)
			--Declare @UserId As Varchar(20)

			--Set @MONo = '790013902'
			--Set @UserId = 'edgar'
			--Select * from OB Where MONo Like '%7900139%'
			--Select * From WorkersOutputDet
			Declare @OrdQty	INT,@SewQty INT,@wOB BIT = 0

			Select @OrdQty = Sum(Qty) From Mo_det with(nolock) Where MONo = @MONo
			Select @SewQty = Sum(Qty) From Wip_Scan with(nolock) Where MONo = @MONo AND VAP = 'ASSY-PPCK' AND SVAP = 'ISS'


			--IF NOT EXISTS(SELECT TOP 1 'X' FROM LAYINGHDR WHERE MONO = @MONO AND [STATUS] = 'G')
			IF(ISNULL(@OrdQty,0) > ISNULL(@SewQty,0))
			BEGIN

			If Exists (Select top 1  'x' From Workers_Output_Det with(nolock) Where MONo = @MONo)
			Begin
				-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				--delete records that does exists from the source MO
					If exists(Select TOP 1 'X' from OB with(nolock) Where MONo = @MONo) Begin Set @wOB = 1 End
					--remarks by donel Delete From OBSMVHdr Where MONo = @MONo
					Delete From OB_SMV_Det Where MONo = @MONo And Operation Not In (Select Operation From Workers_Output_Det with(nolock) Where MONo = @MONo)
					Delete From OB_Group_Operations Where MONo = @MONo And Operation Not In (Select Operation From Workers_Output_Det with(nolock)  Where MONo = @MONo)
					Delete From OB_Group_WorkSections Where MONo = @MONo And Group_Name Not In (Select Group_Name From OB_Group_Operations with(nolock)  Where MONo = @MONo And Operation In (Select Operation From Workers_Output_Det   with(nolock)  Where MONo = @MONo))
					Delete From OB_Group_Hdr Where MONo = @MONo And Group_Name Not In (Select Group_Name From OB_Group_Operations  with(nolock)  Where MONo = @MONo And Operation In (Select Operation From Workers_Output_Det  with(nolock)  Where MONo = @MONo))
					Delete From OB_Spare_BT Where MONo = @MONo
					--remarks by donel Delete From OBShellNo Where MONo = @MONo
					Delete From OB Where MONo = @MONo And Operation Not In (Select Operation From Workers_Output_Det   with(nolock)  Where MONo = @MONo)
				-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

				-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				--insert new record from the source MO
					Insert Into OB (sbu_id,MONo,Feature,Operation,Seq,Split,VAP,SVAP,smv,Target_Output,price_per_pc,Active--remarks by donel ,Added_Opn
					,Difficulty,Remarks,Style_No,smv2,Escalation,WBT,
									Deleted,Created_By,time_Created,Updated_By,time_Updated , feature_desc, operation_Desc
									--remarks by donel ,Approved,Approved_By,time_Approved
									,Sync_Fr,Sync_By,time_Sync,Machine)
					Select @sbu_id,@MONo,Feature,Operation,Seq,Split,VAP,SVAP,smv,Target_Output,price_per_pc,Active--remarks by donel ,AddedOpn
					,Difficulty,Remarks,Style_No,smv2,Escalation,WBT,
									Deleted,Created_By,time_Created,Updated_By,time_Updated
									--remarks by donel,Approved,ApprovedBy,ApprovedDt
									,@sMONo,@UserId,Getdate(),Machine , feature_desc, operation_Desc
					From OB
					Where MONo = @sMONo
						And Operation Not In (Select Operation From OB Where MONo = @MONo)

					Insert Into OB_Spare_BT (MONo,Feature,Spare_BT,Shell_No,active,Created_By,time_Created,Updated_By,time_Updated)
					Select @MONo,Feature,Spare_BT,Shell_No,active,Created_By,time_Created,Updated_By,time_Updated
					From OB_Spare_BT
					Where MONo = @sMONo
					/* remarks by donel
					Insert Into OBSMVHdr (MONo,EffDt,Seq,CreatedBy,CreatedDt,ApprovedBy,ApprovedDt)
					Select @MONo,EffDt,Seq,CreatedBy,CreatedDt,ApprovedBy,ApprovedDt
					From OBSMVHdr
					Where MONo = @sMONo
					*/
					Insert Into OB_SMV_Det (sbu_id,MONo,Eff_Dt,Operation,smv,Created_By,time_Created--remarks by donel,Revised_By,RevisedDt
					,Approved_By,Approved_Dt,Feature,Style)
					Select @sbu_id,@MONo,Eff_Dt,Operation,smv,Created_By,time_Created--remarks by donel,RevisedBy,RevisedDt
					,Approved_By,Approved_Dt,Feature,Style
					From OB_SMV_Det
					Where MONo = @sMONo
						And Operation Not In (Select Operation From OB_SMV_Det Where MONo = @MONo)
					/* remarks by donel
					Insert Into OBShellNo (MONo,Feature,ShellNo,Deleted,CreatedBy,CreatedDt,UpdatedBy,UpdatedDt)
					Select @MONo,Feature,ShellNo,Deleted,CreatedBy,CreatedDt,UpdatedBy,UpdatedDt
					From OBShellNo
					Where MONo = @sMONo
					*/
					Declare @GrpName varchar(20)
					Declare @VAP varchar(20)
					Declare @SVAP varchar(20)
					Declare GrpVAPSVAP Cursor For
								Select
									a.Group_Name,
									a.VAP,
									a.SVAP
								From OB_Group_Hdr	a
								Inner Join OB_Group_Operations b On a.Group_Name = b.Group_Name And a.MONo = b.MONo
								Where a.MONo = @sMONo --And b.Operation In (Select Operation From WorkersOutputDet Where MONo = @MONo)
					Open GrpVAPSVAP
					Fetch Next From GrpVAPSVAP Into @GrpName,@VAP,@SVAP
					While @@FETCH_STATUS = 0
					Begin

							Insert Into OB_Group_Hdr (sbu_id,MONo,Group_Name,VAP,SVAP,Remarks,Deleted,Created_By,time_Created,Updated_By,time_Updated)
							Select @sbu_id,@MONo,Group_Name,VAP,SVAP,Remarks,Deleted,Created_By,time_Created,Updated_By,time_Updated
							From OB_Group_Hdr
							Where MONo = @sMONo
								And VAP + '-' + SVAP Not In (Select VAP + '-' + SVAP From OB_Group_Hdr Where MONo = @MONo)
							If Exists (Select 'x' From OB_Group_Operations Where MONo = @MONo And Group_Name = @GrpName)
							Begin
									Insert Into OB_Group_Operations (sbu_id,MONo,Group_Name,Operation,First_Opn,Last_Opn,For_Print,Deleted,Created_By,time_Created,Updated_By,time_Updated,Seq,Split,Feature,Style, active)
									Select @sbu_id,@MONo,@GrpName,a.Operation,0,0,a.For_Print,a.Deleted,a.Created_By,a.time_Created,a.Updated_By,a.time_Updated,a.Seq,a.Split,a.Feature,a.Style, a.active
									From OB_Group_Operations a
									Inner Join OB_Group_Hdr b On a.MONo = b.MONo And a.Group_Name = b.Group_Name
									Where a.MONo = @sMONo
										And Operation Not In (Select Operation From OB_Group_Operations Where MONo = @MONo)
										And b.VAP + '-' + b.SVAP = @VAP + '-' + @SVAP

									Insert Into OB_Group_Operations (sbu_id,MONo,Group_Name,Operation,First_Opn,Last_Opn,For_Print,Deleted,Created_By,time_Created,Updated_By,time_Updated,Seq,Split,Feature,Style,active)
									Select @sbu_id,@MONo,a.Group_Name,a.Operation,0,0,a.For_Print,a.Deleted,a.Created_By,a.time_Created,a.Updated_By,a.time_Updated,a.Seq,a.Split,a.Feature,a.Style, a.active
									From OB_Group_Operations a
									Inner Join OB_Group_Hdr b On a.MONo = b.MONo And a.Group_Name = b.Group_Name
									Where a.MONo = @sMONo
										And Operation Not In (Select Operation From OB_Group_Operations Where MONo = @MONo)
										--And b.VAP + '-' + b.SVAP = @VAP + '-' + @SVAP
							End
							Else
							Begin
									Insert Into OB_Group_Operations (sbu_id,MONo,Group_Name,Operation,First_Opn,Last_Opn,For_Print,Deleted,Created_By,time_Created,Updated_By,time_Updated,Seq,Split,Feature,Style, active)
									Select @sbu_id,@MONo,@GrpName,a.Operation,First_Opn,Last_Opn,a.For_Print,a.Deleted,a.Created_By,a.time_Created,a.Updated_By,a.time_Updated,a.Seq,a.Split,a.Feature,a.Style, a.active
									From OB_Group_Operations a
									Inner Join OB_Group_Hdr b On a.MONo = b.MONo And a.Group_Name = b.Group_Name
									Where a.MONo = @sMONo
										And Operation Not In (Select Operation From OB_Group_Operations Where MONo = @MONo)
										And b.VAP + '-' + b.SVAP = @VAP + '-' + @SVAP

									Insert Into OB_Group_Operations (sbu_id,MONo,Group_Name,Operation,First_Opn,Last_Opn,For_Print,Deleted,Created_By,time_Created,Updated_By,time_Updated,Seq,Split,Feature,Style, active)
									Select @sbu_id,@MONo,a.Group_Name,a.Operation,First_Opn,Last_Opn,a.For_Print,a.Deleted,a.Created_By,a.time_Created,a.Updated_By,a.time_Updated,a.Seq,a.Split,a.Feature,a.Style, a.active
									From OB_Group_Operations a
									Inner Join OB_Group_Hdr b On a.MONo = b.MONo And a.Group_Name = b.Group_Name
									Where a.MONo = @sMONo
										And Operation Not In (Select Operation From OB_Group_Operations Where MONo = @MONo)
										--And b.VAP + '-' + b.SVAP = @VAP + '-' + @SVAP
							End
							-------------Insert WS setup under the same Group name
							Insert Into OB_Group_WorkSections (sbu_id,MONo,Group_Name,Work_Section,Deleted,Created_By,time_Created,Updated_By,time_Updated, active)
							Select @sbu_id,@MONo,@GrpName,a.Work_Section,a.Deleted,a.Created_By,a.time_Created,a.Updated_By,a.time_Updated, a.active
							From OB_Group_WorkSections a
							Inner Join OB_Group_Hdr b On a.MONo = b.MONo And a.Group_Name = b.Group_Name
							Where a.MONo = @sMONo
								And a.Work_Section Not In (Select Work_Section From OB_Group_WorkSections Where MONo = @MONo)
								And b.VAP + '-' + b.SVAP = @VAP + '-' + @SVAP


							-------------Insert WS setup under the source Group name
							Insert Into OB_Group_WorkSections (sbu_id,MONo,Group_Name,Work_Section,Deleted,Created_By,time_Created,Updated_By,time_Updated)
							Select @sbu_id,@MONo,a.Group_Name,a.Work_Section,a.Deleted,a.Created_By,a.time_Created,a.Updated_By,a.time_Updated
							From OB_Group_WorkSections a
							Inner Join OB_Group_Hdr b On a.MONo = b.MONo And a.Group_Name = b.Group_Name
							Where a.MONo = @sMONo
								And a.Work_Section Not In (Select Work_Section From OB_Group_WorkSections Where MONo = @MONo)

							--If Not Exists(Select 'x' From OBGroupOperations Where MONo = @MONo And LastOpn = 1 And GroupName = @GrpName)
							--Begin
							--	Update OBGroupOperations Set LastOpn = 1 Where MONo = @MONo And Operation = (Select Operation From OBGroupOperations Where MONo = @sMONo And LastOpn = 1 And GroupName = @GrpName)  And GroupName = @GrpName
							--End
								--And b.VAP + '-' + b.SVAP = @VAP + '-' + @SVAP
							--INSERT INTO MOSVAPPart(MONO,SEQ,PARTCD,VAP,SVAP,DELETED,CREATEDBY,CREATEDDT)
							--SELECT DISTINCT  @MONO,SEQ,PARTCD,VAP,SVAP,0,CREATEDBY,CREATEDDT FROM MOSVAPPart where mono = @sMONo
							--AND PARTCD+VAP+SVAP NOT IN (SELECT PARTCD+VAP+SVAP FROM  MOSVAPPart where mono = @MONo)





					Fetch Next From GrpVAPSVAP Into @GrpName,@VAP,@SVAP
					End
					Close GrpVAPSVAP
					Deallocate GrpVAPSVAP
				--Print 'test 3'
				-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

				-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				--Update existing record from the source MO
					--IF Object_Id ('tempdb..#tmpOBGrpWS') Is Not Null Drop Table #tmpOBGrpWS
					--Select MONo,GroupName,WorkSection,Deleted,CreatedBy,CreatedDt,UpdatedBy,UpdatedDt
					--Into #tmpOBGrpWS
					--From OBGroupWorkSections
					--Where MONo = @sMONo
					----Select * From #tmpOBGrpOpe
					--Update a
					--	Set a.GroupName = b.GroupName, a.Deleted = b.Deleted, a.UpdatedBy = @UserId, UpdatedDt = Getdate()
					--From OBGroupWorkSections a
					--Inner Join #tmpOBGrpWS b ON a.WorkSection = b.WorkSection
					--Where a.MONo = @MONo


					--IF Object_Id ('tempdb..#tmpOBGrpHdr') Is Not Null Drop Table #tmpOBGrpHdr
					--Select MONo,GroupName,VAP,SVAP,Remarks,Deleted,CreatedBy,CreatedDt,UpdatedBy,UpdatedDt
					--Into #tmpOBGrpHdr
					--From OBGroupHdr
					--Where MONo = @sMONo
					----Select * From OBGroupHdr
					--Update a
					--	Set a.GroupName = b.GroupName, a.Remarks = b.Remarks, a.Deleted = b.Deleted, a.UpdatedBy = @UserId, UpdatedDt = Getdate()
					--From OBGroupHdr a
					--Inner Join #tmpOBGrpHdr b ON a.VAP = b.SVAP And a.SVAP = b.SVAP
					--Where a.MONo = @MONo

				---------------Tagged last operation from the source if MO has no last operation
				If Not Exists(Select 'x' From OB_Group_Operations Where MONo = @MONo And Last_Opn = 1 And Group_Name = @GrpName)
				Begin
					Update OB_Group_Operations Set Last_Opn = 1 Where MONo = @MONo And Operation IN (Select Operation From OB_Group_Operations Where MONo = @sMONo And Last_Opn = 1)
				End

				If Exists (Select 'x' From EPF_Worker_Op Where MONo = @MONo)
				Begin
					--Print 'test'
					--		IF Object_Id ('tempdb..#tmpOB') Is Not Null Drop Table #tmpOB
					--Select MONo,Feature,Operation,Seq,Split,VAP,SVAP,SAM,TargetOutput,Cost,Active,AddedOpn,Difficulty,Remarks,StyleNo,SAM2,Escalation,WBT,
					--				Deleted,CreatedBy,CreatedDt,UpdatedBy,UpdatedDt,Approved,ApprovedBy,ApprovedDt
					--Into #tmpOB
					--From OB
					--Where MONo = @sMONo
					--	And Operation In (Select a.Operation from OBSMVDet a
					--						Inner Join EPFWorkerOp b On a.MONo = b.MONo And a.Operation = b.Operation And a.EffDt > b.EffDt
					--						Where a.MONo = @MONo
					--					 )
					----Select * From WorkersOutputDet Where MONo = @MONo And Operation Not In (Select Operation From OBSMVDet Where MONo = @MONo)
					----Select * From #tmpOB
					--Update a
					--	Set a.VAP = b.VAP, a.SVAP = b.SVAP, a.Escalation = b.Escalation, a.Seq = b.Seq, a.Split = b.Split, a.UpdatedBy = @UserId, UpdatedDt = Getdate()
					--From OB a
					--Inner Join #tmpOB b ON a.Operation = b.Operation
					--Where a.MONo = @MONo


					--IF Object_Id ('tempdb..#tmpOBGrpOpe') Is Not Null Drop Table #tmpOBGrpOpe
					--Select MONo,GroupName,Operation,FirstOpn,LastOpn,ForPrint,Deleted,CreatedBy,CreatedDt,UpdatedBy,UpdatedDt,Seq,Split
					--Into #tmpOBGrpOpe
					--From OBGroupOperations
					--Where MONo = @sMONo
					--	And Operation In (Select a.Operation from OBSMVDet a
					--						Inner Join EPFWorkerOp b On a.MONo = b.MONo And a.Operation = b.Operation And a.EffDt > b.EffDt
					--						Where a.MONo = @MONo
					--					 )

					----Select * From #tmpOBGrpOpe
					--Update a
					--	Set  a.LastOpn = b.LastOpn, a.ForPrint = b.ForPrint, a.Deleted = b.Deleted, a.Seq = b.Seq, a.Split = b.Split, a.UpdatedBy = @UserId, UpdatedDt = Getdate()
					--From OBGroupOperations a
					--Inner Join #tmpOBGrpOpe b ON a.Operation = b.Operation
					--Where a.MONo = @MONo


					IF Object_Id ('tempdb..#tmpOBSMVDet') Is Not Null Drop Table #tmpOBSMVDet
					Select MONo,Eff_Dt,Operation,smv,Created_By,time_Created,Revised_By,Revised_Dt
					,Approved_By,Approved_Dt
					Into #tmpOBSMVDet
					From OB_SMV_Det
					Where MONo = @sMONo
						And Operation In (Select a.Operation from OB_SMV_Det a
											Inner Join EPF_Worker_Op b On a.MONo = b.MONo And a.Operation = b.Operation And a.Eff_Dt > b.Eff_Dt
											Where a.MONo = @MONo
										 )
					--Select * From #tmpOBSMVDet
					Update a
						Set a.Eff_Dt = b.Eff_Dt--remarks by donel, a.RevisedBy = @UserId, RevisedDt = Getdate()
					From OB_SMV_Det a
					Inner Join #tmpOBSMVDet b On a.Operation = b.Operation
					Where a.MONo = @MONo
				End
				Else
				Begin
					IF Object_Id ('tempdb..#tmpOB2') Is Not Null Drop Table #tmpOB2
					Select MONo,Feature,Operation,Seq,Split,VAP,SVAP,smv,Target_Output,price_per_pc,Active,Added_Opn
					,Difficulty,Remarks,Style_No,smv2,Escalation,WBT,
									Deleted,Created_By,time_Created,Updated_By,time_Updated--remarks by donel ,Approved,Approved_By,Approved_Dt
									,machine
					Into #tmpOB2
					From OB
					Where MONo = @sMONo
						And Operation Not In (Select a.Operation from OB_SMV_Det a
													Inner Join EPF_Worker_Op b On a.MONo = b.MONo And a.Operation = b.Operation And a.Eff_Dt > b.Eff_Dt
													Where a.MONo = @MONo
											)
					Update a
						Set a.Escalation = b.Escalation, a.smv = b.smv, a.smv2 = b.smv2, a.Seq = b.Seq, a.Split = b.Split, a.Updated_By = @UserId, time_Updated = Getdate(), a.Machine = b.Machine, a.Remarks = b.Remarks
					From OB a
					Inner Join #tmpOB2 b ON a.Operation = b.Operation
					Where a.MONo = @MONo


					--IF Object_Id ('tempdb..#tmpOBGrpOpe2') Is Not Null Drop Table #tmpOBGrpOpe2
					--Select MONo,GroupName,Operation,FirstOpn,LastOpn,ForPrint,Deleted,CreatedBy,CreatedDt,UpdatedBy,UpdatedDt,Seq,Split
					--Into #tmpOBGrpOpe2
					--From OBGroupOperations
					--Where MONo = @sMONo
					----Select * From #tmpOBGrpOpe
					--Update a
					--	Set  a.LastOpn = b.LastOpn, a.ForPrint = b.ForPrint, a.Deleted = b.Deleted, a.Seq = b.Seq, a.Split = b.Split, a.UpdatedBy = @UserId, UpdatedDt = Getdate()
					--From OBGroupOperations a
					--Inner Join #tmpOBGrpOpe2 b ON a.Operation = b.Operation
					--Where a.MONo = @MONo


					IF Object_Id ('tempdb..#tmpOBSMVDet2') Is Not Null Drop Table #tmpOBSMVDet2
					Select MONo,Eff_Dt,Operation,smv,Created_By,time_Created, Revised_By,Revised_Dt
					,Approved_By,Approved_Dt
					Into #tmpOBSMVDet2
					From OB_SMV_Det
					Where MONo = @sMONo
						And Operation Not In (Select a.Operation from OB_SMV_Det a
													Inner Join EPF_Worker_Op b On a.MONo = b.MONo And a.Operation = b.Operation And a.Eff_Dt > b.Eff_Dt
													Where a.MONo = @MONo
											)
					Update a
						Set a.Eff_Dt = b.Eff_Dt, a.smv = b.smv, a.Revised_By = @UserId, Revised_Dt = Getdate()
					From OB_SMV_Det a
					Inner Join #tmpOBSMVDet2 b On a.Operation = b.Operation and a.time_Created = b.time_Created
					Where a.MONo = @MONo

					Insert Into OB_SMV_Det (sbu_id,MONo,Eff_Dt,Operation,smv,Created_By,time_Created,Revised_By,Revised_Dt--remarks by donel ,ApprovedBy,ApprovedDt
					,Feature,Style, active)
					Select @sbu_id,@MONo,Eff_Dt,Operation,smv,Created_By,time_Created,Revised_By,Revised_Dt--remarks by donel,ApprovedBy,ApprovedDt
					,Feature,Style, active
					From OB_SMV_Det a
					Where MONo = @sMONo
						And Operation Not In (Select Operation from OB_SMV_Det
													Where MONo = @MONo and Operation = a.Operation And Eff_Dt < a.Eff_Dt)
					And Operation Not In (Select Operation from OB_SMV_Det
													Where MONo = @sMONo and Operation = a.Operation And Eff_Dt = a.Eff_Dt)

					Insert Into OB_SMV_Det (sbu_id,MONo,Eff_Dt,Operation,smv,Created_By,time_Created,Revised_By,Revised_Dt--remarks by donel ,ApprovedBy,ApprovedDt
					,Feature,Style, active)
					Select @sbu_id,@MONo,Eff_Dt,Operation,smv,Created_By,time_Created,Revised_By,Revised_Dt--remarks by donek ,ApprovedBy,ApprovedDt
					,Feature,Style, active
					From OB_SMV_Det a
					Where MONo = @sMONo
											And Operation Not In (Select Operation from OB_SMV_Det
													Where MONo = @MONo and Operation = a.Operation And Eff_Dt > a.Eff_Dt)
					And Operation Not In (Select Operation from OB_SMV_Det
													Where MONo = @MONo and Operation = a.Operation And Eff_Dt = a.Eff_Dt)

				End
				-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				--If Exists (Select 'x' From MOVAPSVAP Where MONo = @MONo And Active = 1 And Reqd = 1)
				--Begin
				--	UPDATE MOHdr SET MOStatus = 'Released', UpdatedBy = @UserId, UpdatedDt = GETDATE()
				--	WHERE MONo = @MONo AND EXISTS (SELECT 'x' FROM OBSMVDet o WHERE o.MONo = iMAPPS.dbo.MOHdr.MONo AND ISNULL(o.ApprovedBy,'') <> '')
				--End

					Declare @Description varchar(2000)
					Declare @MOOpeSAM varchar(50)
					set @Description = ''
					Declare MOOpeSAM Cursor For
								Select Distinct
									MONO + '-'+ Operation + '-' + Cast(smv as Varchar(10))
								From Workers_Output_Det
								Where MONo = @MONo
					Open MOOpeSAM
					Fetch Next From MOOpeSAM Into @MOOpeSAM
					While @@FETCH_STATUS = 0
					Begin
						if @Description = ''
						Begin
						Set @Description = @MOOpeSAM
						End
						Else
						Begin
							Set @Description = @Description + '/' + @MOOpeSAM
						End


					Fetch Next From MOOpeSAM Into @MOOpeSAM

					End
					Close MOOpeSAM
					Deallocate MOOpeSAM

					DELETE  FROM MO_SVAP_Part WHERE MONo = @MONo
					--AND PartCd NOT IN (SELECT FEATURE FROM OB WHERE MONo = @MONo)
					--AND VAP+SVAP+PartCd NOT IN (SELECT VAP+SVAP+PartCd FROM WIPScanPart WHERE MONo = @MONo)


					IF NOT EXISTS(SELECT MONo,Group_Name,Operation,Seq
						FROM OB_Group_Operations A
						WHERE MONo = @MONo
						AND Seq IN (SELECT MIN(Seq) FROM OB_Group_Operations WHERE MONo = A.MONO AND Group_Name = A.Group_Name)
						AND First_Opn = 0)
					BEGIN
						UPDATE A SET A.First_Opn = 1
						--SELECT MONo,GroupName,Operation,Seq
						FROM OB_Group_Operations A
						WHERE MONo = @MONo
						AND Seq IN (SELECT MIN(Seq) FROM OB_Group_Operations WHERE MONo = A.MONO AND Group_Name = A.Group_Name)
						AND First_Opn = 0

						UPDATE A SET A.Last_Opn = 1
						--SELECT MONo,GroupName,Operation,Seq
						FROM OB_Group_Operations A
						WHERE MONo = @MONo
						AND Seq IN (SELECT MAX(Seq) FROM OB_Group_Operations WHERE MONo = A.MONO AND Group_Name = A.Group_Name)
						AND Last_Opn = 0
					END

					EXEC prdInsertMOSVAPPartsp @MONO
					--remarks by donel Exec prdUpdateOBGroupWS @MONo,@UserId

					IF EXISTS(SELECT TOP 1 'X' FROM OB WITH(NOLOCK) WHERE MONO = @MONO)
					BEGIN

						UPDATE MO_VAP_SVAP SET ACTIVE = 0
						WHERE MONO =  @MONO
						AND VAP+SVAP NOT IN
						(
						SELECT DISTINCT VAP+SVAP
						FROM
						MO_SVAP_PART
						WHERE MONO = @MONO
						)
						AND  SEQ2 < (SELECT TOP 1 SEQ2 FROM MO_VAP_SVAP WHERE MONO = @MONO AND GVAP = 'SEW' AND LOAD_OFF = 1 ORDER BY SEQ2 DESC)

						UPDATE MO_VAP_SVAP SET ACTIVE = 1
						WHERE MONO =  @MONO
						AND VAP+SVAP IN
						(
						SELECT DISTINCT VAP+SVAP
						FROM
						MO_SVAP_PART
						WHERE MONO = @MONO
						)
						AND  SEQ2 < (SELECT TOP 1 SEQ2 FROM MO_VAP_SVAP WHERE MONO = @MONO AND GVAP = 'SEW' AND LOAD_OFF = 1 ORDER BY SEQ2 DESC)


						UPDATE MO_VAP_SVAP SET ACTIVE = 1
						WHERE MONO =  @MONO
						AND  SEQ2 >= (SELECT TOP 1 SEQ2 FROM MO_VAP_SVAP WHERE MONO = @MONO AND GVAP = 'SEW' AND LOAD_OFF = 1 ORDER BY SEQ2 DESC)

					END

					--Select 'Some operations aleady have an output or EPF' + ' ' + @Description,1
					/* remarks by donel if(@wOB = 1)
					begin
						Select @MONo+'(Generated)',0
					end
					else
					begin
						Select @MONo+'(Created)',0
					end
					*/
			End
			Else
			Begin
				--Print 'test 3'

				If exists(Select TOP 1 'X' from OB with(nolock) Where MONo = @MONo)
					Begin
						Set @wOB = 1
					End
				--select 'test 3'
				Delete From OB_Group_WorkSections Where MONo = @MONo
				Delete From OB_Group_Operations Where MONo = @MONo
				Delete From OB_Group_Hdr Where MONo = @MONo
				--remarks by donel Delete From OBShellNo Where MONo = @MONo
				Delete From OB_SMV_Det Where MONo = @MONo
				--remarks by donel Delete From OB_SMV_Hdr Where MONo = @MONo
				Delete From OB_Spare_BT Where MONo = @MONo
				Delete From OB Where MONo = @MONo

				--sp_columns OBGroupWorkSections

				Insert Into OB (sbu_id,MONo,Feature,Operation,Seq,Split,VAP,SVAP,smv,Target_Output,price_per_pc,Active,Added_Opn,Difficulty,Remarks,Style_No,smv2,Escalation,WBT,
								Deleted,Created_By,time_Created,Updated_By,time_Updated
								--remarks by donel ,Approved,Approved_By,Approved_Dt
								,Sync_Fr,Sync_By,time_Sync,machine, feature_desc, operation_desc)
				Select @sbu_id,@MONo,Feature,Operation,Seq,Split,VAP,SVAP,smv,Target_Output,price_per_pc,Active,Added_Opn,Difficulty,Remarks,Style_No,smv2,Escalation,WBT,
								Deleted,Created_By,time_Created,Updated_By,time_Updated--remarks by donel,Approved,ApprovedBy,ApprovedDt
								,@sMONo,@UserId,Getdate(),machine , feature_desc, operation_desc
				From OB
				Where MONo = @sMONo

				Insert Into OB_Spare_BT (MONo,Feature,Spare_BT,Shell_No,Deleted,Created_By,time_Created,Updated_By,time_Updated,active)
				Select @MONo,Feature,Spare_BT,Shell_No,Deleted,Created_By,time_Created,Updated_By,time_Updated, active
				From OB_Spare_BT
				Where MONo = @sMONo
				/* remarks by donel
				Insert Into OB_SMV_Hdr (MONo,Eff_Dt,Seq,Created_By,CreatedDt,ApprovedBy,ApprovedDt)
				Select @MONo,EffDt,Seq,CreatedBy,CreatedDt,ApprovedBy,ApprovedDt
				From OBSMVHdr
				Where MONo = @sMONo
				*/
				Insert Into OB_SMV_Det (sbu_id,MONo,Eff_Dt,Operation,smv,Created_By,time_Created,Revised_By,Revised_Dt--remarks by donel ,ApprovedBy,ApprovedDt
				,Feature,Style, active)
				Select @sbu_id,@MONo,Eff_Dt,Operation,smv,Created_By,time_Created,Revised_By,Revised_Dt--remarks by donel ,Approved_By,Approved_Dt
				,Feature,Style, active
				From OB_SMV_Det
				Where MONo = @sMONo
				/*remarks by donel
				Insert Into OBShellNo (MONo,Feature,ShellNo,Deleted,CreatedBy,CreatedDt,UpdatedBy,UpdatedDt)
				Select @MONo,Feature,ShellNo,Deleted,CreatedBy,CreatedDt,UpdatedBy,UpdatedDt
				From OBShellNo
				Where MONo = @sMONo
				*/
				Insert Into OB_Group_Hdr (sbu_id,MONo,Group_Name,VAP,SVAP,Remarks,Deleted,Created_By,time_Created,Updated_By,time_Updated, active)
				Select @sbu_id,@MONo,Group_Name,VAP,SVAP,Remarks,Deleted,Created_By,time_Created,Updated_By,time_Updated, active
				From OB_Group_Hdr
				Where MONo = @sMONo

				Insert Into OB_Group_Operations (sbu_id,MONo,Group_Name,Operation,First_Opn,Last_Opn,For_Print,Deleted,Created_By,time_Created,Updated_By,time_Updated,Seq,Split,Feature,Style, active)
				Select @sbu_id,@MONo,Group_Name,Operation,First_Opn,Last_Opn,For_Print,Deleted,Created_By,time_Created,Updated_By,time_Updated,Seq,Split,Feature,Style, active
				From OB_Group_Operations
				Where MONo = @sMONo

				Insert Into OB_Group_WorkSections (sbu_id,MONo,Group_Name,Work_Section,Deleted,Created_By,time_Created,Updated_By,time_Updated, active)
				Select @sbu_id,@MONo,Group_Name,Work_Section,Deleted,Created_By,time_Created,Updated_By,time_Updated, active
				From OB_Group_WorkSections
				Where MONo = @sMONo

				DELETE  FROM MO_SVAP_Part WHERE MONo = @MONo
				--AND PartCd NOT IN (SELECT FEATURE FROM OB WHERE MONo = @MONo)
				--AND VAP+SVAP+PartCd NOT IN (SELECT VAP+SVAP+PartCd FROM WIPScanPart WHERE MONo = @MONo)

				--INSERT INTO MOSVAPPart(MONO,SEQ,PARTCD,VAP,SVAP,DELETED,CREATEDBY,CREATEDDT)
				--Select DISTINCT @MONO,SEQ,PARTCD,VAP,SVAP,0,CREATEDBY,CREATEDDT FROM MOSVAPPart where mono = @sMONo
				--AND PARTCD+VAP+SVAP NOT IN (SELECT PARTCD+VAP+SVAP FROM  MOSVAPPart where mono = @MONo)

				--remarks by donel EXEC prdInsertMOSVAPPartsp @MONO


				--If Exists (Select 'x' From MOVAPSVAP Where MONo = @MONo And Active = 1 And Reqd = 1)
				--Begin
				--	UPDATE MOHdr SET MOStatus = 'Released', UpdatedBy = @UserId, UpdatedDt = GETDATE()
				--	WHERE MONo = @MONo AND EXISTS (SELECT 'x' FROM OBSMVDet o WHERE o.MONo = iMAPPS.dbo.MOHdr.MONo AND ISNULL(o.ApprovedBy,'') <> '')
				--End


				IF NOT EXISTS(SELECT MONo,Group_Name,Operation,Seq
					FROM OB_Group_Operations A
					WHERE MONo = @MONo
					AND Seq IN (SELECT MIN(Seq) FROM OB_Group_Operations WHERE MONo = A.MONO AND Group_Name = A.Group_Name)
					AND First_Opn = 0)
				BEGIN
					UPDATE A SET A.First_Opn = 1
					--SELECT MONo,GroupName,Operation,Seq
					FROM OB_Group_Operations A
					WHERE MONo = @MONo
					AND Seq IN (SELECT MIN(Seq) FROM OB_Group_Operations WHERE MONo = A.MONO AND Group_Name = A.Group_Name)
					AND First_Opn = 0

					UPDATE A SET A.Last_Opn = 1
					--SELECT MONo,GroupName,Operation,Seq
					FROM OB_Group_Operations A
					WHERE MONo = @MONo
					AND Seq IN (SELECT MAX(Seq) FROM OB_Group_Operations WHERE MONo = A.MONO AND Group_Name = A.Group_Name)
					AND Last_Opn = 0
				END

				--remarks by donel Exec prdUpdateOBGroupWS @MONo,@UserId

				IF EXISTS(SELECT TOP 1 'X' FROM OB WITH(NOLOCK) WHERE MONO = @MONO)
				BEGIN

					UPDATE MO_VAP_SVAP SET ACTIVE = 0
					WHERE MONO =  @MONO
					AND VAP+SVAP NOT IN
					(
					SELECT DISTINCT VAP+SVAP
					FROM
					MO_SVAP_PART
					WHERE MONO = @MONO
					)
					AND  SEQ2 < (SELECT TOP 1 SEQ2 FROM MO_VAP_SVAP WHERE MONO = @MONO AND GVAP = 'SEW' AND LOAD_OFF = 1 ORDER BY SEQ2 DESC)

					UPDATE MO_VAP_SVAP SET ACTIVE = 1
					WHERE MONO =  @MONO
					AND VAP+SVAP IN
					(
					SELECT DISTINCT VAP+SVAP
					FROM
					MO_SVAP_PART
					WHERE MONO = @MONO
					)
					AND  SEQ2 < (SELECT TOP 1 SEQ2 FROM MO_VAP_SVAP WHERE MONO = @MONO AND GVAP = 'SEW' AND LOAD_OFF = 1 ORDER BY SEQ2 DESC)


					UPDATE MO_VAP_SVAP SET ACTIVE = 1
					WHERE MONO =  @MONO
					AND  SEQ2 >= (SELECT TOP 1 SEQ2 FROM MO_VAP_SVAP WHERE MONO = @MONO AND GVAP = 'SEW' AND LOAD_OFF = 1 ORDER BY SEQ2 DESC)

				END
				--Select 'Sync successful  MO#' + @MONo
				/* remarks by donel
				if(@wOB = 1)
				begin
					Select @MONo+'(Generated)',0
				end
				else
				begin
					Select @MONo+'(Created)',0
				end
				*/
			EnD

			IF EXISTS(SELECT 'X' FROM LAYING_HDR WHERE MONo = @MONo AND Status = 'G')
			BEGIN
				DECLARE @LAY NVARCHAR(20)
				DECLARE @NOOFLAY INT
				DECLARE @COUNTER INT = 1

				DECLARE @LAYLIST TABLE
				(
					ROWNO INT,
					LAY_NO NVARCHAR(20)
				)

				INSERT INTO @LAYLIST
				SELECT ROW_NUMBER() OVER (PARTITION BY MONO ORDER BY LAYNO) AS ROWNO, LayNo
				FROM Laying_Hdr WHERE MONo = @MONo
				AND Status = 'G'

				SELECT @NOOFLAY = COUNT(1) FROM @LAYLIST

				WHILE @COUNTER <= @NOOFLAY
				BEGIN

				SELECT @LAY = LAY_NO FROM @LAYLIST WHERE ROWNO = @COUNTER

				/*Insert Into WIP_Scan_Part(Rec_Id,MONo,LayNo,PTNo,Load_Type,Seq,VAP,SVAP,Part_Cd,Qty,Created_By,time_Created,Work_Section,time_Updated,Scan_Dt,Authorized_By,Day_Night_Shft)
				Select
					NEWID(),
					Laying_PT.MONo,
					LAYING_PT.LayNo,
					PTNo,
					1 as LoadType,
					1 as Seq,
					'BIN-INIT',
					'BIN-INIT',
					Part_Cd,
					Qty,
					Laying_PT.time_Created,
					GETDATE(),
					Laying_Hdr.Created_By,
					NULL,
					Laying_PT.time_Created,
					NULL,
					shift
				From Laying_PT
				INNER JOIN MO_SVAP_PART ON Laying_PT.MONo = MO_SVAP_PART.MONo
				INNER JOIN Laying_Hdr ON Laying_PT.MONo = Laying_Hdr.MONo AND Laying_PT.LayNo = Laying_Hdr.LayNo
				OUTER APPLY(SELECT TOP 1 shift FROM WIP_Scan with(nolock) WHERE MONo = @MONo AND LayNo = Laying_PT.LayNo) AS shift
				Where Laying_PT.MONo = @MONo AND VAP = 'BIN-INIT'
				AND LAYING_PT.LayNo = @Lay AND PTNo+Part_Cd NOT IN (SELECT PTNo+Part_Cd FROM WIP_Scan_Part  with(nolock) WHERE MONo = @MONo AND LayNo = @LAY AND PTNo = Laying_PT.PTNo)*/


				Insert Into WIP_Scan_Part(pt_id, Load_Type,Seq,VAP,SVAP,feature,issued_qty,Created_By,Time_Created,work_section_id,Time_Updated,Scan_Dt,Authorized_By,Day_Night_Shft) --Rec_Id, MONo, LayNo, PTNo, remove Mar 27, 2023. Eduard
				Select
					--NEWID(),
					--Laying_PT.MONo,
					--LAYING_PT.LayNo,
					--PTNo,
					pt_id = Laying_PT.id,
					1 as LoadType,
					1 as Seq,
					'BIN-INIT',
					'BIN-INIT',
					Part_Cd,
					Qty,
					Laying_PT.Time_Created,
					GETDATE(),
					Laying_Hdr.Created_By,
					NULL,
					Laying_PT.Time_Created,
					NULL,
					'D'--remarks by donel (SELECT TOP 1 Day_Night_Shft FROM WIP_Scan WHERE MONo = @MONo AND Lay_No = Laying_PT.Lay_No)
				From Laying_PT
				INNER JOIN MO_SVAP_PART ON Laying_PT.MONo = MO_SVAP_PART.MONo
				INNER JOIN Laying_Hdr ON Laying_PT.MONo = Laying_Hdr.MONo AND Laying_PT.LayNo = Laying_Hdr.LayNo
				Where Laying_PT.MONo = @MONo AND VAP = 'BIN-INIT'
				AND LAYING_PT.LayNo = @Lay AND PTNo NOT IN (SELECT PTNo FROM WIP_Scan_Part WHERE WIP_Scan_Part.mo_id = @moid) --replace by Eduard. i cannot see the lay No. Mar 27. 2023
				--AND LAYING_PT.LayNo = @Lay AND PTNo+Part_Cd NOT IN (SELECT PTNo+Part_Cd FROM WIP_Scan_Part WHERE WIP_Scan_Part.mo_id = @moid AND LayNo = @LAY)



				SET @COUNTER = @COUNTER + 1

				END
			END
				Update mo_hdr set mo_status = 'OB' where mono = @MONo
				select 'OB Sync Successful for MONo - ' + @MONo  as description, 'ok' as code
				--rollback transaction
			END
			ELSE
			BEGIN
				SELECT '' as description, '' as code
			END

End
go







CREATE PROCEDURE [dbo].[stg_plnUpdateBObyMO_CPSew]
(
	@MONUM VARCHAR(100),
	@USERID NVARCHAR(50)
)

AS

----FOR TESTING
--DECLARE @MONUM VARCHAR(50)
--DECLARE @USERID NVARCHAR(50)

--SET @MONUM = '12605101003'
--SET @USERID = 'system'


SET NOCOUNT ON 
	
BEGIN TRY

	IF OBJECT_ID('TEMPDB..#BOEVENTS') IS NOT NULL DROP TABLE #BOEVENTS

	SELECT
		[SEQ] = ROW_NUMBER() OVER (PARTITION BY BH.MFG_LOC, BH.MONO, BH.BONO ORDER BY ME.SEQ_NO), --ME.EVENTSEQ
		BH.MONO,
		BH.BONO,
		BH.LINE,
		BH.MFG_LOC,
		ME.REC_ID,
		ME.EVENT_SEQ,
		ME.KEY_EVENT,
		[REQ_START] = CASE WHEN ME.VAP = 'SEW' THEN CAST(BH.PLAN_START AS DATE) ELSE NULL END,
		[REQ_END] = CASE WHEN ME.VAP = 'SEW' THEN CAST(BH.PLAN_FINISH AS DATE) ELSE NULL END,
		[PLAN_START] = ME.PLAN_START,
		[PLAN_END] = ME.PLAN_END,
		[PO_START] = CAST(NULL AS DATETIME),
		[PO_END] = CAST(NULL AS DATETIME),
		ME.ACTUAL_START,
		ME.ACTUAL_END,
		[REQ_DURATION] = CASE WHEN ME.VAP = 'SEW' THEN (SELECT COUNT('X') FROM BO_DAILY_TARGET WHERE MONO = BH.MONO AND BONO = BH.BONO) 
						ELSE ME.REQ_DURATION END,
		ME.PLAN_DURATION,
		ME.ACTUAL_DURATION,
		ME.RESPONSIBLE,
		ME.VAP,
		ME.REMARKS,
		[PREDECESSOR] = ME.PRED, --ME.PREDECESSOR,
		[SUCCESSOR] = ME.SUCC, --ME.SUCCESSOR,
		ME.active,
		[CREATED_BY] = @USERID,
		ME.LEAD_LAG
	INTO #BOEVENTS
--	FROM DBO.MOEVENTSVW ME
	FROM
	(
	SELECT e.*
	, isnull(STUFF((SELECT ',' + cast(Event_Seq as varchar(5)) FROM [MO_Events] WHERE Successor = e.Event_Seq and MONo = e.MONo FOR XML PATH('')), 1, 1, ''),e.Predecessor) AS Pred
	, isnull(STUFF((SELECT ',' + cast(Event_Seq as varchar(5)) FROM [MO_Events] WHERE Predecessor = e.Event_Seq and MONo = e.MONo FOR XML PATH('')), 1, 1, ''),e.Successor) AS Succ
	FROM [MO_Events] e 
	)  ME
	INNER JOIN DBO.BO_HDR BH ON
		BH.MONO = ME.MONO
	WHERE
		BH.MONO = @MONUM



	CREATE NONCLUSTERED INDEX IDX_BOEVENTS_MOBO ON #BOEVENTS(MONO, BONO)

	----START OF POPULATING BOEVENTS
	DECLARE @MOBOLIST TABLE (SEQ INT IDENTITY(1, 1), MONO VARCHAR(50), BONO VARCHAR(50), MFG_LOC VARCHAR(50))
	DECLARE @MONO VARCHAR(50)
	DECLARE @BONO VARCHAR(10)
	DECLARE @MFGLOC VARCHAR(50)
	DECLARE @SEWSEQ INT
	DECLARE @SEQ INT
	DECLARE @MAXSEQ INT
	DECLARE @POSEQ INT


	INSERT INTO @MOBOLIST (MONO, BONO, MFG_LOC)
	SELECT DISTINCT MONO, BONO, MFG_LOC FROM #BOEVENTS ORDER BY MFG_LOC, MONO, BONO

	--SET @MFGLOC = (SELECT TOP 1 MFGLOC FROM #BOEVENTS)

	DECLARE @LOOP INT = 1
	DECLARE @LOOPSUCCESSOR INT
	DECLARE @LOOPPREDECESSOR INT


	WHILE (@LOOP <= (SELECT COUNT(1) FROM @MOBOLIST))
	BEGIN
		SELECT
			@MONO = MONO,
			@BONO = BONO,
			@MFGLOC = MFG_LOC
		FROM 
			@MOBOLIST
		WHERE 
			SEQ = @LOOP

		SELECT
			@SEWSEQ = MIN(CASE WHEN VAP = 'SEW' THEN SEQ ELSE NULL END),
			@MAXSEQ = MAX(SEQ),
			@POSEQ = MIN(CASE WHEN EVENT_SEQ = '605' THEN SEQ ELSE NULL END)
		FROM 
			#BOEVENTS
		WHERE
			MONO = @MONO AND
			BONO = @BONO AND
			MFG_LOC = @MFGLOC


		SET @SEQ = @SEWSEQ
		WHILE (@SEQ <= (SELECT MAX(SEQ) FROM #BOEVENTS WHERE MONO = @MONO AND BONO = @BONO AND MFG_LOC = @MFGLOC))
		BEGIN
			UPDATE BE
			SET REQ_START = CASE 
								WHEN BE.REQ_DURATION = 0 THEN 
									CASE WHEN BE.REQ_START IS NULL THEN BE2.REQ_START 
									ELSE CASE WHEN BE.REQ_START < BE2.REQ_START THEN BE.REQ_START ELSE BE2.REQ_START END END
								WHEN BE.REQ_START IS NOT NULL AND 
									 BE.REQ_START < [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, BE2.REQ_END, 1)
									 THEN BE.REQ_START
								ELSE [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, BE2.REQ_END, 1)
						   END,
				REQ_END = CASE 
							WHEN BE.REQ_DURATION = 0 THEN 
									CASE WHEN BE.REQ_END IS NULL THEN BE2.REQ_END 
									ELSE CASE WHEN BE.REQ_END < BE2.REQ_END THEN BE.REQ_END ELSE BE2.REQ_END END END
							WHEN BE.REQ_END IS NOT NULL AND 
								 BE.REQ_END < [DBO].[PRDGETDURATIONWORKDATE](BE.REQ_DURATION, BE.MFG_LOC, BE2.REQ_END, 1)
								 THEN BE.REQ_END
							ELSE [DBO].[PRDGETDURATIONWORKDATE](BE.REQ_DURATION, BE.MFG_LOC, BE2.REQ_END, 1)
						 END
			FROM 
				#BOEVENTS BE
			INNER JOIN 
				#BOEVENTS BE2 ON 
				--BE2.EVENTSEQ = BE.PREDECESSOR AND 
				CHARINDEX(CAST(BE2.EVENTSEQ AS VARCHAR), BE.PREDECESSOR, 1) > 0 AND
				BE2.MONO = BE.MONO AND
				BE2.BONO = BE.BONO AND
				BE2.MFG_LOC = BE.MFG_LOC
			WHERE 
				BE.MONO = @MONO AND
				BE.BONO = @BONO AND
				BE.MFG_LOC = @MFGLOC AND
				BE2.SEQ = @SEQ

			SET @SEQ = @SEQ + 1
		END	
		--SELECT * FROM #BOEVENTS

		UPDATE BE
		SET 
			--POSTART = [DBO].[PRDGETDURATIONWORKDATE](BE.REQDURATION, BE.MFGLOC, 
			--(SELECT TOP 1 PODDT FROM IMAPPS.DBO.MODET WHERE MONO = @MONO AND QTY > 0), 0),
			POSTART = [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, ([DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, 
					  (SELECT TOP 1 POD_DT FROM IMAPPS.DBO.MO_DET WHERE MONO = @MONO AND QTY > 0), 1)), -1),
			POEND = [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, ([DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, 
					(SELECT TOP 1 POD_DT FROM IMAPPS.DBO.MO_DET WHERE MONO = @MONO AND QTY > 0), 1)), -1)
		FROM 
			#BOEVENTS BE
		WHERE 
			MONO = @MONO AND
			BONO = @BONO AND
			MFG_LOC = @MFGLOC AND
			SEQ = @POSEQ --Shipment	
		--SELECT * FROM #BOEVENTS

		SET @SEQ = @POSEQ		
		WHILE (@SEQ < @MAXSEQ)
		BEGIN
			--PRINT @SEQ

			UPDATE BE
			SET POSTART = CASE 
								WHEN BE.REQ_DURATION = 0 THEN 
									CASE WHEN BE.PO_START IS NULL THEN BE2.PO_START 
									ELSE CASE WHEN BE.PO_START < BE2.PO_START THEN BE.PO_START ELSE BE2.PO_START END END
								WHEN BE.PO_START IS NOT NULL AND 
									 BE.PO_START < [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, BE2.PO_END, 1)
									 THEN BE.PO_START
								ELSE [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFGL_OC, BE2.PO_END, 1) 
						  END,
				POEND = CASE 
							WHEN BE.REQ_DURATION = 0 THEN 
									CASE WHEN BE.PO_END IS NULL THEN BE2.PO_END 
									ELSE CASE WHEN BE.PO_END < BE2.PO_END THEN BE.PO_END ELSE BE2.PO_END END END
							WHEN BE.PO_END IS NOT NULL AND
								 BE.PO_END < [DBO].[PRDGETDURATIONWORKDATE](BE.REQ_DURATION, BE.MFG_LOC, BE2.PO_END, 1)
								 THEN BE.PO_END
							ELSE [DBO].[PRDGETDURATIONWORKDATE](BE.REQ_DURATION, BE.MFG_LOC, BE2.PO_END, 1) 
						END
			--SELECT BE2.*
			FROM 
				#BOEVENTS BE
				INNER JOIN #BOEVENTS BE2 ON 
					--BE2.EVENTSEQ = BE.PREDECESSOR AND
					CHARINDEX(CAST(BE2.EVENT_SEQ AS VARCHAR), BE.PREDECESSOR, 1) > 0 AND
					BE2.MONO = BE.MONO AND
					BE2.BONO = BE.BONO AND
					BE2.MFG_LOC = BE.MFG_LOC
			WHERE 
				BE.MONO = @MONO AND
				BE.BONO = @BONO AND
				BE.MFG_LOC = @MFGLOC AND
				BE2.SEQ = @SEQ

			SET @SEQ = @SEQ + 1
		END
		--SELECT * FROM #BOEVENTS

		SET @SEQ = @POSEQ
		WHILE (@SEQ > @SEWSEQ)
		BEGIN
			UPDATE BE 
			SET PO_START = CASE 
								WHEN BE.REQ_DURATION = 0 THEN 
									CASE WHEN BE.PO_START IS NULL THEN BE2.PO_START 
									ELSE CASE WHEN BE.PO_START < BE2.PO_START THEN BE.PO_START ELSE BE2.PO_START END END
								WHEN BE.PO_START IS NOT NULL AND 
									 BE.PO_START < [DBO].[PRDGETDURATIONWORKDATE](BE.REQ_DURATION, BE.MFG_LOC, BE2.PO_START, -1)
									 THEN BE.PO_START
								ELSE [DBO].[PRDGETDURATIONWORKDATE](BE.REQ_DURATION, BE.MFG_LOC, BE2.PO_START, -1) 
						  END,
				POEND = CASE 
							WHEN BE.REQ_DURATION = 0 THEN 
									CASE WHEN BE.PO_END IS NULL THEN BE2.PO_END 
									ELSE CASE WHEN BE.PO_END < BE2.PO_END THEN BE.PO_END ELSE BE2.PO_END END END
							WHEN BE.PO_END IS NOT NULL AND
								 BE.PO_END < [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, BE2.PO_START, -1)
								 THEN BE.PO_END
							ELSE [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, BE2.PO_START, -1) 
						END
			FROM 
				#BOEVENTS BE
				INNER JOIN 
				#BOEVENTS BE2 ON 
					--BE2.PREDECESSOR = BE.EVENTSEQ AND
					CHARINDEX(CAST(BE.EVENT_SEQ AS VARCHAR), BE2.PREDECESSOR, 1) > 0 AND
					BE2.MONO = BE.MONO AND
					BE2.BONO = BE.BONO AND
					BE2.MFG_LOC = BE.MFG_LOC
			WHERE 
				BE.MONO = @MONO AND
				BE.BONO = @BONO AND
				BE.MFG_LOC = @MFGLOC AND
				BE2.SEQ = @SEQ
					
				SET @SEQ = @SEQ - 1
		END
		--SELECT * FROM #BOEVENTS

		SET @SEQ = @SEWSEQ
		WHILE (@SEQ >= 1)
		BEGIN
			UPDATE BE 
			SET REQ_START = CASE 
								WHEN BE.REQ_DURATION = 0 THEN 
									CASE WHEN BE.REQ_START IS NULL THEN BE2.REQ_START 
									ELSE CASE WHEN BE.REQ_START < BE2.REQ_START THEN BE.REQ_START ELSE BE2.REQ_START END END
								WHEN BE.REQ_START IS NOT NULL AND 
									 BE.REQ_START < [DBO].[PRDGETDURATIONWORKDATE](BE.REQ_DURATION, BE.MFG_LOC, BE2.REQ_START, -1)
									 THEN BE.REQ_START
								ELSE [DBO].[PRDGETDURATIONWORKDATE](BE.REQ_DURATION, BE.MFG_LOC, BE2.REQ_START, -1) 
						   END,
				REQ_END = CASE 
							WHEN BE.REQ_DURATION = 0 THEN 
									CASE WHEN BE.REQ_END IS NULL THEN BE2.REQ_END 
									ELSE CASE WHEN BE.REQ_END < BE2.REQ_END THEN BE.REQ_END ELSE BE2.REQ_END END END
							WHEN BE.REQ_END IS NOT NULL AND 
								 BE.REQ_END < [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, BE2.REQ_START, -1)
								 THEN BE.REQ_END
							ELSE [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, BE2.REQ_START, -1) 
						 END,
				PO_START = CASE 
								WHEN BE.REQ_DURATION = 0 THEN 
									CASE WHEN BE.PO_START IS NULL THEN BE2.PO_START 
									ELSE CASE WHEN BE.PO_START < BE2.PO_START THEN BE.PO_START ELSE BE2.PO_START END END
								WHEN BE.PO_START IS NOT NULL AND 
									 BE.PO_START < [DBO].[PRDGETDURATIONWORKDATE](BE.REQ_DURATION, BE.MFG_LOC, BE2.PO_START, -1)
									 THEN BE.PO_START
								ELSE [DBO].[PRDGETDURATIONWORKDATE](BE.REQ_DURATION, BE.MFG_LOC, BE2.PO_START, -1) 
						  END,
				PO_END = CASE 
							WHEN BE.REQ_DURATION = 0 THEN 
									CASE WHEN BE.PO_END IS NULL THEN BE2.PO_END 
									ELSE CASE WHEN BE.PO_END < BE2.PO_END THEN BE.PO_END ELSE BE2.PO_END END END
							WHEN BE.PO_END IS NOT NULL AND
								 BE.PO_END < [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, BE2.PO_START, -1)
								 THEN BE.PO_END
							ELSE [DBO].[PRDGETDURATIONWORKDATE](1, BE.MFG_LOC, BE2.PO_START, -1) 
						END
			FROM 
				#BOEVENTS BE
				INNER JOIN 
				#BOEVENTS BE2 ON 
					--BE2.EVENTSEQ = BE.SUCCESSOR AND
					CHARINDEX(CAST(BE2.EVENT_SEQ AS VARCHAR), BE.SUCCESSOR, 1) > 0 AND
					BE2.MONO = BE.MONO AND
					BE2.BONO = BE.BONO AND
					BE2.MFG_LOC = BE.MFG_LOC
			WHERE 
				BE.MONO = @MONO AND
				BE.BONO = @BONO AND
				BE.MFG_LOC = @MFGLOC AND
				BE2.SEQ = @SEQ

				SET @SEQ = @SEQ - 1
		END
		--SELECT * FROM #BOEVENTS

		SET @LOOP = @LOOP + 1
	END

	DELETE BE
	FROM DBO.BO_EVENTS BE
	WHERE EXISTS(SELECT 1 FROM #BOEVENTS SQ WHERE SQ.MONO = BE.MONO AND SQ.BONO = BE.BONO AND SQ.MFG_LOC = BE.MFG_LOC)


	INSERT INTO DBO.BO_EVENTS
	(
		MONO, BONO, REC_ID, EVENT_SEQ, KEY_EVENT, REQ_START, REQ_END, PLAN_START, PLAN_END, 
		PO_START, PO_END, ACTUAL_START, ACTUAL_END, REQ_DURATION, PLAN_DURATION, ACTUAL_DURATION, 
		RESPONSIBLE, VAP, REMARKS, PREDECESSOR, SUCCESSOR, DELETED, CREATED_BY, LEAD_LAG, MFG_LOC
	)
	SELECT
		BE.MONO, BE.BONO, BE.REC_ID, BE.EVENT_SEQ, BE.KEY_EVENT, BE.REQ_START, BE.REQ_END,
		BE.PLAN_START, BE.PLAN_END, BE.PO_START, BE.PO_END, BE.ACTUAL_START, BE.ACTUAL_END, 
		BE.REQ_DURATION, BE.PLAN_DURATION, BE.ACTUAL_DURATION,BE.RESPONSIBLE, BE.VAP, 
		BE.REMARKS, BE.PREDECESSOR, BE.SUCCESSOR, BE.active, BE.CREATED_BY, BE.LEAD_LAG, MFG_LOC
	FROM #BOEVENTS BE
	----END OF POPULATING BOEVENTS


	----START OF POPULATING MOEVENTS
	DECLARE @MOLIST TABLE (NUM INT IDENTITY(1, 1), MONO VARCHAR(50))
	INSERT INTO @MOLIST (MONO)
	SELECT DISTINCT MONO FROM #BOEVENTS

	DECLARE @ROWNUM INT, @NUM INT, @MO VARCHAR(50)

	SELECT @NUM = MAX(NUM) FROM @MOLIST
	SELECT @ROWNUM = Count(*) FROM @MOLIST
	
	WHILE @ROWNUM > 0
	BEGIN
		SELECT @MO = MONO FROM @MOLIST WHERE NUM = @NUM
		
		EXEC stg_PLNUPDATEMO_CP @MO,@USERID

		SELECT TOP 1 @NUM = NUM FROM @MOLIST WHERE NUM < @NUM ORDER BY NUM DESC
		SET @ROWNUM = @ROWNUM - 1
	END		
	----END OF POPULATING MOEVENTS

	--SELECT * FROM #BOEVENTS
	--SELECT SEQ, EVENTSEQ, PREDECESSOR, SUCCESSOR, VAP, REQSTART, REQEND, REQDURATION, POSTART, POEND FROM #BOEVENTS ORDER BY SEQ
	--DROP TABLE #BOEVENTS
	
	IF OBJECT_ID('TEMPDB..#BOEVENTS') IS NOT NULL DROP TABLE #BOEVENTS
	SELECT 0 AS [STATUS], 'UPDATED' AS ERROR_MSG

END TRY
BEGIN CATCH
	SELECT ERROR_MESSAGE()
END CATCH


go

--exec usp_download_asnxfga_with_update @pono  = 'PO21Q1LW00313', @withDelete = 1
 --exec usp_download_asnxfga_with_update @pono ='PO21Q1LW00313', @withDelete =1
CREATE procedure usp_download_asnxfga_with_update
--declare
  @pono varchar(20) = '',
  @withDelete bit = 0
as

-- declare
--   @pono varchar(20) = 'PO20Q3JW00690',
--   @withDelete bit = 1

BEGIN
  --set @pono = 'POC22Q2JT0300250'
  PRINT '----------------- 1. Varialble Declaration -----------------'

  declare @poid varchar(20)
  select @poid = POID from tmp.dbo.btPurchaseOrders where PONumber  = @pono
  --select poid = POID from tmp.dbo.btPurchaseOrders where PONumber  = 'POC22Q2JT0300250'
  BEGIN TRY
      BEGIN TRAN DownloadASNxFgaPO
      if ( @withDelete = 1)
      BEGIN
          --2. delete all tables affected for orders
          delete from fg_carton_allocation where carton_id in (select id from fg_carton where purchase_order_dtl_id in (select id from fg_purchase_order_dtl where purchase_order_id in (select id from fg_purchase_order where pono = @pono)))
          delete from fg_carton where purchase_order_dtl_id in (select id from fg_purchase_order_dtl where purchase_order_id in (select id from fg_purchase_order where pono = @pono ))
          delete from fg_purchase_order_dtl where purchase_order_id in (select id from fg_purchase_order where pono =@pono )
          delete from fg_purchase_order where pono = @pono
         -- if (@@error <> 0) goto err
      END

      PRINT '-----------------  2. Download Purchase Order -----------------'
      insert into  dbo.fg_purchase_order(
        active, created_by, sbu_id, time_created, time_updated, updated_by,
        asn_no, booking_no, code, color_desc_cn, color_desc_en, customer_order_no, delivery_seq,
        description, ex_fty_date, invoice_no, iono, order_qty, pono, rev_ex_fty_date,
        revised_style_code, ship_date, ship_mode, ship_to, ship_to_remarks, store_code, style_code, vendor, factory, buyer, status_code, downloaded, downloaded_date)
      select
          active = 1, created_by ='System', sbu_id=1, time_created = getdate(), time_updated = null , updated_by = null,
          asn_no = '', booking_no = '', code = POID, color_desc_cn = '', color_desc_en = '', customer_order_no ='', delivery_seq = '',
          description = '', ex_fty_date = '', invoice_no = '', iono = POID,
          order_qty = 0,
          pono = PONumber, rev_ex_fty_date = '',
          revised_style_code = '', ship_date = null , ship_mode = null, ship_to = null , ship_to_remarks = null , store_code = '',
          style_code = '', vendor = '', factory = FacLocCode, BuyerCode, StatusCode, 1 as downloaded, getdate()
      from tmp.dbo.btPurchaseOrders
      where POID = @poid and PONumber  not in (
          select pono COLLATE DATABASE_DEFAULT
          from fg_purchase_order x
          WHERE x.pono = @pono
      )

      PRINT '-----------------  3. DELETE  tmp first  -----------------'
      DELETE FROM fg_purchase_order_dtl_tmp where POID = @poid
      --if (@@error <> 0) goto err

      PRINT '-----------------  4. insert into tmp first -----------------'
      insert into  dbo.fg_purchase_order_dtl_tmp(
          active, created_by, sbu_id, time_created, time_updated, updated_by,
          asn_date, asn_no, booking_no, carrier_code,  eta,
          etd, factory_loc_code, invoice_date, invoice_no, ship_date,
        shipment_code, shipper_code, split_no, purchase_order_id, POID)
      select active = 1, created_by ='System', sbu_id=1, time_created = getdate(), time_updated = null , updated_by = null,
        asn_date = b.ASNDate, asn_no = b.ASNNo, booking_no = b.BookingNo, carrier_code=b.CarrierCode,  eta = b.ETA,
        etd = b.ETD, factory_loc_code = b.FacLocCode, invoice_date = b.InvoiceDate, invoice_no = b.InvoiceNo, ship_date = b.ShipDate,
        shipment_code = b.ShipmentCode, shipper_code = b.ShipperCode, split_no = a.SplitNo,
        purchase_order_id = (select id from  dbo.fg_purchase_order where pono COLLATE DATABASE_DEFAULT = c.PONumber COLLATE DATABASE_DEFAULT ),
        a.POID
      from tmp.dbo.btPOSplits a
      left outer join  tmp.dbo.btShipments b on a.POID = b.POID and a.SplitNo = b.SplitNo
      inner join tmp.dbo.btPurchaseOrders c on a.POID = c.POID
      where a.POID =   @poid
      --if (@@error <> 0) goto err

      PRINT '-----------------  5. insert fg_purchase_order_dtl from tmp if not exist -----------------'
      insert into  dbo.fg_purchase_order_dtl(
        active, created_by, sbu_id, time_created, time_updated,
        updated_by,
        asn_date, asn_no, booking_no, carrier_code,  eta,
        etd, factory_loc_code, invoice_date, invoice_no, ship_date,
      shipment_code, shipper_code, split_no, purchase_order_id, POID)

      select a.active, a.created_by, a.sbu_id, a.time_created, getdate(),
        a.updated_by,
        a.asn_date, a.asn_no, a.booking_no, a.carrier_code,  a.eta,
        a.etd, a.factory_loc_code, a.invoice_date, a.invoice_no, a.ship_date,
        a.shipment_code, a.shipper_code, a.split_no, a.purchase_order_id, a.POID
      --SELECT a.*
      from fg_purchase_order_dtl_tmp a
        left join fg_purchase_order_dtl b on a.POID COLLATE DATABASE_DEFAULT = b.poid COLLATE DATABASE_DEFAULT
        and a.split_no  = b.split_no and a.POID = @poid
      where  a.POID = @poid and b.id is null
      --if (@@error <> 0) goto err

      PRINT '-----------------  6. UPDATE Order Detail if ASN is null -----------------'
      update fg_purchase_order_dtl set asn_date  = a.asn_date, asn_no = a.asn_no, booking_no = a.booking_no, carrier_code = a.carrier_code,
          eta = a.eta, etd = a.etd, factory_loc_code = a.factory_loc_code, invoice_date = a.invoice_date, invoice_no = a.invoice_no, ship_date = a.ship_date,
          shipment_code = a.shipment_code, shipper_code = a.shipment_code
      from fg_purchase_order_dtl_tmp a
        left join fg_purchase_order_dtl b on a.POID COLLATE DATABASE_DEFAULT = b.poid COLLATE DATABASE_DEFAULT
        and a.split_no  = b.split_no
      where b.asn_no is null and a.POID = @poid
      --if (@@error <> 0) goto err

      PRINT '-----------------  7. GET Packing List First to use for cartons and carton allocations -----------------'
      DELETE FROM tmp.dbo.packing_list where POID = @poid
      insert into tmp.dbo.packing_list(POID, SplitNo, PONumber, CartonNo, UCCNo, Style, Color, POShade, POQuality, Size, Qty, SizeSort, Packtype, Weight, AccWeight, CartonWeight, Length, Width, Height, CBM)
      SELECT A.POID, b.SplitNo, A.PONumber, E.CartonNo
      , E.UCCNo as UCCNo
      , M.Style, M.Color, ISNULL(Y.Infocode,'') as POShade , ISNULL(Z.InfoCode,'1') as POQuality
      ,M.Size, F.PackedQty  AS Qty, O.SizeSort, Case When G.UserCreated = 1 then 'SLD' else UPPER(J.PackType) end as Packtype
      ,convert(numeric(14,6), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = M.WeightUOM and ToUOMCode = 'KG' ) * M.Weight,0))  as Weight
      ,convert(numeric(14,6), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = M.WeightUOM and ToUOMCode = 'KG' ) * M.AccWeight,0)) as AccWeight
      ,convert(numeric(14,6), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = I.WeightUOM and ToUOMCode = 'KG' ) * I.Weight,0)) as CartonWeight
      ,convert(numeric(12,0), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = I.DimensionUOM and ToUOMCode = 'MM') * I.Length, 0)) as Length
      ,convert(numeric(12,0), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = I.DimensionUOM and ToUOMCode = 'MM') * I.Width, 0)) as Width
      ,convert(numeric(12,0), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = I.DimensionUOM and ToUOMCode = 'MM') * I.Height, 0)) as Height
      ,convert(numeric(14,6), isnull((select Multiplier from tmp.dbo.btConversions where FromUOMCode = I.VolumeUOM and ToUOMCode = 'CR') * I.Volume,0)) as CBM
      FROM (Select * FROM tmp.dbo.btPurchaseOrders Where POID = @poid ) A
      INNER JOIN (Select * FROM tmp.dbo.btPOSplits Where POID = @poid  ) B ON A.POID = B.POID
      LEFT JOIN (Select * FROM tmp.dbo.btShipments Where POID = @poid  ) C ON B.POID = C.POID AND B.SplitNo = C.SplitNo
      LEFT JOIN (Select * FROM tmp.dbo.btCartons Where POID = @poid  ) E ON B.POID = E.POID AND B.SplitNo = E.SplitNo
      LEFT JOIN (Select * FROM tmp.dbo.btCartonitems Where POID = @poid  ) F ON E.POID = F.POID AND E.SplitNo = F.SplitNo AND E.CartonNo = F.CartonNo -- for mixed cartons
      LEFT JOIN (Select * FROM tmp.dbo.btSplititems Where POID = @poid  ) D ON F.POID = D.POID AND F.SplitNo = D.SplitNo  AND F.SplitItemNo = D.SplitItemNo
      LEFT JOIN (Select * FROM tmp.dbo.btPackingDefinition Where POID = @poid  ) G ON F.POID = G.POID AND F.SplitNo = G.SplitNo AND F.PackDefID = G.PackDefID
      LEFT JOIN (Select * FROM tmp.dbo.btPackDefItems Where POID = @poid  ) H ON F.POID = H.POID AND F.SplitNo = H.SplitNo AND F.PackDefID = H.PackDefID AND F.SplititemNo = H.SplititemNo
      INNER JOIN tmp.dbo.btCartonTypes I ON E.CtnTypeCode = I.CtnTypeCode
      INNER JOIN (Select * FROM tmp.dbo.btCartonTemplates Where POID = @poid  ) J ON E.POID = J.POID AND E.SplitNo = J.SplitNo AND E.CtnTmpCode = J.CtnTmpCode
      LEFT JOIN (Select * FROM tmp.dbo.btProducts Where POID = @poid) M ON  D.ProductID = M.ProductID AND D.POID = M.POID
      LEFT JOIN tmp.dbo.btStores N ON E.FacLocCode = N.FacLocCode AND E.StoreCode = N.StoreCode
      LEFT JOIN tmp.dbo.btSizeHierarchy O ON  M.FacLocCode = O.FacLocCode AND M.Size = O.SizeCode
      LEFT JOIN (Select * FROM tmp.dbo.btProductInfo Where POID = @poid  ) Y ON D.POID = Y.POID and  D.SplitNo = Y.SplitNo and  D.SplitItemNo = Y.SplitItemNo and Y.InfoQualifier = 'SHD'
      LEFT JOIN (Select * FROM tmp.dbo.btProductInfo Where POID = @poid  ) Z ON D.POID = Z.POID and  D.SplitNo = Z.SplitNo and  D.SplitItemNo = Z.SplitItemNo and Z.InfoQualifier = 'QLT'
      WHERE A.POID = @poid
     -- if (@@error <> 0) goto err

      PRINT '-----------------  8. INSERT INTO CARTON FROM PACKING LIST -----------------'
      insert into  dbo.fg_carton(active, created_by, sbu_id, time_created, time_updated, updated_by,
                                         purchase_order_id, ucc_barcode, carton_no, carton_qty,
                                         length, width, height, gross_weight, net_weight, nnw , purchase_order_dtl_id,
                                         split_no
      )
      select active = 1, created_by ='System', sbu_id=1, time_created = getdate(), time_updated = null , updated_by = null,
          purchase_order_id = (select id from  dbo.fg_purchase_order where pono COLLATE DATABASE_DEFAULT = a.PONumber COLLATE DATABASE_DEFAULT ),
          ucc_barcode = a.UCCNo, carton_no = CartonNo, carton_qty = sum(Qty),
          length, width, height, gross_weight = 0, net_weight = 0 , nnw = 0,
          purchase_order_dtl_id = (select id from  dbo.fg_purchase_order_dtl where POID  COLLATE DATABASE_DEFAULT = a.POID COLLATE DATABASE_DEFAULT and split_no = a.SplitNo ),
          a.SplitNo
      from  tmp.dbo.packing_list a
      WHERE POID =  @poid
          and CartonNo  not in (
          select carton_no
          from fg_purchase_order x
          inner join fg_purchase_order_dtl f2 on x.id = f2.purchase_order_id
          inner join fg_carton fc on f2.id = fc.purchase_order_dtl_id
          WHERE x.pono = @pono )
      group by length, width, height,a.UCCNo,CartonNo, a.PONumber, a.POID, a.SplitNo
      order by a.PONumber, carton_no
      --if (@@error <> 0) goto err

      PRINT '-----------------  9. INSERT INTO CARTON ALLCATION FROM PACKING LIST -----------------'
      INSERT INTO  dbo.fg_carton_allocation(
        active, created_by, sbu_id, time_created, time_updated, updated_by,
        color, qty, size, sku, style, upc_barcode, carton_id)

      select active = 1, created_by ='System', sbu_id=1, time_created = getdate(), time_updated = null , updated_by = null,
            color, qty, size, sku = '', style, upc_barcode = '',
            carton_id  = (SELECT ID FROM fg_carton WHERE carton_no  =  A.CartonNo
                                                         AND Split_No = a.SplitNo
                                                         AND purchase_order_id   =  (SELECT ID FROM fg_purchase_order WHERE CODE COLLATE DATABASE_DEFAULT = A.POID COLLATE DATABASE_DEFAULT )
        )
      from  tmp.dbo.packing_list a
      WHERE POID = @poid
        and CartonNo  not in (
        select carton_no
        from fg_purchase_order x
        inner join fg_purchase_order_dtl f2 on x.id = f2.purchase_order_id
        inner join fg_carton fc on f2.id = fc.purchase_order_dtl_id
        inner join fg_carton_allocation a2 on fc.id = a2.carton_id
        WHERE x.pono =  @pono
      )
      --if (@@error <> 0) goto err

    -- udpate order qty in the header
    declare @orderQty int = 0
    select @orderQty = sum(fc2.carton_qty) from fg_purchase_order a
      inner join fg_purchase_order_dtl b on a.id = b.purchase_order_id
      inner join fg_carton fc2 on b.id = fc2.purchase_order_dtl_id
    where a.pono = @pono
    update dbo.fg_purchase_order set order_qty = @orderQty where pono = @pono

    COMMIT TRAN DownloadASNxFgaPO
    SELECT code = 'download', description = 'successful'
  END TRY
  BEGIN CATCH
    PRINT '-----------------  10. END CATCH -----------------'
    ROLLBACK TRAN DownloadASNxFgaPO
    SELECT code = 'download', description = 'failed'
  END CATCH;
  return
    err:
    ROLLBACK TRAN DownloadASNxFgaPO
    SELECT code = 'download', description = 'failed'

END
go




CREATE PROCEDURE [dbo].[prdGetBoDiscrepancySP] (@MfgLoc varchar(50), @User nvarchar(50))  

AS  

BEGIN  
    
	---- FOR TESTING PURPOSES
	--DECLARE @MfgLoc varchar(50), @User nvarchar(50)
	--SET @MfgLoc = 'BATAAN2'
	--SET @User = 'aj'

	SELECT H.Line, H.MONo, H.BONo, H.Plan_Qty as Plan_Qty, D.Output_Qty as Output_Qty, (H.Plan_Qty-D.Output_Qty) as 'Balance'
	FROM

		(SELECT BO_Hdr.Line, BO_Hdr.MONO, BO_Hdr.BONO, MO_Hdr.Remarks, cast(SUM(Plan_Qty) as numeric) as Plan_Qty
		FROM BO_Hdr 
		inner join MO_Hdr on BO_Hdr.MONo = MO_Hdr.MONo
		WHERE BO_Hdr.Mfg_Loc = @MfgLoc
		GROUP BY BO_Hdr.Line, BO_Hdr.MONO, BO_Hdr.BONO, MO_Hdr.Remarks) H 
		
		INNER JOIN
		
		(SELECT BO_Daily_Output.Line, BO_Daily_Output.MONO, BO_Daily_Output.BONO, MO_Hdr.Remarks, cast(SUM(Qty) as numeric) as Output_Qty
		FROM BO_Daily_Output 
		inner join MO_Hdr on BO_Daily_Output.MONo = MO_Hdr.MONo
		GROUP BY BO_Daily_Output.Line, BO_Daily_Output.MONO, BO_Daily_Output.BONO, MO_Hdr.Remarks) D
	
	ON H.MONO = D.MONO and H.BONo = D.BONo
	WHERE H.Plan_Qty < D.Output_Qty
	ORDER BY Line, MONo



	--SELECT SUBSTRING((SELECT DISTINCT Line + ', ' FROM BOHdr WHERE MfgLoc = @MfgLoc and MONo = B.MONo FOR XML PATH('')), 1, LEN((SELECT DISTINCT Line + ', ' FROM BOHdr WHERE MfgLoc = @MfgLoc and MONo = B.MONo FOR XML PATH('')))-1) as Line, 
	--	B.MONo, M.Remarks, M.MOQty as POQty, B.BOQty as PlannedQty, (M.MOQty-B.BOQty) as 'UnplannedQty'
	--FROM

	--	(SELECT MOHdr.MfgLoc, MOHdr.MONO, MOHdr.Remarks, cast(SUM(Qty) as numeric) as MOQty
	--	FROM MODet inner join MOHdr on MODet.MONo = MOHdr.MONo
	--	WHERE MOHdr.MfgLoc = @MfgLoc
	--	GROUP BY MOHdr.MfgLoc, MOHdr.MONO, MOHdr.Remarks) M 
		
	--	INNER JOIN
		
	--	(SELECT MfgLoc as MfgLoc,MONO, '' as Remarks, cast(SUM(PlanQty) as numeric) as BOQty
	--	FROM BOHdr
	--	WHERE MfgLoc = @MfgLoc
	--	GROUP BY MfgLoc,MONO) as B 
	
	--ON M.MONO = B.MONO 
	--WHERE M.MOQty <> B.BOQty


  
END


go



CREATE PROC [dbo].[prdInsertMOSVAPPartsp]
(
	@MONO VARCHAR(20)
)
AS
BEGIN
	--INSERT LOAD OFF OPERATION
		
		INSERT INTO MO_SVAP_Part(MONo,Seq,Part_Cd,VAP,SVAP,Deleted,Created_By,time_Created)
			SELECT DISTINCT  X.MONO,X.SEQ,Feature,X.VAP,X.SVAP,0,'system',GETDATE()
			FROM MO_VAP_SVAP X
			OUTER APPLY (
				SELECT m_SVAP.VAP,m_SVAP.code,GVAP FROM 
				m_SVAP 
				INNER JOIN m_VAP ON m_SVAP.VAP = m_VAP.code--m_VAP.VAP
				WHERE GVAP IN
				(
				SELECT GVAP
				FROM MO_VAP_SVAP A
				WHERE A.MONo = @MONO
				AND A.VAP = X.VAP
				AND Load_On = 1
				) AND [Check_point] = 0
			) CHK 
			INNER JOIN (
							SELECT MONO,Feature,GVAP,IssGVAP FROM 
							(
							SELECT DISTINCT TOP 100 PERCENT dbo.OB.MONo, dbo.OB.Feature, dbo.OB.Seq, dbo.OB.VAP, dbo.OB.SVAP, dbo.OB.smv, dbo.m_SVAP.GVAP
							,LAG(dbo.m_SVAP.GVAP, 1,'') OVER (PARTITION BY OB.Feature ORDER BY OB.Feature, OB.Seq) AS IssGVAP
							FROM     dbo.OB INNER JOIN
											  dbo.m_SVAP ON dbo.OB.SVAP = dbo.m_SVAP.code AND dbo.OB.VAP = dbo.m_SVAP.VAP
							WHERE  (dbo.OB.MONo = @MONO) ORDEr BY OB.Feature, OB.Seq
							) x 
							WHERE IssGVAP <> ''
						) PART  ON X.MONO = PART.MONO AND PART.GVAP = CHK.GVAP AND PART.ISSGVAP = X.GVAP
			WHERE X.MONO = @MONO
			--AND X.VAP = 'ICUT-GLU'
			AND Load_Off = 1 AND X.MONO+Feature+X.VAP+X.SVAP NOT IN (SELECT MONO+Part_Cd+VAP+SVAP FROM MO_SVAP_Part WHERE MONo = @MONO)

	--INSERT LOAD ON OPERATION
		
		INSERT INTO MO_SVAP_Part(MONo,Seq,Part_Cd,VAP,SVAP,Deleted,Created_By,time_Created)
			SELECT DISTINCT X.MONO,X.SEQ,FEATURE,X.VAP,X.SVAP,0,'system',GETDATE()
			FROM MO_VAP_SVAP X
			OUTER APPLY (
				SELECT m_SVAP.VAP,m_SVAP.code,ISNULL(GVAP,'CUT') AS GVAP FROM 
				m_SVAP 
				INNER JOIN m_VAP ON m_SVAP.VAP = m_VAP.code
				WHERE GVAP IN
				(
				SELECT GVAP
				FROM MO_VAP_SVAP A
				WHERE A.MONo = @MONO
				AND A.VAP = X.VAP
				AND Load_Off = 1
				) AND [Check_point] = 0
			) CHK 
			INNER JOIN (
							SELECT MONO,Feature,GVAP,IssGVAP FROM 
							(
							SELECT DISTINCT TOP 100 PERCENT dbo.OB.MONo, dbo.OB.Feature, dbo.OB.Seq, dbo.OB.VAP, dbo.OB.SVAP, dbo.OB.smv, dbo.m_SVAP.GVAP
							,LAG(dbo.m_SVAP.GVAP, 1,'CUT') OVER (PARTITION BY OB.Feature ORDER BY OB.Feature, OB.Seq) AS IssGVAP
							FROM     dbo.OB INNER JOIN
											  dbo.m_SVAP ON dbo.OB.SVAP = dbo.m_SVAP.code AND dbo.OB.VAP = dbo.m_SVAP.VAP
							WHERE  (dbo.OB.MONo = @MONO) ORDEr BY OB.Feature, OB.Seq
							) x 
						) PART  ON X.MONO = PART.MONO AND PART.GVAP = X.GVAP AND ISNULL(PART.ISSGVAP,'CUT') = ISNULL(CHK.GVAP,'CUT')
			WHERE X.MONO = @MONO
			AND Load_On = 1 AND X.MONO+Feature+X.VAP+X.SVAP NOT IN (SELECT MONO+Part_Cd+VAP+SVAP FROM MO_SVAP_Part WHERE MONo = @MONO)

		
		INSERT INTO MO_SVAP_Part(MONo,Seq,Part_Cd,VAP,SVAP,Deleted,Created_By,time_Created)
		SELECT A.MONO,A.SEQ,FEATURE,VAP,SVAP,0,'system',GETDATE() FROM MO_VAP_SVAP A
		OUTER APPLY
		(
		SELECT DISTINCT FEATURE 
		from OB where mono = @MONO
		AND Feature NOT IN (
		select DISTINCT PART_CD from mo_svap_part where mono = @MONO  AND VAP = 'BIN-INIT'
		)
		) AS PART
		WHERE MONO = @MONO
		AND VAP = 'BIN-INIT'
		AND ISNULL(FEATURE,'') <> ''
		
		UPDATE MO_VAP_SVAP SET ACTIVE = 0
		WHERE MONO =  @MONO
		AND VAP+SVAP NOT IN
		(
		SELECT DISTINCT VAP+SVAP
		FROM 
		MO_SVAP_PART 
		WHERE MONO = @MONO
		)
		AND  SEQ2 <> (SELECT TOP 1 SEQ2 FROM MO_VAP_SVAP WHERE MONO = @MONO AND GVAP = 'SEW' AND LOAD_OFF = 1 ORDER BY SEQ2 DESC)

		UPDATE MO_VAP_SVAP SET ACTIVE = 1
		WHERE MONO =  @MONO
		AND VAP+SVAP IN
		(
		SELECT DISTINCT VAP+SVAP
		FROM 
		MO_SVAP_PART 
		WHERE MONO = @MONO
		)
		AND  SEQ2 <> (SELECT TOP 1 SEQ2 FROM MO_VAP_SVAP WHERE MONO = @MONO AND GVAP = 'SEW' AND LOAD_OFF = 1 ORDER BY SEQ2 DESC)

END


go




CREATE FUNCTION [dbo].[prdGetDurationWorkDate]    
(
	@DURATION INT,
	@MFGLOC VARCHAR(50),
	@DATE DATE,
	@OPERATION INT
)

RETURNS DATE	

AS

----FOR TESTING
--DECLARE @DURATION INT
--DECLARE @MFGLOC VARCHAR(50)
--DECLARE @DATE DATE
--DECLARE @OPERATION INT --(-1 OR 1)

--SET @DURATION = 1
--SET @MFGLOC = 'CB01'
--SET @DATE = '10/14/2017'
--SET @OPERATION = 1
  

BEGIN

	DECLARE @NEWDATE DATE
	DECLARE @LASTDATE DATE
	DECLARE @COUNT INT
	DECLARE @CHECKMIN INT
	DECLARE @COUNTNOWORK INT
	DECLARE @ERRORMAXNOWORK INT
 
	SET @NEWDATE = @DATE
	SET @LASTDATE = @DATE
	SET @COUNT = 0
	SET @ERRORMAXNOWORK = 20
	

	WHILE (@COUNT < @DURATION)
	BEGIN	 
		
		SET @COUNTNOWORK = 0

		WHILE (1 = 1)
		BEGIN
			
			SET @NEWDATE = DATEADD(DAY, @OPERATION, @NEWDATE)
			SET @CHECKMIN = 
					(SELECT COUNT(1)
					FROM DBO.CALENDAR_WEEK_DAY_DET DET
					INNER JOIN DBO.CALENDAR_WEEK_DAY HDR ON
						HDR.CALENDAR = DET.CALENDAR AND
						HDR.WEEK_NAME = DET.WEEK_NAME AND
						HDR.[WEEK_DAY] = DET.[WEEK_DAY]
					WHERE
						HDR.CALENDAR = @MFGLOC AND
						HDR.HAS_WORK = 1 AND
						HDR.WEEK_NAME = (SELECT TOP 1 WEEK_NAME FROM DBO.CALENDAR_WEEK 
										WHERE @NEWDATE BETWEEN DATE_FROM AND DATE_TO) AND
						HDR.[WEEK_DAY] = DATENAME(WEEKDAY, @NEWDATE) AND
						NOT EXISTS(SELECT 1 FROM DBO.CALENDAR_EX EX WHERE EX.CALENDAR = DET.CALENDAR AND 
								   @NEWDATE BETWEEN CAST(EX.DATE_FROM AS DATE) AND CAST(EX.DATE_TO AS DATE)))
			
			IF (@CHECKMIN > 0) 
			BEGIN
				SET @LASTDATE = @NEWDATE
				BREAK
			END
			ELSE IF (@COUNTNOWORK = @ERRORMAXNOWORK)
			BEGIN
				BREAK
			END
			ELSE IF (@CHECKMIN = 0)
			BEGIN
				SET @COUNTNOWORK = @COUNTNOWORK + 1
			END
		END

		IF (@COUNTNOWORK = @ERRORMAXNOWORK) BREAK
		SET @COUNT = @COUNT + 1
	END

	RETURN ISNULL(@NEWDATE, @LASTDATE)

END


go



CREATE PROCEDURE [dbo].[prdGetDiscrepancyQtySP] (@MfgLoc varchar(50), @User nvarchar(50))  

AS  

BEGIN  
    
	---- FOR TESTING PURPOSES
	--DECLARE @MfgLoc varchar(50), @User nvarchar(50)
	--SET @MfgLoc = 'CB01'
	--SET @User = 'aj'

	declare @mfgloc_id int
	select @mfgloc_id = id from m_mfg_locs where code = @Mfgloc
	SELECT 0 as Sel, @MfgLoc as Mfg_Loc, SUBSTRING((SELECT DISTINCT Line + ', ' FROM BO_Hdr WHERE Mfg_Loc = @MfgLoc and MONo = B.MONo FOR XML PATH('')), 1, LEN((SELECT DISTINCT Line + ', ' FROM BO_Hdr WHERE Mfg_Loc = @MfgLoc and MONo = B.MONo FOR XML PATH('')))-1) as Line, 
		B.MONo, M.Remarks, M.MO_Qty as PO_Qty, B.BO_Qty as PlannedQty, (M.MO_Qty-B.BO_Qty) as 'Diff_Qty'
	FROM

		(SELECT @mfgloc as Mfg_Loc, MO_Hdr.MONO, MO_Hdr.Remarks, (SELECT cast(ISNULL(SUM(Qty),0) as numeric) FROM MO_Det WHERE MONo = MO_Hdr.MONo) as MO_Qty
		FROM MO_Hdr
		WHERE MO_Hdr.Mfg_Loc = @MfgLoc_id
		GROUP BY MO_Hdr.Mfg_Loc, MO_Hdr.MONO, MO_Hdr.Remarks) M 
		
		INNER JOIN
		
		(SELECT Mfg_Loc as Mfg_Loc,MONO, '' as Remarks, cast(ISNULL(SUM(Plan_Qty),0) as numeric) as BO_Qty
		FROM BO_Hdr
		WHERE Mfg_Loc = @MfgLoc --and PlanStart >= DATEADD(dd, DATEDIFF(dd, 0, getdate()), 0)
		GROUP BY Mfg_Loc,MONO) as B 
	
	ON M.MONO = B.MONO 
	WHERE 
		--M.MOQty <> B.BOQty
		B.BO_Qty > M.MO_Qty
	ORDER BY
		Line
		,MONo

END
go

CREATE PROCEDURE [dbo].[CriticalPath_process_display]
	-- Add the parameters for the stored procedure here
	@mono varchar(20)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	--declare @mono varchar(20) = '15270901001'
	-- update mo_events actual start/finish/qty per MONo
	exec prdUpdateCP_Actual_MO @mono, 'system'

	--update actual_duration if NULL
	update mo_events set actual_duration = orig_req_duration
	where mono = @mono and actual_duration is NULL

	---begin compute ex_fty_dt
	--get updated and max ex_fty_date
	declare @ex_fty_dt date, @mo_qty int 
	select @ex_fty_dt = max(ex_fty_dt), @mo_qty = sum(qty) from mo_det with(index(FGWarehouse_SQLOPS_mo_det_106_105))
	where mono = @mono and qty > 0

	update mo_events set ex_fty_dt = @ex_fty_dt
	where mono = @mono 

	--create a cursor that will update req_start, req_end
	--please be noted that computation will always start on event_seq = 600

	declare @prev_dt date = @ex_fty_dt, @cur_req_start date
	DECLARE 
		@event_seq bigint, 
		--@req_start date,
		--@req_end date
		 @actual_duration int
	declare @cntSunday int = 0, @cnt int = 1
	declare @req_finish date

	DECLARE cursor_cp CURSOR
	FOR select event_seq as a--, req_start, req_end
	, actual_duration
		from mo_events with(index(mo_events_mono_seq))
		where mono = @mono and event_seq < 605 and active = 1 
		order by event_seq desc

	OPEN cursor_cp;

	FETCH NEXT FROM cursor_cp INTO 
		@event_seq, 
		@actual_duration
	
	WHILE @@FETCH_STATUS = 0
		BEGIN
        		
			set @cur_req_start = dateadd(day, -1 * @actual_duration, convert(date, @prev_dt))
			if @cnt = 1
				begin
					set @prev_dt = @cur_req_start
				end
		
			set @cntSunday = 0
			SELECT @cntSunday =  count(DateValue)
				FROM dbo.GetSundaysAndHolidaysInRange(@cur_req_start,@prev_dt)
	
			if @cntSunday > 0 
				begin
					--select @cur_req_start, @cntSunday, @prev_dt
					set @cur_req_start = dateadd(day, -1 * @cntSunday, convert(date, @cur_req_start))
					--select @cur_req_start, @prev_dt
				end
			set @req_finish = dateadd(day, @actual_duration - 1 + @cntSunday, convert(date, @cur_req_start))
			--set @cur_req_start = dateadd(day, @cntSunday, convert(date, @cur_req_start))
			if DATENAME(WEEKDAY, @cur_req_start) = 'Sunday'
				begin
					set @cur_req_start = dateadd(day, -1, convert(date, @cur_req_start))
				end
			if DATENAME(WEEKDAY, @req_finish) = 'Sunday'
				begin
					set @req_finish = dateadd(day, -1, convert(date, @req_finish))
				end

			update mo_events set req_start = @cur_req_start, req_end = @req_finish
			where mono = @mono and event_seq = @event_seq
			set @prev_dt = @cur_req_start
			set @cnt = @cnt + 1
			FETCH NEXT FROM cursor_cp INTO 
				@event_seq, 
				@actual_duration
		END;

	CLOSE cursor_cp;

	DEALLOCATE cursor_cp;
	--update event_seq 605 and 610
	update mo_events set req_start = ex_fty_dt, req_end = ex_fty_dt
			where mono = @mono and event_seq = 605
	update mo_events set req_start = dateadd(day, 1, convert(date, ex_fty_dt)), req_end = dateadd(day, 1, convert(date, ex_fty_dt))
			where mono = @mono and event_seq = 610

	---end compute ex_fty_dt

	---begin compute sew plan start backward <510
	--get updated and max ex_fty_date
	declare @plan_start date , @plan_finish date
	select @plan_start = min(plan_start), @plan_finish = max(plan_finish) from bo_hdr with(index(BO_Hdr_MONo_BONo_uindex))
	where mono = @mono 

	update mo_events set plan_start = @plan_start, plan_end = @plan_finish
	where mono = @mono and event_seq = 510

	--create a cursor that will update plan_start, plan_end
	--please be noted that computation will always start on event_seq = 510

	--declare @prev_dt date = @plan_start, @cur_req_start date
	set @prev_dt = @plan_start


	select @cntSunday = 0, @cnt = 1

	DECLARE cursor_cp CURSOR
	FOR select event_seq as a--, req_start, req_end
	, actual_duration
		from mo_events with(index(mo_events_mono_seq))
		where mono = @mono and event_seq < 510 and active = 1 
		order by event_seq desc

	OPEN cursor_cp;

	FETCH NEXT FROM cursor_cp INTO 
		@event_seq, 
		@actual_duration
	
	WHILE @@FETCH_STATUS = 0
		BEGIN
        		
			set @cur_req_start = dateadd(day, -1 * @actual_duration, convert(date, @prev_dt))
			if @cnt = 1
				begin
					set @prev_dt = @cur_req_start
				end
		
			set @cntSunday = 0
			SELECT @cntSunday =  count(DateValue)
				FROM dbo.GetSundaysAndHolidaysInRange(@cur_req_start,@prev_dt)
	
			if @cntSunday > 0 
				begin
					--select @cur_req_start, @cntSunday, @prev_dt
					set @cur_req_start = dateadd(day, -1 * @cntSunday, convert(date, @cur_req_start))
					--select @cur_req_start, @prev_dt
				end
			set @req_finish = dateadd(day, @actual_duration - 1 + @cntSunday, convert(date, @cur_req_start))
			--set @cur_req_start = dateadd(day, @cntSunday, convert(date, @cur_req_start))
			if DATENAME(WEEKDAY, @cur_req_start) = 'Sunday'
				begin
					set @cur_req_start = dateadd(day, -1, convert(date, @cur_req_start))
				end
			if DATENAME(WEEKDAY, @req_finish) = 'Sunday'
				begin
					set @req_finish = dateadd(day, -1, convert(date, @req_finish))
				end

			update mo_events set plan_start = @cur_req_start, plan_end = @req_finish
			where mono = @mono and event_seq = @event_seq
			set @prev_dt = @cur_req_start
			set @cnt = @cnt + 1
			FETCH NEXT FROM cursor_cp INTO 
				@event_seq, 
				@actual_duration
		END;

	CLOSE cursor_cp;

	DEALLOCATE cursor_cp;

	---end compute sew plan start backward <510


	---begin compute sew plan start forward >510
	--get updated and max/min plan_start/plan_finish
	--declare @plan_start date , @plan_finish date
	declare @plan_qty int
	select @plan_start = min(plan_start), @plan_finish = max(plan_finish), @plan_qty = sum(plan_qty) from bo_hdr with(index(BO_Hdr_MONo_BONo_uindex))
	where mono = @mono 

	--create a cursor that will update plan_start, plan_end
	--please be noted that computation will always start on event_seq = 510

	--declare @prev_dt date = @plan_start, @cur_req_start date
	set @prev_dt = @plan_start


	select @cntSunday = 0, @cnt = 1

	DECLARE cursor_cp CURSOR
	FOR select event_seq as a
	, actual_duration
		from mo_events with(index(mo_events_mono_seq))
		where mono = @mono and event_seq > 510 and active = 1 
		order by event_seq asc

	OPEN cursor_cp;

	FETCH NEXT FROM cursor_cp INTO 
		@event_seq, 
		@actual_duration
	
	WHILE @@FETCH_STATUS = 0
		BEGIN
        		
			set @cur_req_start = dateadd(day, 1 * @actual_duration, convert(date, @prev_dt))
			if @cnt = 1
				begin
					set @prev_dt = @cur_req_start
				end
		
			set @cntSunday = 0
			SELECT @cntSunday =  count(DateValue)
				FROM dbo.GetSundaysAndHolidaysInRange(@cur_req_start,@prev_dt)
	
			if @cntSunday > 0 
				begin
					--select @cur_req_start, @cntSunday, @prev_dt
					set @cur_req_start = dateadd(day, 1 * @cntSunday, convert(date, @cur_req_start))
					--select @cur_req_start, @prev_dt
				end
			set @req_finish = dateadd(day, @actual_duration -1 , convert(date, @cur_req_start))
			--set @cur_req_start = dateadd(day, @cntSunday, convert(date, @cur_req_start))
			if DATENAME(WEEKDAY, @cur_req_start) = 'Sunday'
				begin
					set @cur_req_start = dateadd(day, 1, convert(date, @cur_req_start))
				end
			if DATENAME(WEEKDAY, @req_finish) = 'Sunday'
				begin
					set @req_finish = dateadd(day, 1, convert(date, @req_finish))
				end
		
			update mo_events set plan_start = @cur_req_start, plan_end = @req_finish
			where mono = @mono and event_seq = @event_seq
			set @prev_dt = @cur_req_start
			set @cnt = @cnt + 1
			FETCH NEXT FROM cursor_cp INTO 
				@event_seq, 
				@actual_duration
		END;

	CLOSE cursor_cp;

	DEALLOCATE cursor_cp;
	---end compute sew plan start forward >510
	--update mo_qty and plan_qty
	update mo_events set mo_qty = @mo_qty, plan_qty = @plan_qty
	where mono = @mono


	select * from ordMOEventsUpdateV3vw where mono = @mono

end

--SELECT DATEPART(DW, GETDATE() + 2)
go






CREATE PROCEDURE [dbo].[prdGetDiscrepancySmvSP] (@MfgLoc varchar(50), @User nvarchar(50))  

AS 

BEGIN  
    
	---- FOR TESTING PURPOSES
	--DECLARE @MfgLoc varchar(50), @User nvarchar(50)
	--SET @MfgLoc = 'CB01'
	--SET @User = 'aj'

	SELECT 0 as Sel, @MfgLoc as Mfg_Loc, SUBSTRING((SELECT DISTINCT Line + ', ' FROM BO_Hdr WHERE Mfg_Loc = @MfgLoc and MONo = B.MONo FOR XML PATH('')), 1, LEN((SELECT DISTINCT Line + ', ' FROM BO_Hdr WHERE Mfg_Loc = @MfgLoc and MONo = B.MONo FOR XML PATH('')))-1) as Line, 
		B.MONo, M.Remarks, M.SMV as MO_Smv, B.SMV as BO_Smv, (M.SMV-B.SMV) as 'Diff_Smv'
	FROM

		(SELECT Mfg_Loc, MONO, Remarks, ISNULL(PlanSMV,0) as SMV
		FROM MO_Hdr
		WHERE Mfg_Loc = @MfgLoc
		GROUP BY Mfg_Loc, MONO, Remarks, PlanSMV) M 
		
		INNER JOIN
		
		(SELECT Mfg_Loc, MONO, '' as Remarks, ISNULL(SMV,0) as SMV
		FROM BO_Hdr
		WHERE Mfg_Loc = @MfgLoc and Plan_Start >= DATEADD(dd, DATEDIFF(dd, 0, getdate()), 0)
		GROUP BY Mfg_Loc, MONO, SMV) as B 
	
	ON M.MONO = B.MONO 
	WHERE 
		M.SMV <> B.SMV
	ORDER BY
		Line
		,MONo
  
END


go

create PROCEDURE [dbo].[prdUpdateCP_ERP_Actual]
	-- Add the parameters for the stored procedure here
	@UserId		NVARCHAR(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRY

		DECLARE @RecId AS varchar(100)
	
		Set @RecId = NEWID()


		INSERT INTO [dbo].[stg_SyncLog]([Recid],[RunTime],[CreatedBy],[Remarks])
		 VALUES(@RecId, getdate(), @UserId, 'prdUpdateCP_ERP_Act - Update CP Actual.')
--		 select top 10 * from [stg_SyncLog]
--select * from [ordMOEventsUpdateV3vw] where mono = '15270901001'
--rollback transaction
--		begin transaction
		UPDATE MO_EVENTS SET Actual_Start = FabArrvl.FabAS, Actual_End = FabArrvl.FabAF, Act_Qty = (CASE WHEN FabArrvl.FabAS is null THEN 0 ELSE isnull(Qty,0) END)
		FROM MO_EVENTS ME INNER JOIN (SELECT [MONo] ,min([Plant_Avail_Dt]) as FabAS ,max([Plant_Avail_Dt]) as FabAF, min(In_Avail_Qty) as Qty FROM [dbo].[MO_Mat_List_vw] 
				WHERE Mat_Typ = 'Leather' GROUP BY MONo) FabArrvl ON ME.MONo = FabArrvl.MONo
		WHERE Event_Seq = '100' --Leather Arrvl
		AND (
		isnull(ME.Act_Qty,0) <> (CASE WHEN FabArrvl.FabAS is null THEN 0 ELSE isnull(Qty,0) END)
		OR isnull(ME.Actual_End,'1/1/1900') <> isnull(FabArrvl.FabAF,'1/1/1900'))

		UPDATE MO_EVENTS SET Actual_Start = FabArrvl.FabAS, Actual_End = FabArrvl.FabAF, Act_Qty = (CASE WHEN FabArrvl.FabAS is null THEN 0 ELSE isnull(Qty,0) END)
		FROM MO_EVENTS ME INNER JOIN (SELECT [MONo] ,min([Plant_Avail_Dt]) as FabAS ,max([Plant_Avail_Dt]) as FabAF, min(In_Avail_Qty) as Qty FROM [dbo].[MO_Mat_List_vw] 
				WHERE Mat_Typ = 'Textile' GROUP BY MONo) FabArrvl ON ME.MONo = FabArrvl.MONo
		WHERE Event_Seq = '105' --Fab Arrvl
		AND (
		isnull(ME.Act_Qty,0) <> (CASE WHEN FabArrvl.FabAS is null THEN 0 ELSE isnull(Qty,0) END)
		OR isnull(ME.Actual_End,'1/1/1900') <> isnull(FabArrvl.FabAF,'1/1/1900'))

		UPDATE MO_EVENTS SET Actual_Start = AccArrvl.AccAS, Actual_End = AccArrvl.AccAF, Act_Qty = (CASE WHEN AccArrvl.AccAS is null THEN 0 ELSE isnull(Qty,0) END)
		FROM MO_EVENTS ME INNER JOIN (SELECT [MONo] ,min([Plant_Avail_Dt]) as AccAS ,max([Plant_Avail_Dt]) as AccAF, min(In_Avail_Qty) as Qty FROM [dbo].[MO_Mat_List_vw] 
				WHERE Mat_Typ not in ('Leather','Textile') GROUP BY MONo) AccArrvl ON ME.MONo = AccArrvl.MONo
		WHERE Event_Seq = '110' --Acc/Hardware Arrvl
		AND (
		isnull(ME.Actual_Start,'1/1/1900') <> isnull(AccArrvl.AccAS,'1/1/1900')
		OR isnull(ME.Actual_End,'1/1/1900') <> isnull(AccArrvl.AccAF,'1/1/1900'))

		UPDATE MO_EVENTS SET Actual_Start = FabArrvl.FabAS, Actual_End = FabArrvl.FabAF, Act_Qty = (CASE WHEN FabArrvl.FabAS is null THEN 0 ELSE isnull(Qty,0) END)
		FROM MO_EVENTS ME INNER JOIN (SELECT [MONo] ,min([Plant_Avail_Dt]) as FabAS ,max([Plant_Avail_Dt]) as FabAF, min(In_Avail_Qty) as Qty FROM [dbo].[MO_Mat_List_vw] 
				WHERE Mat_Typ = 'Leather' GROUP BY MONo) FabArrvl ON ME.MONo = FabArrvl.MONo
		WHERE Event_Seq = '200' --Leather Arrvl
		AND (
		isnull(ME.Act_Qty,0) <> (CASE WHEN FabArrvl.FabAS is null THEN 0 ELSE isnull(Qty,0) END)
		OR isnull(ME.Actual_End,'1/1/1900') <> isnull(FabArrvl.FabAF,'1/1/1900'))

		UPDATE MO_EVENTS SET Actual_Start = FabArrvl.FabAS, Actual_End = FabArrvl.FabAF, Act_Qty = (CASE WHEN FabArrvl.FabAS is null THEN 0 ELSE isnull(Qty,0) END)
		FROM MO_EVENTS ME INNER JOIN (SELECT [MONo] ,min([Plant_Avail_Dt]) as FabAS ,max([Plant_Avail_Dt]) as FabAF, min(In_Avail_Qty) as Qty FROM [dbo].[MO_Mat_List_vw] 
				WHERE Mat_Typ = 'Textile' GROUP BY MONo) FabArrvl ON ME.MONo = FabArrvl.MONo
		WHERE Event_Seq = '205' --Fab/Textile Arrvl
		AND (
		isnull(ME.Act_Qty,0) <> (CASE WHEN FabArrvl.FabAS is null THEN 0 ELSE isnull(Qty,0) END)
		OR isnull(ME.Actual_End,'1/1/1900') <> isnull(FabArrvl.FabAF,'1/1/1900'))

		UPDATE MO_EVENTS SET Actual_Start = AccArrvl.AccAS, Actual_End = AccArrvl.AccAF, Act_Qty = (CASE WHEN AccArrvl.AccAS is null THEN 0 ELSE isnull(Qty,0) END)
		FROM MO_EVENTS ME INNER JOIN (SELECT [MONo] ,min([Plant_Avail_Dt]) as AccAS ,max([Plant_Avail_Dt]) as AccAF, min(In_Avail_Qty) as Qty FROM [dbo].[MO_Mat_List_vw] 
				WHERE Mat_Typ not in ('Leather','Textile') GROUP BY MONo) AccArrvl ON ME.MONo = AccArrvl.MONo
		WHERE Event_Seq = '210' --Acc Arrvl
		AND (
		isnull(ME.Actual_Start,'1/1/1900') <> isnull(AccArrvl.AccAS,'1/1/1900')
		OR isnull(ME.Actual_End,'1/1/1900') <> isnull(AccArrvl.AccAF,'1/1/1900'))

	

		Update dbo.stg_SyncLog set Remarks = 'prdUpdateCP_ERP_Act - Completed' Where Recid = @RecId

	END TRY
	
	BEGIN CATCH
		IF (@@TRANCOUNT > 0)
		--SELECT 1 AS ERROR_MSG
			--SELECT ERROR_MESSAGE() AS ERROR_MSG
			Update dbo.stg_SyncLog set Remarks = left('prdUpdateCP_ERP_Act - ' + ERROR_MESSAGE(),2000) Where Recid = @RecId
			SELECT 1 AS ERROR_CODE, ERROR_MESSAGE() AS ERROR_MSG
			--ROLLBACK TRANSACTION	
	END CATCH	
	
END
go




CREATE PROCEDURE [dbo].[prdGetBoLearnCurveSP](@MfgLoc varchar(50), @User nvarchar(50))  
 
AS  

BEGIN  

	SELECT
		MONo
		,BONo
		,Line
		,Learn_Curve
		,Interval
		,Period_01
		,Period_02
		,Period_03
		,Period_04
		,Period_05
		,Period_06
		,Period_07
		,Period_08
		,Period_09
		,Period_10
		,Period_11
		,Period_12
		,Period_13
		,Period_14
		,Period_15
		,Period_16
		,Period_17
		,Period_18
		,Period_19
		,Period_20
		,Period_21
		,Period_22
		,Period_23
		,Period_24
		,Period_25
		,Period_26
		,Period_27
		,Period_28
		,Period_29
		,Period_30
		,Created_By
		,Time_Created
		,Updated_By
		,Time_Updated
	FROM 
		BO_Learn_Curve
	WHERE
		Mfg_Loc = @MfgLoc
	ORDER BY 
		Line, MONo, BONo
    
END

go

CREATE PROCEDURE [dbo].[prdUpdateCP_Actual]
	-- Add the parameters for the stored procedure here
	@UserId		NVARCHAR(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRY
	rollback transaction
	begin transaction
		DECLARE @RecId AS varchar(100)
	
		Set @RecId = NEWID()

		INSERT INTO [dbo].[stg_SyncLog]([Recid],[RunTime],[CreatedBy],[Remarks])
		 VALUES(@RecId, getdate(), @UserId, 'prdUpdateCP_Act - Update CP Actual.')

		--Select m.MONo, m.Event_Seq, m.Actual_Start, m.Actual_End, m.Act_Qty--, e.* 
		Update MO_Events Set Act_Qty = isnull(e.Qty,0), Actual_Start = e.ActS, Actual_End = e.ActF
		from MO_Events m 
		inner join
			(
			SELECT MONo, Event_Seq, min(Qty) AS Qty, min(ActS) AS ActS, max(ActF) As ActF 
			FROM
				(
					SELECT m.MONo, e.Event_Seq, m.VAP, SUM(ISNULL(w.Qty, 0)) AS Qty, MIN(w.Scan_Dt) AS ActS, MAX(w.Scan_Dt) AS ActF
					FROM     dbo.MO_VAP_SVAP AS m 
					INNER JOIN dbo.Event_SVAP AS e ON m.VAP = e.VAP AND m.SVAP = e.SVAP 
					LEFT OUTER JOIN dbo.WIP_Scan AS w with (nolock) ON m.SVAP = w.SVAP AND m.VAP = w.VAP AND m.MONo = w.MONo
					WHERE  (m.Active = 1) 
					GROUP BY m.MONo, e.Event_Seq, m.VAP
				) x GROUP BY MONo, Event_Seq
			) e on m.MONo = e.MONo and m.Event_Seq = e.Event_Seq
		Where isnull(ActF,'1/1/1900') <> isnull(Actual_End,'1/1/1900') or isnull(Act_Qty,0) <> isnull(Qty,0)
		

		select * from [ordMOEventsUpdateV3vw] where mono = '15270901001'

		Update dbo.stg_SyncLog set Remarks = 'prdUpdateCP_Act - Completed' Where Recid = @RecId

	END TRY
	
	BEGIN CATCH
		IF (@@TRANCOUNT > 0)
		--SELECT 1 AS ERROR_MSG
			--SELECT ERROR_MESSAGE() AS ERROR_MSG
			Update dbo.stg_SyncLog set Remarks = left('prdUpdateCP_Act - ' + ERROR_MESSAGE(),2000) Where Recid = @RecId
			SELECT 1 AS ERROR_CODE, ERROR_MESSAGE() AS ERROR_MSG
			--ROLLBACK TRANSACTION	
	END CATCH	
	
END
go

CREATE PROC [dbo].[prdAutoLaysp]
	@USERID NVARCHAR(50)
AS
--[dbo].[prdAutoLaysp] 'system'
--declare @USERID NVARCHAR(50) ='admin'

SET NOCOUNT ON

 BEGIN TRY
 	BEGIN TRANSACTION

	--declare @userid varchar(20) = 'abc'
	IF OBJECT_ID('tempdb.dbo.#Loop') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #Loop
	END

	IF OBJECT_ID('tempdb.dbo.#MCS') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #MCS
	END

	IF OBJECT_ID('tempdb.dbo.#AutoLay') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #AutoLay
	END

	DECLARE @UpdatedDt date = convert(date,dateadd(day, -1, getdate())), @sbu_id int = 1

	Select h.IONo, h.MONo, d.Color, d.Size, d.Qty, s.Std_Bndl_Qty, s.Default_WS into #MCS
	from MO_Hdr h with (nolock)
		OUTER APPLY
		(
			Select Color, Size, sum(Qty) as Qty, max(isnull(time_Updated,time_Created)) as UpdatedDt
				from MO_Det with (nolock) Where MONo = h.MONo group by Color, Size
		) d
		OUTER APPLY
		(
			Select Std_Bndl_Qty, Default_WS from m_Mfg_Locs Where id = h.Mfg_Loc
		) s
		Where
		h.MONo in (Select MONo from OB with (nolock))
		and h.MO_Status in ('Released','For Release')
		and (h.time_updated >= @UpdatedDt or d.UpdatedDt >=@UpdatedDt)


	Select mcs.*, Qty - isnull(cutQty,0) as BalQty, isnull(convert(bigint,mxLayNo),0)+1 as LayNo into #AutoLay
	from #MCS mcs
	outer apply
	(
		Select sum(clrQty * szQty) as cutQty from Laying_Hdr h with (nolock)
				outer apply
				(
					Select Color, sum(Qty) as clrQty from Laying_Ply_Batch with (nolock) Where MONo = h.MONo and LayNo = h.LayNo group by Color
				) b
				outer apply
				(
					Select Size, sum(Qty) as szQty from Laying_Sizes with (nolock) Where MONo = h.MONo and LayNo = h.LayNo group by Size
				) s
		Where MONo = mcs.MONo and Color = mcs.Color and Size = mcs.Size and h.[Status] <> 'V'
	) c
	outer apply
	(
		Select max(isnull(case when LayNo like '%[^0-9]%' then Null else LayNo END,0)) as mxLayNo from Laying_Hdr with (nolock) Where MONo = mcs.MONo
	) l
	--outer apply
	--(
	--	Select sum(Qty) as ptQTY from LayingPT with (nolock) Where MONo = mcs.MONo and Color = mcs.Color
	--) p
	Where Qty > isnull(cutQty,0)
	order by MONo, Color

	Select ROW_NUMBER() OVER (order by MONo, Color) AS Row_Num, IONo, MONo, LayNo, Color, Size, Std_Bndl_Qty, Default_WS,
		ceiling(BalQty/Std_Bndl_Qty) as NoOfPlyBatch, BalQty - (floor(BalQty/Std_Bndl_Qty) * Std_Bndl_Qty) as lastBatch
	into #Loop
	from #AutoLay l
	--where MONo like 'TS194853-3001'

	--select * from #mcs
	--select * from #autolay
	--select * from #loop

	--Loop to Auto Create Laying
	DECLARE @RecCnt int = (Select count(1) from #Loop)
	DECLARE @CurRow	int = 1

	WHILE @CurRow <= @RecCnt
	BEGIN
		--Do Insert Laying Tables Here
		INSERT INTO [dbo].[Laying_Hdr]
           (sbu_id, [MONo],[LayNo]--,[LayDt]
		   ,[Status],[Bundle_No_From],[Bundle_No_To],[Cut_Work_Section]
           --,[BTScanned],[PTScanned],[Printed],[UnAssigned],[Replacement]
           ,Active,[Created_By],[time_Created]) --,[IONo])
		SELECT @sbu_id,t.MONo, t.LayNo, 'N', 0,0,Default_WS--,0,0,0,0,0
		,1,@USERID,getdate()--,t.IONo
		FROM
		#Loop t
		Where t.Row_Num = @CurRow

		INSERT INTO [dbo].[Laying_Ply_Batch]
				   (sbu_id,[MONo]
				   ,[LayNo]
				   ,[Seq]
				   ,[Color]
				   ,[Qty]
				   ,Active
				   ,[Created_By]
				   ,[time_Created])

		SELECT @sbu_id,t.MONo, t.LayNo, n.RowNo, t.Color, CASE WHEN n.RowNo <> t.NoOfPlyBatch THEN t.Std_Bndl_Qty ELSE (CASE WHEN t.lastBatch = 0 THEN t.Std_Bndl_Qty ELSE t.lastBatch END) END as BndlQty, 1, @USERID, getdate()
		FROM
		#Loop t
		INNER JOIN
		Config_Row_No n
			ON n.RowNo <= t.NoOfPlyBatch
		Where t.Row_Num = @CurRow

		INSERT INTO [dbo].[Laying_Sizes]
				   (sbu_id,[MONo]
				   ,[LayNo]
				   ,[Size]
				   ,[Qty]
				   ,Active
				   ,[Created_By]
				   ,[time_Created]
				   ,[Seq])
		SELECT top 1 @sbu_id,t.MONo, t.LayNo, t.Size, 1, 1, @USERID, getdate(), 1
		FROM
		#Loop t
		Where t.Row_Num = @CurRow

		SET @CurRow = @CurRow + 1
		IF @CurRow > @RecCnt
			BREAK
		ELSE
			CONTINUE
	END


	--SELECT t.Row_Num, t.MONo, t.LayNo, t.Color, n.RowNo, CASE WHEN n.RowNo <> t.NoOfPlyBatch THEN t.StdBndlQty ELSE t.lastBatch END as BndlQty
	--FROM
	--#Loop t
	--INNER JOIN
	--ConfigRowNo n
	--	ON n.RowNo <= t.NoOfPlyBatch
	update mo_hdr set mo_status = 'LAYING'
	where mono in (select distinct mono from #loop )



	--populate wip_scan_part
	declare @mono varchar(20)
	select distinct top 1 @mono = mono FROM #Loop
	IF EXISTS(SELECT 'X' FROM LAYING_HDR WHERE MONo = @MONo AND Status = 'G')
		BEGIN
				DECLARE @LAY NVARCHAR(20)
				DECLARE @NOOFLAY INT
				DECLARE @COUNTER INT = 1

				DECLARE @LAYLIST TABLE
				(
					ROWNO INT,
					LAYNO NVARCHAR(20)
				)

				INSERT INTO @LAYLIST
				SELECT ROW_NUMBER() OVER (PARTITION BY MONO ORDER BY LAYNO) AS ROWNO, LayNo
				FROM Laying_Hdr WHERE MONo = @MONo
				AND Status = 'G'

				SELECT @NOOFLAY = COUNT(*) FROM @LAYLIST

				WHILE @COUNTER <= @NOOFLAY
				BEGIN

				SELECT @LAY = LAYNO FROM @LAYLIST WHERE ROWNO = @COUNTER


				Insert Into WIP_Scan_Part(mo_id,pt_id,Load_Type,Seq,VAP,SVAP,feature,output_qty,Created_By,Time_Created,work_section_id,Time_Updated,Scan_Dt,Authorized_By,Day_Night_Shft)
				Select
					--NEWID(),
					Laying_PT.mo_id,
					laying_pt.id,
					1 as LoadType,
					1 as Seq,
					'BIN-INIT',
					'BIN-INIT',
					Part_Cd,
					Qty,
					Laying_PT.Time_Created,
					GETDATE(),
					Laying_Hdr.Created_By,
					NULL,
					Laying_PT.Time_Created,
					NULL,
					'D'
				From Laying_PT
				INNER JOIN MO_SVAP_PART ON Laying_PT.MONo = MO_SVAP_PART.MONo
				INNER JOIN Laying_Hdr ON Laying_PT.MONo = Laying_Hdr.MONo AND Laying_PT.LayNo = Laying_Hdr.LayNo
				Where Laying_PT.MONo = @MONo AND VAP = 'BIN-INIT'
				AND LAYING_PT.LayNo = @Lay AND PTNo+Part_Cd NOT IN (SELECT convert(varchar(10),pt_id)+feature FROM WIP_Scan_Part WHERE MONo = @MONo AND LayNo = @LAY)


/*				Insert Into WIP_Scan_Part(Rec_Id,MONo,LayNo,PTNo,Load_Type,Seq,VAP,SVAP,Part_Cd,Qty,Created_By,Time_Created,Work_Section,Time_Updated,Scan_Dt,Authorized_By,Day_Night_Shft)
				Select
					NEWID(),
					Laying_PT.MONo,
					LAYING_PT.LayNo,
					PTNo,
					1 as LoadType,
					1 as Seq,
					'BIN-INIT',
					'BIN-INIT',
					Part_Cd,
					Qty,
					Laying_PT.Time_Created,
					GETDATE(),
					Laying_Hdr.Created_By,
					NULL,
					Laying_PT.Time_Created,
					NULL,
					'D'
				From Laying_PT
				INNER JOIN MO_SVAP_PART ON Laying_PT.MONo = MO_SVAP_PART.MONo
				INNER JOIN Laying_Hdr ON Laying_PT.MONo = Laying_Hdr.MONo AND Laying_PT.LayNo = Laying_Hdr.LayNo
				Where Laying_PT.MONo = @MONo AND VAP = 'BIN-INIT'
				AND LAYING_PT.LayNo = @Lay AND PTNo+Part_Cd NOT IN (SELECT PTNo+Part_Cd FROM WIP_Scan_Part WHERE MONo = @MONo AND LayNo = @LAY)*/

				SET @COUNTER = @COUNTER + 1

				END
		END



	IF OBJECT_ID('tempdb.dbo.#Loop') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #Loop
	END

	IF OBJECT_ID('tempdb.dbo.#MCS') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #MCS
	END

	IF OBJECT_ID('tempdb.dbo.#AutoLay') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #AutoLay
	END



	COMMIT TRANSACTION

SET NOCOUNT OFF

END TRY
BEGIN CATCH
	SELECT 'error' AS code,ERROR_MESSAGE() AS description
	ROLLBACK TRANSACTION
END CATCH
go


CREATE PROCEDURE [dbo].[prdUpdateCP_Actual_MO]
	-- Add the parameters for the stored procedure here
	@mono varchar(20),
	@UserId		NVARCHAR(50) = NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRY
	
		DECLARE @RecId AS varchar(100)
	
		Set @RecId = NEWID()

		INSERT INTO [dbo].[stg_SyncLog]([Recid],[RunTime],[CreatedBy],[Remarks])
		 VALUES(@RecId, getdate(), @UserId, 'prdUpdateCP_Act - Update CP Actual.')

		--Select m.MONo, m.Event_Seq, m.Actual_Start, m.Actual_End, m.Act_Qty--, e.* 
		Update MO_Events Set Act_Qty = isnull(e.Qty,0), Actual_Start = e.ActS, Actual_End = e.ActF
		from MO_Events m 
		inner join
			(
			SELECT MONo, Event_Seq, min(Qty) AS Qty, min(ActS) AS ActS, max(ActF) As ActF 
			FROM
				(
					SELECT m.MONo, e.Event_Seq, m.VAP, SUM(ISNULL(w.Qty, 0)) AS Qty, MIN(w.Scan_Dt) AS ActS, MAX(w.Scan_Dt) AS ActF
					FROM     dbo.MO_VAP_SVAP AS m 
					INNER JOIN dbo.Event_SVAP AS e ON m.VAP = e.VAP AND m.SVAP = e.SVAP 
					LEFT OUTER JOIN dbo.WIP_Scan AS w with (nolock) ON m.SVAP = w.SVAP AND m.VAP = w.VAP AND m.MONo = w.MONo
					WHERE  m.mono = @mono and (m.Active = 1) 
					GROUP BY m.MONo, e.Event_Seq, m.VAP
				) x GROUP BY MONo, Event_Seq
			) e on m.MONo = e.MONo and m.Event_Seq = e.Event_Seq
		Where isnull(ActF,'1/1/1900') <> isnull(Actual_End,'1/1/1900') or isnull(Act_Qty,0) <> isnull(Qty,0)
		
		Update dbo.stg_SyncLog set Remarks = 'prdUpdateCP_Act - Completed' Where Recid = @RecId

	END TRY
	
	BEGIN CATCH
		IF (@@TRANCOUNT > 0)
		--SELECT 1 AS ERROR_MSG
			--SELECT ERROR_MESSAGE() AS ERROR_MSG
			Update dbo.stg_SyncLog set Remarks = left('prdUpdateCP_Act - ' + ERROR_MESSAGE(),2000) Where Recid = @RecId
			SELECT 1 AS ERROR_CODE, ERROR_MESSAGE() AS ERROR_MSG
			--ROLLBACK TRANSACTION	
	END CATCH	
	
END
go

CREATE FUNCTION dbo.fn_material_alert(@mono varchar(20))
RETURNS TABLE
AS
RETURN
(
    WITH alerts_cte AS (
      select a.*, KeyEvent, ExFactoryDate_Req_Start, Actual_Start,
          alert = case when Latest_ETA > ExFactoryDate_Req_Start then 1 else 0 end
      from (
        --MATERIAL ETA
        Select event_seq = case when Mat_Typ = 'Hardware' then 110 when Mat_Typ = 'Leather' then 100 when Mat_Typ = 'Textile' then 105 else 0 end,
          MONo, Mat_Typ, Latest_ETA
        from mo_mat_eta a where a.mono =@mono and Mat_Typ in ('Hardware','Leather','Textile')
      )  a
      INNER JOIN
        (
        --CRITICAL PATH
        SELECT Event_Seq, KeyEvent, ExFactoryDate_Req_Start, Actual_Start
        FROM ordMOEventsUpdateV3vw where mono = @mono and KeyEvent in ('Leather Arrvl','Fabric/Fillers Arrvl','Acc/Hardware Arrvl')
      ) B on a.event_seq = b.Event_Seq
    )
    SELECT * FROM alerts_cte
)
go


CREATE procedure [dbo].[qconn_top10_defect_summary]
    @year int = null,
    @datefrom date = null,
    @dateto date = null,
    @customer varchar(20) = '',
    @season varchar(20) = '',
    @prodtype varchar(20) = '',
    @styleno varchar(100) = ''
as
	set nocount on
    set @datefrom = ISNULL(@dateFrom, '2015-01-01')
    set @dateto = ISNULL(@dateTo, GETDATE())

    select top 10 b.desc1, b.desc2, sum(DefectQty) as total_defect
    from EndLineQCDet (nolock) a
    inner join DefectTypes (nolock) b on a.DefectType=b.DefectType
    inner join Laying_PT (nolock) c on a.PTNo = c.PTNo
--     inner join MODet (nolock) d on c.MONo = d.MONo
--     inner join MOHdr (nolock) e on d.MONo = e.MONo
    inner join MO_Hdr (nolock) e on c.MONo = e.MONo
    inner join IO_Hdr (nolock) f on e.IONo = f.IONo and e.Style_No = f.Style_No
    inner join (select distinct mono, Style_No as StyleNo, Sold_To_Cust as SoldToCust from MO_Det (nolock)) d on d.MONo = e.MONo and d.StyleNo = e.Style_No
    where d.SoldToCust = IIF(@customer = '', d.SoldToCust, @customer)
        and f.Season = IIF(@season = '', f.Season, @season)
        and e.Prod_Type = IIF(@prodtype = '', e.Prod_Type, @prodtype)
        and f.Style_No = IIF(@styleno = '', f.Style_No, @styleno)
--         and e.ReqProdStart between @datefrom and @dateto
        and (@year is null or year(e.Req_Prod_Start) = @year)
    group by b.desc1, b.desc2
    order by sum(DefectQty) desc
go


CREATE procedure [dbo].[qconn_defect_summary_breakdown]
    @year int = null,
    @datefrom date = null,
    @dateto date = null,
    @customer varchar(20) = '',
    @season varchar(20) = '',
    @prodtype varchar(20) = '',
    @styleno varchar(100) = ''
as
	set nocount on
    set @datefrom = ISNULL(@dateFrom, '2015-01-01')
    set @dateto = ISNULL(@dateTo, GETDATE())

    select row_number() over (order by g.ProdLine, b.Desc1) as id,
           g.ProdLine, --a1.DefectType as code,
           b.desc1, b.desc2, a1.total_defect,
           isnull(sum(DefectQty), 0) as line_defect
    from
        (select top 10 b.Desc1, sum(DefectQty) as total_defect
            from EndLineQCDet a inner join DefectTypes b on a.DefectType=b.DefectType
            inner join Laying_PT (nolock) c on a.PTNo = c.PTNo
--             inner join MODet (nolock) d on c.MONo = d.MONo
--             inner join MOHdr (nolock) e on d.MONo = e.MONo
            inner join MO_Hdr (nolock) e on c.MONo = e.MONo
            inner join IO_Hdr (nolock) f on e.IONo = f.IONo
            inner join (select distinct mono, Style_No as StyleNo, Sold_To_Cust as SoldToCust from MO_Det (nolock)) d on d.MONo = e.MONo and d.StyleNo = e.Style_No
            where d.SoldToCust = IIF(@customer = '', d.SoldToCust, @customer)
                and f.Season = IIF(@season = '', f.Season, @season)
                and e.Prod_Type = IIF(@prodtype = '', e.Prod_Type, @prodtype)
                and d.StyleNo = IIF(@styleno = '', d.StyleNo, @styleno)
                and (@year is null or year(e.Req_Prod_Start) = @year)
            group by b.Desc1
            order by sum(DefectQty) desc) a1
    inner join DefectTypes (nolock) b on a1.Desc1=b.Desc1
    inner join EndLineQCDet (nolock) a on b.DefectType = a.DefectType
    inner join Laying_PT (nolock) c on a.PTNo = c.PTNo
--     inner join MODet (nolock) d on c.MONo = d.MONo
--     inner join MOHdr (nolock) e on d.MONo = e.MONo
    inner join MO_Hdr (nolock) e on c.MONo = e.MONo
    inner join IO_Hdr (nolock) f on e.IONo = f.IONo
    inner join (select distinct mono, Style_No as StyleNo, Sold_To_Cust as SoldToCust from MO_Det (nolock)) d on d.MONo = e.MONo and d.StyleNo = e.Style_No
    inner join EndLineQCHdr g on a.PTNo = g.PTNo and a.Seq = g.Seq
    where --g.Reject = 1 and
        d.SoldToCust = IIF(@customer = '', d.SoldToCust, @customer)
        and f.Season = IIF(@season = '', f.Season, @season)
        and e.Prod_Type = IIF(@prodtype = '', e.Prod_Type, @prodtype)
        and d.StyleNo = IIF(@styleno = '', d.StyleNo, @styleno)
        and (@year is null or year(e.Req_Prod_Start) = @year)
    group by g.ProdLine, --a1.DefectType,
             b.desc1, b.desc2, a1.total_defect
    order by g.ProdLine, a1.total_defect desc
go

CREATE function fn_po_has_draft(@poid BIGINT)
RETURNS bit
AS
BEGIN
	declare @hasDraft bit = 0

	select @hasDraft = case when count(is_draft) >= 1 then 1 else 0 end  from fg_purchase_order_dtl where purchase_order_id = @poid and is_draft = 1
	return @hasDraft
END
go

CREATE FUNCTION dbo.GetSundaysAndHolidaysV2 (@StartDate DATE, @EndDate DATE)
RETURNS TABLE
AS
RETURN
(
    SELECT DATEADD(day, number, @StartDate) AS [Date], 'Sunday' AS [DayType]
    FROM master..spt_values
    WHERE type = 'P'
        AND DATEPART(weekday, DATEADD(day, number, @StartDate)) = 1 -- Sunday
        AND DATEADD(day, number, @StartDate) <= @EndDate

    UNION
    SELECT HolidayDate AS [Date], 'Holiday' AS [DayType]
    FROM Holidays
    WHERE HolidayDate BETWEEN @StartDate AND @EndDate
)
go

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[prdReleaseMo]
	-- Add the parameters for the stored procedure here
	@mono varchar(20),
	@username varchar(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	declare @mo_status varchar(20) 
	select top 1 @mo_status = mo_status from mo_hdr a inner join mo_det b on b.mono = a.mono where a.mono = @mono
	--check if MO exists
	if @mo_status = NULL
		begin
			select 'MONo - ' + @mono + ' not existing' as description, 'error' as code
			return
		end
	
	--check mo status 
	if @mo_status <> 'OB'
		begin
			select 'MONo - ' + @mono + ' status not available for releasing, current status : ' + @mo_status   as description, 'error' as code
			return
		end

	--check if MO exists in OB
	if not exists(select top 1 mono from ob a where a.mono = @mono )
		begin 
			select 'MONo - ' + @mono + ' has no Operations ' as description, 'error' as code
			return
		end

	--check if MO has OB_group_operations
	if not exists(select top 1 mono from OB_group_operations a where a.mono = @mono )
		begin 
			select 'MONo - ' + @mono + ' has no OB Group Operations ' as description, 'error' as code
			return
		end

	
	update mo_hdr set mo_status = 'Released',updated_by = @username, time_updated = getdate()
	where mono = @mono 

	

	exec [prdAutoLaysp] 'system'
	update mo_hdr set mo_status = 'LAYING',updated_by = @username, time_updated = getdate()
	where mono = @mono 

	select 'MONo - ' + @mono + ' Successful in RELEASING and LAYING ' as description, 'success' as code

END
go




--exec plnUpdateMO_CP '43014019028','system' select * from BOEvents Where MONo = '43014019028'

CREATE PROCEDURE [dbo].[stg_plnUpdateMO_CP]
(
	@MONO		VARCHAR(50),
	@USERID		NVARCHAR(50)
)

AS

SET NOCOUNT ON 
	
BEGIN TRY
	--BEGIN TRAN

		Update MO_Events Set Req_Start = boe.Req_Start_Min
						, Req_End = boe.Req_End_Max --CASE WHEN VAP = 'SEW' THEN boe.ReqEndMax ELSE ReqEndMin END
						, Plan_Start = CASE WHEN VAP = 'SEW' and isnull(Actual_Qty,0) = 0 THEN boe.Req_Start_Min
										ELSE
										CASE WHEN moe.Plan_Start is null then boe.Req_Start_Min else moe.Plan_Start END
										END 
						--, PlanStart = boe.PlanStart
						, Plan_End = CASE WHEN VAP = 'SEW' and isnull(Actual_Qty,0) = 0 THEN boe.Req_End_Max 
										--CASE WHEN moe.PlanEnd is null then boe.ReqEndMax else moe.PlanEnd END 
										ELSE
										CASE WHEN moe.Plan_End is null then boe.Req_End_Max else moe.Plan_End END 
										END
						--, PlanEnd = boe.PlanEndMax
						--, POStart = boe.POStartMin
						--, POEnd = boe.POEndMax
						, Time_Updated = getdate()
						, Updated_By = @USERID
		FROM  dbo.MO_Events AS moe INNER JOIN
						(SELECT boe.MONo, boe.Event_Seq
							, MIN(boe.Req_Start) AS Req_Start_Min
							, MIN(boe.Req_End) AS Req_End_Min
							, MAX(boe.Req_End) AS Req_End_Max
							, MIN(boe.Plan_Start) AS Plan_Start_Min
							, MIN(boe.Plan_End) AS Plan_End_Min
							, MAX(boe.Plan_End) AS Plan_End_Max
							, MIN(boe.Actual_Start) AS Actual_Start_Min
							, MAX(boe.Actual_End) AS Actual_End_Max
							, MIN(boe.PO_Start) AS PO_Start_Min
							, MIN(boe.PO_End) AS PO_End_Min
							, MAX(boe.PO_End) AS PO_End_Max
							FROM dbo.BO_Events boe inner join BO_Hdr bh on boe.MONo = bh.MONo and boe.BONo = bh.BONo and boe.Mfg_Loc = bh.Mfg_Loc
							GROUP BY boe.MONo, boe.Event_Seq) AS boe 
		ON moe.MONo = boe.MONo AND moe.Event_Seq = boe.Event_Seq
		WHERE moe.MONo = @MONO

		SELECT 0 AS [STATUS], 'UPDATED' AS ERROR_MSG

	--COMMIT TRAN
END TRY
BEGIN CATCH
	SELECT ERROR_MESSAGE()
	--ROLLBACK TRAN
END CATCH

go



CREATE PROC [dbo].[prdAutoLayspMO]
(
	@MONO varchar(20),
	@REPLACEMENT bit = 0,
	@EXCESS bit = 0,
	@USERID NVARCHAR(50)
)

AS

--[dbo].[prdAutoLaysp] 'system'

SET NOCOUNT ON

BEGIN TRY
	BEGIN TRANSACTION
	

	--declare @userid varchar(20) = 'abc'
	IF OBJECT_ID('tempdb.dbo.#Loop') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #Loop
	END

	IF OBJECT_ID('tempdb.dbo.#MCS') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #MCS
	END

	IF OBJECT_ID('tempdb.dbo.#AutoLay') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #AutoLay
	END

	DECLARE @UpdatedDt date = convert(date,dateadd(day, -1, getdate())), @sbu_id int = 1

	Select h.IONo, h.MONo, d.Color, d.Size, d.Qty, s.Std_Bndl_Qty, s.Default_WS into #MCS 
	from MO_Hdr h with (nolock) 
		OUTER APPLY
		(
			Select Color, Size, sum(Qty) as Qty, max(isnull(time_Updated,time_Created)) as UpdatedDt 
				from MO_Det with (nolock) Where MONo = h.MONo group by Color, Size
		) d
		OUTER APPLY
		(
			Select Std_Bndl_Qty, Default_WS from m_Mfg_Locs Where id = h.Mfg_Loc
		) s
		Where 
		h.MONo in (Select MONo from OB with (nolock))
		and h.MO_Status in ('Released','For Release')
		and (h.time_updated >= @UpdatedDt or d.UpdatedDt >=@UpdatedDt)
		and h.mono = @MONO


	Select mcs.*, Qty - isnull(cutQty,0) as BalQty, isnull(convert(bigint,mxLayNo),0)+1 as LayNo into #AutoLay 
	from #MCS mcs
	outer apply
	(
		Select sum(clrQty * szQty) as cutQty from Laying_Hdr h with (nolock) 
				outer apply
				(
					Select Color, sum(Qty) as clrQty from Laying_Ply_Batch with (nolock) Where MONo = h.MONo and LayNo = h.LayNo group by Color
				) b
				outer apply
				(
					Select Size, sum(Qty) as szQty from Laying_Sizes with (nolock) Where MONo = h.MONo and LayNo = h.LayNo group by Size
				) s
		Where MONo = mcs.MONo and Color = mcs.Color and Size = mcs.Size and h.[Status] <> 'V'
	) c
	outer apply
	(
		Select max(isnull(case when LayNo like '%[^0-9]%' then Null else LayNo END,0)) as mxLayNo from Laying_Hdr with (nolock) Where MONo = mcs.MONo
	) l
	--outer apply
	--(
	--	Select sum(Qty) as ptQTY from LayingPT with (nolock) Where MONo = mcs.MONo and Color = mcs.Color
	--) p
	Where Qty > isnull(cutQty,0)
	order by MONo, Color

	Select ROW_NUMBER() OVER (order by MONo, Color) AS Row_Num, IONo, MONo, LayNo, Color, Size, Std_Bndl_Qty, Default_WS, ceiling(BalQty/Std_Bndl_Qty) as NoOfPlyBatch, BalQty - (floor(BalQty/Std_Bndl_Qty) * Std_Bndl_Qty) as lastBatch
	into #Loop 
	from #AutoLay l
	--where MONo like 'TS194853-3001'

	--select * from #mcs
	--select * from #autolay
	--select * from #loop

	--Loop to Auto Create Laying
	DECLARE @RecCnt int = (Select count(1) from #Loop)
	DECLARE @CurRow	int = 1
	
	WHILE @CurRow <= @RecCnt  
	BEGIN  
		--Do Insert Laying Tables Here
		INSERT INTO [dbo].[Laying_Hdr]
           (sbu_id, [MONo],[LayNo]--,[LayDt]
		   ,[Status],[Bundle_No_From],[Bundle_No_To],[Cut_Work_Section]
           --,[BTScanned],[PTScanned],[Printed],[UnAssigned],[Replacement]
           ,Active,[Created_By],[time_Created], excess, replacement) --,[IONo])
		SELECT @sbu_id,t.MONo, t.LayNo, 'N', 0,0,Default_WS--,0,0,0,0,0
		,1,@USERID,getdate(),@excess, @replacement --,t.IONo
		FROM
		#Loop t
		Where t.Row_Num = @CurRow

		INSERT INTO [dbo].[Laying_Ply_Batch]
				   (sbu_id,[MONo]
				   ,[LayNo]
				   ,[Seq]
				   ,[Color]
				   ,[Qty]
				   ,Active
				   ,[Created_By]
				   ,[time_Created])
				   
		SELECT @sbu_id,t.MONo, t.LayNo, n.RowNo, t.Color, CASE WHEN n.RowNo <> t.NoOfPlyBatch THEN t.Std_Bndl_Qty ELSE (CASE WHEN t.lastBatch = 0 THEN t.Std_Bndl_Qty ELSE t.lastBatch END) END as BndlQty, 1, @USERID, getdate()
		FROM
		#Loop t
		INNER JOIN
		Config_Row_No n
			ON n.RowNo <= t.NoOfPlyBatch
		Where t.Row_Num = @CurRow

		INSERT INTO [dbo].[Laying_Sizes]
				   (sbu_id,[MONo]
				   ,[LayNo]
				   ,[Size]
				   ,[Qty]
				   ,Active
				   ,[Created_By]
				   ,[time_Created]
				   ,[Seq])
		SELECT top 1 @sbu_id,t.MONo, t.LayNo, t.Size, 1, 0, @USERID, getdate(), 1
		FROM
		#Loop t
		Where t.Row_Num = @CurRow
			
		SET @CurRow = @CurRow + 1
		IF @CurRow > @RecCnt  
			BREAK  
		ELSE  
			CONTINUE  
	END 
	

	--SELECT t.Row_Num, t.MONo, t.LayNo, t.Color, n.RowNo, CASE WHEN n.RowNo <> t.NoOfPlyBatch THEN t.StdBndlQty ELSE t.lastBatch END as BndlQty
	--FROM
	--#Loop t
	--INNER JOIN
	--ConfigRowNo n
	--	ON n.RowNo <= t.NoOfPlyBatch
	update mo_hdr set mo_status = 'LAYING'
	where mono in (select distinct mono from #loop )

	--populate wip_scan_part
	--declare @mono varchar(20)
	--select distinct top 1 @mono = mono FROM #Loop
	IF EXISTS(SELECT 'X' FROM LAYING_HDR WHERE MONo = @MONo AND Status = 'G')
		BEGIN
				DECLARE @LAY NVARCHAR(20)
				DECLARE @NOOFLAY INT
				DECLARE @COUNTER INT = 1

				DECLARE @LAYLIST TABLE
				(
					ROWNO INT,
					LAYNO NVARCHAR(20)
				)

				INSERT INTO @LAYLIST
				SELECT ROW_NUMBER() OVER (PARTITION BY MONO ORDER BY LAYNO) AS ROWNO, LayNo
				FROM Laying_Hdr WHERE MONo = @MONo
				AND Status = 'G'

				SELECT @NOOFLAY = COUNT(*) FROM @LAYLIST

				WHILE @COUNTER <= @NOOFLAY
				BEGIN

				SELECT @LAY = LAYNO FROM @LAYLIST WHERE ROWNO = @COUNTER

				Insert Into WIP_Scan_Part(Rec_Id,MONo,LayNo,PTNo,Load_Type,Seq,VAP,SVAP,Part_Cd,Qty,Created_By,Time_Created,Work_Section,Time_Updated,Scan_Dt,Authorized_By,Day_Night_Shft)
				Select
					NEWID(),
					Laying_PT.MONo,
					LAYING_PT.LayNo,
					PTNo,
					1 as LoadType,
					1 as Seq,
					'BIN-INIT',
					'BIN-INIT',
					Part_Cd,
					Qty,
					Laying_PT.Time_Created,
					GETDATE(),
					Laying_Hdr.Created_By,
					NULL,
					Laying_PT.Time_Created,
					NULL,
					'D'
				From Laying_PT
				INNER JOIN MO_SVAP_PART ON Laying_PT.MONo = MO_SVAP_PART.MONo
				INNER JOIN Laying_Hdr ON Laying_PT.MONo = Laying_Hdr.MONo AND Laying_PT.LayNo = Laying_Hdr.LayNo
				Where Laying_PT.MONo = @MONo AND VAP = 'BIN-INIT'
				AND LAYING_PT.LayNo = @Lay AND PTNo+Part_Cd NOT IN (SELECT PTNo+Part_Cd FROM WIP_Scan_Part WHERE MONo = @MONo AND LayNo = @LAY)

				SET @COUNTER = @COUNTER + 1

				END
		END




	IF OBJECT_ID('tempdb.dbo.#Loop') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #Loop
	END

	IF OBJECT_ID('tempdb.dbo.#MCS') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #MCS
	END

	IF OBJECT_ID('tempdb.dbo.#AutoLay') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #AutoLay
	END



	COMMIT TRANSACTION
	select 'ok' as code, 'Laying for MONo - ' + @MONO + ' is successful ' as description
SET NOCOUNT OFF
		
END TRY
BEGIN CATCH
	SELECT 'error' AS code,ERROR_MESSAGE() AS description
	ROLLBACK TRANSACTION
END CATCH


go



CREATE FUNCTION [dbo].[prdCheckCutqty_UDF]
(
	@MONO VARCHAR(20),
	@LAYNO NVARCHAR(20),
	@LAYING VARCHAR(1) = 0,
	@EXCESS BIT = 0,
	@REPLACEMENT BIT = 0,
	@PTGEN BIT = 0
)
RETURNS @STATUS TABLE 
(
	MSG NVARCHAR(1000),
	ERROR VARCHAR(1)
)
AS
BEGIN 

--DECLARE @MONO VARCHAR(20) = '7529198001'
--DECLARE @LAYNO NVARCHAR(20) = '28'

	DECLARE 
	@ORDQTY INT,
	@CUTQTY INT,
	@GENQTY INT

	IF EXISTS(SELECT 'X' FROM Control_File WHERE CTRLCUTQTY = 1) 
	BEGIN
		
		IF EXISTS(
		SELECT TOP 1 'X' FROM MO_DET A WITH(NOLOCK) 
		INNER JOIN MO_HDR B WITH(NOLOCK) ON A.MONO = B.MONO
		INNER JOIN IO_DET C WITH(NOLOCK) ON A.ITEM_NO = C.ITEM_NO
		WHERE A.MONO = @MONO AND C.QTY > 0 ) --AND ISNULL(ALLOWOVRSHP,0) = 1)
		BEGIN

			INSERT INTO @STATUS
			SELECT 'CONTINUE' AS MSG,0 AS ERROR
			RETURN

		END

		SELECT @ORDQTY = SUM(QTY) FROM MO_Det WITH(NOLOCK) WHERE MONo = @MONO

		--SELECT @CUTQTY = SUM(QTY) FROM WIPScan WP WITH(NOLOCK)
		--INNER JOIN VAP VP ON WP.VAP = VP.VAP AND InitChkpt = 1
		--WHERE MONo = @MONO

		--PRINT @ORDQTY PRINT @CUTQTY
		--IF ORDER QTY < GENERATED CUT QTY 
		IF(@ORDQTY <= @CUTQTY)
		BEGIN
			IF(@LAYING = 0)
			BEGIN
				INSERT INTO @STATUS
				SELECT 'Generation failed,Order quantity already reached!' AS MSG,1 AS ERROR
				RETURN
			END
			ELSE
			BEGIN
				INSERT INTO @STATUS
				SELECT 'Order quantity already completed!' AS MSG,1 AS ERROR
				RETURN
			END
		END

		IF(@LAYING = 0)
		BEGIN
--				SELECT --Size,LS.Qty,LP.Color,LP.Qty,(LS.Qty * LP.Qty) AS TTLBDLQTY
--				@GENQTY = SUM(LS.Qty * LP.Qty) FROM LAYINGHDR LH WITH(NOLOCK)
--				INNER JOIN LayingSizes LS WITH(NOLOCK) ON LH.MONo = LS.MONo AND LH.LayNo = LS.LayNo
--				INNER JOIN LayingPlyBatch LP WITH(NOLOCK) ON LH.MONo = LP.MONo AND LH.LayNo = LP.LayNo
--				WHERE LH.MONo = @MONO AND LH.LayNo = @LAYNO AND Status = 'N'

--				IF(ISNULL(@ORDQTY,0) < (ISNULL(@CUTQTY,0) + ISNULL(@GENQTY,0)))
--				BEGIN
--					INSERT INTO @STATUS
--					SELECT 'Generation failed:Lay will produce an over cut!
--Current Balance:' + CONVERT(VARCHAR(20),(ISNULL(@ORDQTY,0) - ISNULL(@CUTQTY,0))) + '' AS MSG,1 AS ERROR
--					RETURN
--				END
				DECLARE @NEWLAY TABLE
				(
					LAYCOLOR VARCHAR(20),
					LAYSIZE VARCHAR(20),
					LAYQTY INT
				)

				DECLARE @WIPCUTQTY TABLE
				(
					CUTCOLOR VARCHAR(20),
					CUTSIZE VARCHAR(20),
					CUTQTY INT,
					REPLACEMENTQTY INT
				)

				DECLARE @ORDCOLORSIZEQTY TABLE
				(
					ORDCOLOR VARCHAR(20),
					ORDSIZE VARCHAR(20),
					ORDQTY INT
				)

				INSERT INTO @NEWLAY(LAYCOLOR,LAYSIZE,LAYQTY)
				SELECT	Color,ls.Size,(LS.Qty * LP.Qty) AS TTLBDLQTY
				FROM LAYING_HDR LH WITH(NOLOCK)
				INNER JOIN Laying_Sizes LS WITH(NOLOCK) ON LH.MONo = LS.MONo AND LH.LayNo = LS.LayNo
				INNER JOIN Laying_Ply_Batch LP WITH(NOLOCK) ON LH.MONo = LP.MONo AND LH.LayNo = LP.LayNo
				WHERE LH.MONo = @MONO AND LH.LayNo = @LAYNO AND Status = 'N'

				INSERT INTO @WIPCUTQTY(CUTCOLOR,CUTSIZE,CUTQTY,REPLACEMENTQTY)
				SELECT COLOR,SIZE,(SUM(WP.QTY) + ISNULL(REROUTE.QTY,0)) AS QTY,SUM(REPLACEMENT.QTY)
				FROM WIP_Scan WP WITH(NOLOCK)
				INNER JOIN m_VAP VP ON WP.VAP = VP.code AND initial_check_point = 1
				INNER JOIN Laying_PT LP WITH(NOLOCK) ON WP.MONo = LP.MONo AND WP.LayNo = LP.LayNo AND WP.PTNo = LP.PTNo
				OUTER APPLY(SELECT SUM(QTY) AS QTY FROM Laying_PT L WITH(NOLOCK)
				INNER JOIN Laying_Hdr H ON L.MONO = H.MONo AND L.LAYNO = H.LayNo AND H.Status = 'G'
				WHERE H.MONo = @MONO AND H.LAYNO = 'RR' AND COLOR = LP.COLOR AND SIZE = LP.SIZE) AS REROUTE
				OUTER APPLY(SELECT SUM(QTY) AS QTY FROM Laying_PT L WITH(NOLOCK)
				INNER JOIN Laying_Hdr H ON L.MONO = H.MONo AND L.LAYNO = H.LayNo AND H.Status = 'G'
				WHERE H.MONo = @MONO AND H.LAYNO = LP.LayNo AND COLOR = LP.COLOR AND SIZE = LP.SIZE AND Replacement = 1) AS REPLACEMENT
				WHERE WP.MONo = @MONO
				GROUP BY Color,Size,REROUTE.QTY

				IF NOT EXISTS(SELECT TOP 1 'X' FROM @WIPCUTQTY)
				BEGIN
					INSERT INTO @WIPCUTQTY(CUTCOLOR,CUTSIZE,CUTQTY)
					SELECT Color,Size,SUM(Qty) FROM Laying_PT L WITH(NOLOCK)
					INNER JOIN Laying_Hdr H ON L.MONO = H.MONo AND L.LAYNO = H.LayNo AND H.Status = 'G'
					WHERE L.MONO = @MONO AND L.LayNo = 'RR'
					GROUP BY Color,Size
				END

				INSERT INTO @ORDCOLORSIZEQTY(ORDCOLOR,ORDSIZE,ORDQTY)
				SELECT COLOR,SIZE,SUM(QTY) AS QTY FROM MO_Det 
				WHERE MONo = @MONO
				GROUP BY Color,Size

				--SELECT * FROM @NEWLAY
				--SELECT * FROM @CUTQTY
				--SELECT * FROM @ORDQTY
				IF(@EXCESS = 0 AND @REPLACEMENT = 0)
				BEGIN
					IF EXISTS(SELECT ORDCOLOR,ORDSIZE,ORDQTY
					FROM @ORDCOLORSIZEQTY A
					OUTER APPLY (SELECT CUTQTY FROM @WIPCUTQTY WHERE CUTCOLOR = A.ORDCOLOR AND CUTSIZE = A.ORDSIZE) WIP
					OUTER APPLY (SELECT SUM(LAYQTY) AS LAYQTY FROM @NEWLAY WHERE LAYCOLOR = A.ORDCOLOR AND LAYSIZE = A.ORDSIZE) AS LAY
					--INNER JOIN @NEWLAY C ON A.ORDCOLOR = C.LAYCOLOR AND A.ORDSIZE = C.LAYSIZE
					GROUP BY ORDCOLOR,ORDSIZE,ORDQTY,CUTQTY,LAYQTY
					HAVING ORDQTY < SUM(ISNULL(CUTQTY,0) + ISNULL(LAYQTY,0)))
					BEGIN

					INSERT INTO @STATUS
					SELECT 'Fail over cut detail: ' + ' Color: ' + ORDCOLOR + ' Size: ' + ORDSIZE + ' Ord: ' + CONVERT(VARCHAR(10),ORDQTY) + ' Cut: ' + CONVERT(VARCHAR(10),ISNULL(CUTQTY,0)) + ' Bal: ' + CONVERT(VARCHAR(10),CASE WHEN (ISNULL(ORDQTY,0) - ISNULL(CUTQTY,0))< 0 THEN 0 ELSE ISNULL(ORDQTY,0) - ISNULL(CUTQTY,0) END ) AS MSG,1 ASERROR
					FROM @ORDCOLORSIZEQTY A
					OUTER APPLY (SELECT CUTQTY FROM @WIPCUTQTY WHERE CUTCOLOR = A.ORDCOLOR AND CUTSIZE = A.ORDSIZE) WIP
					OUTER APPLY (SELECT SUM(LAYQTY) AS LAYQTY FROM @NEWLAY WHERE LAYCOLOR = A.ORDCOLOR AND LAYSIZE = A.ORDSIZE) AS LAY
					GROUP BY ORDCOLOR,ORDSIZE,ORDQTY,CUTQTY,LAYQTY
					HAVING ORDQTY < SUM(ISNULL(CUTQTY,0) + ISNULL(LAYQTY,0))
					RETURN

					END
				END
				ELSE IF(@EXCESS = 1 AND @REPLACEMENT = 0)
				BEGIN
					IF(@PTGEN = 0)
					BEGIN
						IF EXISTS(SELECT ORDCOLOR,ORDSIZE,ORDQTY
						FROM @ORDCOLORSIZEQTY A
						OUTER APPLY (SELECT SUM(CUTQTY) AS CUTQTY,SUM(REPLACEMENTQTY) AS REPLACEMENTQTY FROM @WIPCUTQTY WHERE CUTCOLOR = A.ORDCOLOR AND CUTSIZE = A.ORDSIZE) WIP
						OUTER APPLY (SELECT SUM(LAYQTY) AS LAYQTY FROM @NEWLAY WHERE LAYCOLOR = A.ORDCOLOR AND LAYSIZE = A.ORDSIZE) AS LAY
						--INNER JOIN @NEWLAY C ON A.ORDCOLOR = C.LAYCOLOR AND A.ORDSIZE = C.LAYSIZE
						GROUP BY ORDCOLOR,ORDSIZE,ORDQTY,LAYQTY
						HAVING ROUND((ORDQTY + (.05 * ORDQTY)),0) <= SUM((ISNULL(CUTQTY,0) - ISNULL(REPLACEMENTQTY,0)) + ISNULL(LAYQTY,0)))
						BEGIN

						INSERT INTO @STATUS
						SELECT 'Fail over cut detail: ' + ' Color: ' + ORDCOLOR + ' Size: ' + ORDSIZE + ' Ord: ' + CONVERT(VARCHAR(10),ORDQTY) + ' Cut: ' + CONVERT(VARCHAR(10),ISNULL(CUTQTY,0)) + ' Bal: ' + CONVERT(VARCHAR(10),CASE WHEN ROUND((ISNULL(ORDQTY,0) + (.05 * ORDQTY)),0) - ISNULL(CUTQTY,0) < 0 THEN 0 ELSE CONVERT(INT,ROUND((ISNULL(ORDQTY,0) + (.05 * ORDQTY)),0) - ISNULL(CUTQTY,0)) END) AS MSG,1 ASERROR
						FROM @ORDCOLORSIZEQTY A
						OUTER APPLY (SELECT SUM(CUTQTY) AS CUTQTY,SUM(REPLACEMENTQTY) AS REPLACEMENTQTY FROM @WIPCUTQTY WHERE CUTCOLOR = A.ORDCOLOR AND CUTSIZE = A.ORDSIZE) WIP
						OUTER APPLY (SELECT SUM(LAYQTY) AS LAYQTY FROM @NEWLAY WHERE LAYCOLOR = A.ORDCOLOR AND LAYSIZE = A.ORDSIZE) AS LAY
						GROUP BY ORDCOLOR,ORDSIZE,ORDQTY,CUTQTY,LAYQTY,REPLACEMENTQTY
						HAVING ROUND((ORDQTY + (.05 * ORDQTY)),0) <= SUM((ISNULL(CUTQTY,0) - ISNULL(REPLACEMENTQTY,0)) + ISNULL(LAYQTY,0))
						RETURN
						END
					END
					ELSE
					BEGIN
						IF EXISTS(SELECT ORDCOLOR,ORDSIZE,ORDQTY
						FROM @ORDCOLORSIZEQTY A
						OUTER APPLY (SELECT SUM(CUTQTY) AS CUTQTY,SUM(REPLACEMENTQTY) AS REPLACEMENTQTY FROM @WIPCUTQTY WHERE CUTCOLOR = A.ORDCOLOR AND CUTSIZE = A.ORDSIZE) WIP
						OUTER APPLY (SELECT SUM(LAYQTY) AS LAYQTY FROM @NEWLAY WHERE LAYCOLOR = A.ORDCOLOR AND LAYSIZE = A.ORDSIZE) AS LAY
						--INNER JOIN @NEWLAY C ON A.ORDCOLOR = C.LAYCOLOR AND A.ORDSIZE = C.LAYSIZE
						GROUP BY ORDCOLOR,ORDSIZE,ORDQTY,LAYQTY
						HAVING ROUND((ORDQTY + (.05 * ORDQTY)),0) < SUM((ISNULL(CUTQTY,0) - ISNULL(REPLACEMENTQTY,0)) + ISNULL(LAYQTY,0)))
						BEGIN

						INSERT INTO @STATUS
						SELECT 'Fail over cut detail: ' + ' Color: ' + ORDCOLOR + ' Size: ' + ORDSIZE + ' Ord: ' + CONVERT(VARCHAR(10),ORDQTY) + ' Cut: ' + CONVERT(VARCHAR(10),ISNULL(CUTQTY,0)) + ' Bal: ' + CONVERT(VARCHAR(10),CASE WHEN ROUND((ISNULL(ORDQTY,0) + (.05 * ORDQTY)),0) - ISNULL(CUTQTY,0) < 0 THEN 0 ELSE CONVERT(INT,ROUND((ISNULL(ORDQTY,0) + (.05 * ORDQTY)),0) - ISNULL(CUTQTY,0)) END) AS MSG,1 ASERROR
						FROM @ORDCOLORSIZEQTY A
						OUTER APPLY (SELECT SUM(CUTQTY) AS CUTQTY,SUM(REPLACEMENTQTY) AS REPLACEMENTQTY FROM @WIPCUTQTY WHERE CUTCOLOR = A.ORDCOLOR AND CUTSIZE = A.ORDSIZE) WIP
						OUTER APPLY (SELECT SUM(LAYQTY) AS LAYQTY FROM @NEWLAY WHERE LAYCOLOR = A.ORDCOLOR AND LAYSIZE = A.ORDSIZE) AS LAY
						GROUP BY ORDCOLOR,ORDSIZE,ORDQTY,CUTQTY,LAYQTY,REPLACEMENTQTY
						HAVING ROUND((ORDQTY + (.05 * ORDQTY)),0) < SUM((ISNULL(CUTQTY,0) - ISNULL(REPLACEMENTQTY,0)) + ISNULL(LAYQTY,0))
						RETURN
						END
					END
			END
		END
	END

	INSERT INTO @STATUS
	SELECT 'CONTINUE' AS MSG,0 AS ERROR
	RETURN
	
END


go




CREATE PROCEDURE [dbo].[stg_plnUpdateMO_CPPo]
(
	@MONO		VARCHAR(50),
	@USERID		NVARCHAR(50)
)

AS

----FOR TESTING
--DECLARE @MONO VARCHAR(50) = '42013438001'
--DECLARE @USERID NVARCHAR(50) = 'system'


SET NOCOUNT ON 
	
BEGIN TRY

	IF OBJECT_ID('TEMPDB..#MOEVENTS') IS NOT NULL DROP TABLE #MOEVENTS

	DECLARE @QTY NUMERIC(18,5)
	DECLARE @SMV NUMERIC(18,5)
	DECLARE @EFF NUMERIC(18,5)
	DECLARE @MANPOW NUMERIC(18,5)
	DECLARE @WORKMIN NUMERIC(18,5)
	DECLARE @SEWDURATION INT

	SELECT @QTY = ISNULL(SUM(QTY),0) FROM DBO.MO_DET WHERE MONO = @MONO
	SELECT @SMV = PLANSMV FROM DBO.MO_HDR WHERE MONO = @MONO
	
	--SET @EFF = 0.50
	--SET @MANPOW = 44 
	--SET @WORKMIN = 7.5 * 60
	--IF EXISTS(SELECT 'X' FROM DAILYTARGETMATRIX WHERE MINORDQTY < @QTY AND MFGLOC = (SELECT MFGLOC FROM IMAPPS.DBO.MOHDR Where MONO = @MONO))
	IF EXISTS(SELECT 'X' FROM DAILY_TARGET_MATRIX WHERE MIN_SMV < @SMV AND MFG_LOC = (SELECT MFG_LOC FROM DBO.MO_HDR Where MONO = @MONO))
	BEGIN
		--SELECT TOP 1 @EFF = EFF, @MANPOW = MANPOWER, @WORKMIN = WRKMIN FROM DAILYTARGETMATRIX WHERE MINORDQTY <= @QTY AND MFGLOC = (SELECT MFGLOC FROM IMAPPS.DBO.MOHDR Where MONO = @MONO) ORDER BY MINORDQTY DESC
		SELECT TOP 1 @EFF = EFF, @MANPOW = MANPOWER, @WORKMIN = WRK_MIN FROM DAILY_TARGET_MATRIX WHERE MIN_SMV <= @SMV AND MFG_LOC = (SELECT MFG_LOC FROM DBO.MO_HDR Where MONO = @MONO) ORDER BY MIN_SMV DESC
	END
	ELSE
	BEGIN
		SET @EFF = 0.50
		SET @MANPOW = 44 
		SET @WORKMIN = 7.5 * 60
	END

	--SET @SEWDURATION = CEILING((@QTY * @SMV / @EFF) / (@MANPOW * @WORKMIN)) 	
	SET @SEWDURATION = CEILING(@QTY / ((@MANPOW * @WORKMIN / @SMV) * @EFF))

	SELECT
		[SEQ] = ROW_NUMBER() OVER (ORDER BY ME.SEQ_NO),
		ME.MONO,
		[MFG_LOC] = (SELECT TOP 1 SQ.MFG_LOC FROM DBO.MO_HDR SQ WHERE SQ.MONO = ME.MONO),
		ME.EVENT_SEQ,
		[PO_START] = CAST(NULL AS DATETIME),
		[PO_END] = CAST(NULL AS DATETIME),
		ME.VAP,
		[REQ_DURATION] = CASE WHEN ME.VAP = 'SEW' THEN @SEWDURATION ELSE ME.REQ_DURATION END,
		[PREDECESSOR] = ME.PRED, --ME.PREDECESSOR,
		[SUCCESSOR] = ME.SUCC --ME.SUCCESSOR
	INTO #MOEVENTS
	--FROM IMAPPS.DBO.MOEVENTSVW ME
	FROM
	(
	SELECT e.*
	, isnull(STUFF((SELECT ',' + cast(Event_Seq as varchar(5)) FROM [MO_Events] WHERE Successor = e.Event_Seq and MONo = e.MONo FOR XML PATH('')), 1, 1, ''),e.Predecessor) AS Pred
	, isnull(STUFF((SELECT ',' + cast(Event_Seq as varchar(5)) FROM [MO_Events] WHERE Predecessor = e.Event_Seq and MONo = e.MONo FOR XML PATH('')), 1, 1, ''),e.Successor) AS Succ
	FROM [MO_Events] e 
	) ME
	WHERE MONO = @MONO


	DECLARE @MFGLOC VARCHAR(50)
	DECLARE @POSEQ INT
	DECLARE @SEWSEQ INT
	DECLARE @MINSEQ INT
	DECLARE @MAXSEQ INT
	DECLARE @SEQ INT


	SELECT
		@MFGLOC = MIN(MFG_LOC),
		@MINSEQ = MIN(SEQ),
		@MAXSEQ = MAX(SEQ),
		@POSEQ = MIN(CASE WHEN EVENT_SEQ = '605' THEN SEQ ELSE NULL END),
		@SEWSEQ = MIN(CASE WHEN VAP = 'SEW' THEN SEQ ELSE NULL END)
	FROM #MOEVENTS


	UPDATE ME
	--SET POSTART = (SELECT TOP 1 SQ.PODDT FROM IMAPPS.DBO.MODET SQ WHERE SQ.MONO = ME.MONO AND SQ.QTY > 0),
	--	POEND = (SELECT TOP 1 SQ.PODDT FROM IMAPPS.DBO.MODET SQ WHERE SQ.MONO = ME.MONO AND SQ.QTY > 0)
	SET PO_START = [DBO].[PRDGETDURATIONWORKDATE](1, ME.MFG_LOC, ([DBO].[PRDGETDURATIONWORKDATE](1, ME.MFG_LOC, 
					  (SELECT min(POD_DT) AS POD_DT FROM DBO.MO_DET WHERE MONO = @MONO AND QTY > 0), 1)), -1),
		PO_END = [DBO].[PRDGETDURATIONWORKDATE](1, ME.MFG_LOC, ([DBO].[PRDGETDURATIONWORKDATE](1, ME.MFG_LOC, 
				(SELECT min(POD_DT) AS POD_DT FROM DBO.MO_DET WHERE MONO = @MONO AND QTY > 0), 1)), -1)
	FROM #MOEVENTS ME
	WHERE ME.SEQ = @POSEQ


	SET @SEQ = @POSEQ		
	WHILE (@SEQ < @MAXSEQ)
	BEGIN
		UPDATE ME
		SET PO_START = CASE 
							WHEN ME.REQ_DURATION = 0 THEN
								CASE WHEN ME.PO_START IS NULL THEN ME2.PO_START 
								ELSE CASE WHEN ME.PO_START < ME2.PO_START THEN ME.PO_START ELSE ME2.PO_START END END
							WHEN ME.PO_START IS NOT NULL AND 
								 ME.PO_START < [DBO].[PRDGETDURATIONWORKDATE](1, ME.MFG_LOC, ME2.PO_END, 1)
								 THEN ME.PO_START
							ELSE [DBO].[PRDGETDURATIONWORKDATE](1, ME.MFG_LOC, ME2.PO_END, 1) 
					  END,
			PO_END = CASE 
						WHEN ME.REQ_DURATION = 0 THEN
							CASE WHEN ME.PO_END IS NULL THEN ME2.PO_END 
							ELSE CASE WHEN ME.PO_END < ME2.PO_END THEN ME.PO_END ELSE ME2.PO_END END END
						WHEN ME.PO_END IS NOT NULL AND
							ME.PO_END < [DBO].[PRDGETDURATIONWORKDATE](ME.REQ_DURATION, ME.MFG_LOC, ME2.PO_END, 1)
							THEN ME.PO_END
						ELSE [DBO].[PRDGETDURATIONWORKDATE](ME.REQ_DURATION, ME.MFG_LOC, ME2.PO_END, 1) 
					END
		FROM #MOEVENTS ME
		INNER JOIN #MOEVENTS ME2 ON 
			--ME2.EVENTSEQ = ME.PREDECESSOR
			CHARINDEX(CAST(ME2.EVENT_SEQ AS VARCHAR), ME.PREDECESSOR, 1) > 0
		WHERE 
			ME2.SEQ = @SEQ

		SET @SEQ = @SEQ + 1
	END


	SET @SEQ = @POSEQ
	WHILE (@SEQ > @SEWSEQ)
	BEGIN
		UPDATE ME 
		SET PO_START = CASE 
							WHEN ME.REQ_DURATION = 0 THEN 
								CASE WHEN ME.PO_START IS NULL THEN ME2.PO_START 
								ELSE CASE WHEN ME.PO_START < ME2.PO_START THEN ME.PO_START ELSE ME2.PO_START END END
							WHEN ME.PO_START IS NOT NULL AND 
									ME.PO_START < [DBO].[PRDGETDURATIONWORKDATE](ME.REQ_DURATION, ME.MFG_LOC, ME2.PO_START, -1)
									THEN ME.PO_START
							ELSE [DBO].[PRDGETDURATIONWORKDATE](ME.REQ_DURATION, ME.MFG_LOC, ME2.PO_START, -1) 
					  END,
			PO_END = CASE 
						WHEN ME.REQ_DURATION = 0 THEN
							CASE WHEN ME.PO_END IS NULL THEN ME2.PO_END 
							ELSE CASE WHEN ME.PO_END < ME2.PO_END THEN ME.PO_END ELSE ME2.PO_END END END
						WHEN ME.PO_END IS NOT NULL AND
								ME.PO_END < [DBO].[PRDGETDURATIONWORKDATE](1, ME.MFG_LOC, ME2.PO_START, -1)
								THEN ME.PO_END
						ELSE [DBO].[PRDGETDURATIONWORKDATE](1, ME.MFG_LOC, ME2.PO_START, -1) 
					END
		FROM #MOEVENTS ME
		INNER JOIN #MOEVENTS ME2 ON 
			--ME2.PREDECESSOR = ME.EVENTSEQ
			CHARINDEX(CAST(ME.EVENT_SEQ AS VARCHAR), ME2.PREDECESSOR, 1) > 0
		WHERE 
			ME2.SEQ = @SEQ
					
		SET @SEQ = @SEQ - 1
	END


	SET @SEQ = @SEWSEQ
	WHILE (@SEQ > 1)
	BEGIN
		UPDATE ME 
		SET PO_START = CASE 
							WHEN ME.REQ_DURATION = 0 THEN 
								CASE WHEN ME.PO_START IS NULL THEN ME2.PO_START 
								ELSE CASE WHEN ME.PO_START < ME2.PO_START THEN ME.PO_START ELSE ME2.PO_START END END
							WHEN ME.PO_START IS NOT NULL AND 
									ME.PO_START < [DBO].[PRDGETDURATIONWORKDATE](ME.REQ_DURATION, ME.MFG_LOC, ME2.PO_START, -1)
									THEN ME.PO_START
							ELSE [DBO].[PRDGETDURATIONWORKDATE](ME.REQ_DURATION, ME.MFG_LOC, ME2.PO_START, -1) 
					  END,
			PO_END = CASE 
						WHEN ME.REQ_DURATION = 0 THEN 
							CASE WHEN ME.PO_END IS NULL THEN ME2.PO_END 
							ELSE CASE WHEN ME.PO_END < ME2.PO_END THEN ME.PO_END ELSE ME2.PO_END END END
						WHEN ME.PO_END IS NOT NULL AND
								ME.PO_END < [DBO].[PRDGETDURATIONWORKDATE](1, ME.MFG_LOC, ME2.PO_START, -1)
								THEN ME.PO_END
						ELSE [DBO].[PRDGETDURATIONWORKDATE](1, ME.MFG_LOC, ME2.PO_START, -1) 
					END
		FROM #MOEVENTS ME
		INNER JOIN #MOEVENTS ME2 ON 
			--ME2.EVENTSEQ = ME.SUCCESSOR
			CHARINDEX(CAST(ME2.EVENT_SEQ AS VARCHAR), ME.SUCCESSOR, 1) > 0
		WHERE 
			ME2.SEQ = @SEQ

		SET @SEQ = @SEQ - 1
	END


	UPDATE ME
	SET ME.PO_START = ME2.PO_START,
		ME.PO_END = ME2.PO_END,
		ME.UPDATED_BY = @USERID,
		ME.Time_UPDATED = GETDATE()
	FROM DBO.MO_EVENTS ME
	INNER JOIN #MOEVENTS ME2 ON
		ME2.MONO = ME.MONO AND
		ME2.EVENT_SEQ = ME.EVENT_SEQ


	IF OBJECT_ID('TEMPDB..#MOEVENTS') IS NOT NULL DROP TABLE #MOEVENTS
	SELECT 0 AS [STATUS], 'UPDATED' AS ERROR_MSG

END TRY
BEGIN CATCH
	SELECT ERROR_MESSAGE()
END CATCH


go




-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[qconn_display_references]
	-- Add the parameters for the stored procedure here
	@search varchar(20) = ''
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	select id = (row_number() over (order by ref_code,value_)),
	ref_code as code,value_ as description 
	from wip_references --with(index(Wip_References_ref_code))
	where ref_code = @search

END


go


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[qconn_transfer_pt_output_partial_from] 
@ptno varchar(30), @prodline varchar(10),  @datefrom varchar(10) = ''
	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

   /*
	declare @ptno varchar(30), @prodline varchar(10),  @dateinspected varchar(10) = ''
	set @ptno = '401200050189'
	set @prodline = 'L15'
	set @dateinspected = '10/16/2021'
	*/

	declare  @ioline varchar(200), @mono varchar(20)
	select @mono = (select top 1 mono from laying_pt where ptno = @ptno)
	set @ioline = isnull( (select STUFF((select  ',' +  iOLn from MODet aa inner join IODet bb on aa.ItemNo = bb.ItemNo where aa.MONo = @mono FOR XML PATH('')), 1, 1, '') ),'')

	select id = (row_number() over (order by a.ptno, a.seq)),*,@ioline as ioline from (

	select --id = (row_number() over (order by a.ptno, a.seq)),
	--a.seq as id,
	a.ptno, a.seq, a.prodline
	--,case when b.ptno is NULL then '1' else '' end as 'Goodrft'
	--,case when b.rejecttype in ('REWORK') then '1' else '' end as 'Rework'
	--,case when b.ptno is not NULL then '1' else '' end as 'Reject'
	--,isnull(b.NewRFID,'') as 'TagRFID'
	,'1' as 'Goodrft'
	,''  as 'Rework'
	,''  as 'Reject'
	,'' as 'TagRFID'
	,a.CreatedBy as  'InspectedBy', a.CreatedDt as 'InspectedDate'
	--, isnull(b.FixedUserID,'') as 'FixedBy', isnull(convert(varchar(30),b.fixeddt),'') as 'FixedDate' 
	,'' as 'FixedBy', '' as 'FixedDate'
	from endlineqchdr a
	--left outer join endlineqcrfid b on b.ptno = a.ptno and b.seq = a.seq
	where a.ptno = @ptno 
	and a.prodline = (case when @prodline != '' then @prodline else a.prodline end )
	and convert(date,a.createddt,101) = (case when @datefrom != '' then @datefrom else convert(date,a.CreatedDt,101)  end )
	and a.reject = 0
	--order by a.ptno, a.seq

	union all

	select --id = (row_number() over (order by a.ptno, a.seq)),
	--a.seq as id,
	a.ptno, a.seq, a.prodline
	,'' as 'Goodrft'
	,''  as 'Rework'
	,'1'  as 'Reject'
	,b.newrfid as 'TagRFID'
	,a.CreatedBy as  'InspectedBy', a.CreatedDt as 'InspectedDate'
	,'' as 'FixedBy', '' as 'FixedDate'
	from endlineqchdr a
	inner join  endlineqcrfid b on b.ptno = a.ptno and b.seq = a.seq and fixeddt is NULL and b.status <> 'CONDPASS'
	where a.ptno = @ptno 
	and a.prodline = (case when @prodline != '' then @prodline else a.prodline end )
	and convert(date,a.createddt,101) = (case when @datefrom != '' then @datefrom else convert(date,a.CreatedDt,101)  end )
	--order by a.ptno, a.seq

	--condpass
	union all

	select --id = (row_number() over (order by a.ptno, a.seq)),
	--a.seq as id,
	a.ptno, a.seq, a.prodline
	,cast(b.qty as varchar(10)) as 'Goodrft'
	,''  as 'Rework'
	,''  as 'Reject'
	,b.newrfid as 'TagRFID'
	,a.CreatedBy as  'InspectedBy', a.CreatedDt as 'InspectedDate'
	,'' as 'FixedBy', '' as 'FixedDate'
	from endlineqchdr a
	inner join  endlineqcrfid b on b.ptno = a.ptno and b.seq = a.seq and fixeddt is NULL and b.status = 'CONDPASS'
	where a.ptno = @ptno 
	and a.prodline = (case when @prodline != '' then @prodline else a.prodline end )
	and convert(date,a.createddt,101) = (case when @datefrom != '' then @datefrom else convert(date,a.CreatedDt,101)  end )
	

	union all

	select --id = (row_number() over (order by a.ptno, a.seq)),
	--a.seq as id,
	a.ptno, a.seq, a.prodline
	,'' as 'Goodrft'
	,case when exists (select aa.ptno from wipscan aa where aa.ptno = a.ptno and aa.qcseq = a.seq ) then '1' else '0' end  as 'Rework' 
	--,'1'  as 'Rework' 
	--,'1'  as 'Reject'
	,'Reject' = case when convert(varchar(10), transdt, 101) = convert(varchar(10), fixeddt, 101) then '1' else '' end
	,b.newrfid as 'TagRFID'
	,a.CreatedBy as  'InspectedBy', a.CreatedDt as 'InspectedDate'
	, isnull(b.FixedUserID,'') as 'FixedBy', isnull(convert(varchar(30),b.fixeddt),'') as 'FixedDate' 
	from endlineqchdr a
	inner join  endlineqcrfid b on b.ptno = a.ptno and b.seq = a.seq and fixeddt is not NULL
	where a.ptno = @ptno 
	and a.prodline = (case when @prodline != '' then @prodline else a.prodline end )
	and convert(date,b.fixeddt,101) = (case when @datefrom != '' then @datefrom else convert(date,b.fixeddt,101)  end )
	--order by a.ptno, a.seq


	union all

	select --id = (row_number() over (order by a.ptno, a.seq)),
	--a.qcseq as id,
	a.ptno, a.qcseq, a.worksection as prodline
	,cast(qty as varchar(6)) as 'Goodrft'
	,''  as 'Rework'
	,''  as 'Reject'
	,'' as 'TagRFID'
	,a.CreatedBy as  'InspectedBy', a.scandt as 'InspectedDate'
	, '' as 'FixedBy', '' as 'FixedDate' 
	from wipscan a 
	where a.ptno = @ptno
	and worksection = (case when @prodline != '' then @prodline else a.worksection end )
	and vap = 'ASSY-PPCK'
	and convert(date,a.scandt,101) = (case when @datefrom != '' then @datefrom else convert(date,a.scandt,101)  end )
	and qcseq = 0
	--order by a.ptno, a.seq
	) a
	order by a.ptno, a.seq

END

go



-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[qconn_pt_get_daily_output]
	-- Add the parameters for the stored procedure here
	@ptno varchar(20), @prodline varchar(20), @datefrom varchar(10)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    /*declare @ptno varchar(20), @line varchar(20), @datefrom varchar(10)
	set @ptno = '401200024158'
	set @line = 'L22'
	set @datefrom = '01/23/2020'
	*/
	select id, convert(varchar(10),trans_date,101) as trans_date, mono, ptno, style, color, layno, line as prodline
	--, good_qty
	,good_qty = 
	(select isnull(count(*),0) from endlineqchdr a
	--inner join endlineqcrfid b on b.ptno = a.ptno and b.seq = a.seq --and b.status <> 'CONDPASS'
	where a.ptno = @ptno and reject = 0 and convert(varchar(10), a.createddt, 101) = @datefrom and a.prodline = @prodline)
	
	+ (select isnull(sum(b.qty),0) from endlineqchdr a
	inner join endlineqcrfid b on b.ptno = a.ptno and b.seq = a.seq and b.status = 'CONDPASS' and b.cpstatus != 0
	where a.ptno = @ptno and reject = 1 and convert(varchar(10), a.createddt, 101) = @datefrom and a.prodline = @prodline)

	+ (select isnull(sum(qty),0) from wipscan a 
	where a.ptno = @ptno
	and worksection = (case when @prodline != '' then @prodline else a.worksection end )
	and convert(date,a.scandt,101) = (case when @datefrom != '' then @datefrom else convert(date,a.scandt,101)  end )
	and vap = 'ASSY-PPCK'
	and qcseq = 0)

	, reject_qty
	, reworked_qty = (select count(*) from endlineqcrfid where ptno = @ptno  and convert(varchar(10), fixeddt, 101) = @datefrom and prodline = @prodline )
	, repaired_qty
	, unreapairable_qty
	, replaceable_qty
	, prev_reworked
	, secondquality_qty
	--, isnull(good_qty,0) + isnull(reject_qty,0) as total_inspected
	,total_inspected = (select isnull(count(*),0) from endlineqchdr where ptno = @ptno and reject = 0 and convert(varchar(10), createddt, 101) = @datefrom and prodline = @prodline)
	+ (select isnull(count(*),0) from endlineqcrfid where ptno = @ptno  and convert(varchar(10), fixeddt, 101) = @datefrom and prodline = @prodline )
	+ (select isnull(sum(qty),0) from wipscan a 
	where a.ptno = @ptno
	and worksection = (case when @prodline != '' then @prodline else a.worksection end )
	and convert(date,a.scandt,101) = (case when @datefrom != '' then @datefrom else convert(date,a.scandt,101)  end )
	and vap = 'ASSY-PPCK'
	and qcseq = 0)
	
	+ (select isnull(sum(qty),0) from endlineqcrfid where ptno = @ptno  and convert(varchar(10), transdt, 101) = @datefrom and prodline = @prodline and cpApprovedDt is not NULL and status = 'CONDPASS' )
	- ( 1 * (select isnull(count(*),0) 
		from endlineqcrfid aa
		left outer join wipscan bb on bb.ptno = aa.ptno and bb.qcseq = aa.seq
		where aa.ptno = @ptno  and convert(varchar(10), fixeddt, 101) = @datefrom and prodline = @prodline 
		and bb.ptno is NULL
		--and seq not in (select seq from wipscan where ptno = aa.ptno and qcseq = aa.seq )
		) )

	from qconn_output_detail_daily_v3 a
	where a.ptno = @ptno and a.line = @prodline and convert(varchar(10), trans_date,101) = @datefrom

END


go



CREATE FUNCTION [dbo].[prdCheckCapacityFN]
(
	@LINE VARCHAR(50),
	@DATE DATETIME
)

RETURNS CHAR(1)

AS

BEGIN
	
	DECLARE @MFGLOC VARCHAR(20)
	SELECT
		@MFGLOC = MFG_LOC
	FROM DBO.m_PROD_LINES
	WHERE
		PROD_LINE = @LINE AND
		active = 1


	DECLARE @WRK_TIME TABLE
	(
		SEQ INT IDENTITY(1, 1),
		TIME_FROM TIME,
		TIME_TO TIME
	)

	INSERT INTO @WRK_TIME
		(TIME_FROM, TIME_TO)
	SELECT 
		WMD.TIME_FROM,
		WMD.TIME_TO
	FROM DBO.PROD_LINES_WM WM
	INNER JOIN DBO.PROD_LINES_WM_DET WMD ON
		WMD.MFG_LOC = WM.MFG_LOC AND
		WMD.PROD_LINE = WM.PROD_LINE AND
		WMD.EX_NAME = WM.EX_NAME
	WHERE
		CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN CAST((CONVERT(VARCHAR, WM.DATE_FROM, 101)) AS DATETIME) AND
			CAST((CONVERT(VARCHAR, WM.DATE_TO, 101)) AS DATETIME) AND
		WM.MFG_LOC = @MFGLOC AND
		WM.PROD_LINE = @LINE AND
		(
			EXISTS(SELECT 1 FROM DBO.PROD_LINES_EX EX WHERE EX.MFG_LOC = @MFGLOC AND EX.PROD_LINE = @LINE AND
					(CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN CAST((CONVERT(VARCHAR, EX.DATE_FROM, 101)) AS DATETIME) AND 
					CAST((CONVERT(VARCHAR, EX.DATE_TO, 101)) AS DATETIME)) AND EX.active = 1 AND EX.MANPOWER > 0) OR
			(
				NOT EXISTS(SELECT 1 FROM DBO.PROD_LINES_EX EX WHERE EX.MFG_LOC = @MFGLOC AND EX.PROD_LINE = @LINE AND
							(CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN 
							CAST((CONVERT(VARCHAR, EX.DATE_FROM, 101)) AS DATETIME) AND 
							CAST((CONVERT(VARCHAR, EX.DATE_TO, 101)) AS DATETIME)) AND EX.active = 1 AND EX.MANPOWER <= 0) AND
				(SELECT TOP 1 MP.MANPOWER FROM DBO.PROD_LINES_MP MP WHERE MP.MFG_LOC = @MFGLOC AND MP.PROD_LINE = @LINE AND
					CAST((CONVERT(VARCHAR, MP.EFFECT_DT, 101)) AS DATETIME) <= CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) AND
					MP.active = 1 ORDER BY CAST((CONVERT(VARCHAR, MP.EFFECT_DT, 101)) AS DATETIME) DESC) > 0
			)
		)
	ORDER BY CONVERT(TIME, WMD.TIME_FROM)

	IF ((SELECT COUNT(1) FROM @WRK_TIME) = 0)
	BEGIN
		INSERT INTO @WRK_TIME
			(TIME_FROM, TIME_TO)
		SELECT 
			TIME_FROM,
			TIME_TO
		FROM DBO.CALENDAR_WEEK_DAY_DET DET
		WHERE
			CALENDAR = @MFGLOC AND
			WEEK_NAME = (SELECT TOP 1 WEEK_NAME FROM DBO.CALENDAR_WEEK 
						WHERE @DATE BETWEEN DATE_FROM AND DATE_TO) AND
			[WEEK_DAY] = DATENAME(WEEKDAY, @DATE) AND
			NOT EXISTS (SELECT 1 FROM DBO.CALENDAR_EX EX WHERE EX.CALENDAR = DET.CALENDAR AND 
						CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN 
						CAST((CONVERT(VARCHAR, EX.DATE_FROM, 101)) AS DATETIME) AND
						CAST((CONVERT(VARCHAR, EX.DATE_TO, 101)) AS DATETIME)) AND
			(
				EXISTS(SELECT 1 FROM DBO.PROD_LINES_EX EX WHERE EX.MFG_LOC = @MFGLOC AND EX.PROD_LINE = @LINE AND
						(CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN CAST((CONVERT(VARCHAR, EX.DATE_FROM, 101)) AS DATETIME) AND 
						CAST((CONVERT(VARCHAR, EX.DATE_TO, 101)) AS DATETIME)) AND EX.active = 1 AND EX.MANPOWER > 0) OR
				(
					NOT EXISTS(SELECT 1 FROM DBO.PROD_LINES_EX EX WHERE EX.MFG_LOC = @MFGLOC AND EX.PROD_LINE = @LINE AND
								(CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN 
								CAST((CONVERT(VARCHAR, EX.DATE_FROM, 101)) AS DATETIME) AND 
								CAST((CONVERT(VARCHAR, EX.DATE_TO, 101)) AS DATETIME)) AND EX.active = 1 AND EX.MANPOWER <= 0) AND
					(SELECT TOP 1 MP.MANPOWER FROM DBO.PROD_LINES_MP MP WHERE MP.MFG_LOC = @MFGLOC AND MP.PROD_LINE = @LINE AND
						CAST((CONVERT(VARCHAR, MP.EFFECT_DT, 101)) AS DATETIME) <= CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) AND
						MP.active = 0 ORDER BY CAST((CONVERT(VARCHAR, MP.EFFECT_DT, 101)) AS DATETIME) DESC) > 0
				)
			)
		ORDER BY
			CONVERT(TIME, TIME_FROM)
	END


	DECLARE @RESULT CHAR(1)
	IF EXISTS(SELECT 1 FROM @WRK_TIME)
	BEGIN
		SELECT @RESULT = 'T'
	END
	ELSE
	BEGIN
		SELECT @RESULT = 'F'
	END

	RETURN @RESULT

END


go

-- exec [prdScanWIPSP] 'ASSY-PPCK', 'ISS','401200036545'
CREATE PROCEDURE [dbo].[prdScanWIPSP]
--ALTER PROCEDURE [dbo].[prdScanWIPSP] (@VAP varchar(20), @SVAP varchar(20), @WS varchar(10), @PTNo varchar(13), @UserId varchar(20), @ScanDt datetime, @Authorized nvarchar(50), @DayNightShft varchar(15),@sWSIss varchar(10))
(
	@VAP		VARCHAR(20),
	@SVAP		VARCHAR(20),
	@ISSPL		VARCHAR(10),
	@PTNO		VARCHAR(20),
	@USERID		NVARCHAR(50),
	@SCANDT		Datetime,
	@AUTHOR		NVARCHAR(50),
	@SHIFT		VARCHAR(15),
	@Qty		int,
	@RCVPL		VARCHAR(10),
	@Reject		bit = 0,
 	@ElqcSeq	int = 0,
	@result varchar(10) = 'Successful' output
)
AS

SET NOCOUNT ON

declare @mono varchar(20);

DECLARE @SCNQTY INT, @RejectQTY INT
DECLARE @PrevVAP VARCHAR(20), @PrevSVAP VARCHAR(20), @PrevQty INT
-- declare @PlanQty int = 0

BEGIN TRY

		BEGIN

		    /* Get MONo By PTNo */
            select @mono = mono from Laying_PT where PTNo = @ptno

            /* Get Previous VAP */
            SELECT TOP 1
            @PrevVAP = VAP,
            @PrevSVAP= SVAP
            FROM MO_VAP_SVAP WHERE MONo = @MONO AND GVAP IN
            (
                SELECT GVAP FROM MO_VAP_SVAP WHERE VAP = @VAP AND SVAP = @SVAP AND MONo = @MONO
            )
            AND Seq2 < (SELECT Seq2 FROM MO_VAP_SVAP WHERE VAP = @VAP AND SVAP = @SVAP AND MONo = @MONO)
            AND ACTIVE = 1
            AND SVAP <> @SVAP
            ORDER BY Seq2 DESC

            /* Get Received Qty */
            SELECT
            @PrevQty = SUM(QTY)
            FROM WIPSCAN WHERE MONO = @MONO
            AND VAP = @PrevVAP AND SVAP = @PrevSVAP
            AND PTNO = @PTNO


            /* Get Scanned Qty */
            SELECT
            @SCNQTY = count(1)
            FROM
            EndLineQCHdr
            WHERE ProdLine = @ISSPL and PTNo = @PTNO

		    /* Get Reject Qty */
            SELECT
            @RejectQTY = count(1)
            FROM
            EndLineQCHdr a inner join EndLineQCRFID b on a.ProdLine = b.ProdLine and a.Seq = b.Seq
            WHERE a.ProdLine = @ISSPL and a.PTNo = @PTNO and a.Reject = 1 and b.Status = 'REJECT'

		    /* Check Balance */
--             if (ISNULL(@PREVQTY, 0) < (ISNULL(@SCNQTY, 0) + ISNULL(@QTY, 0) - ISNULL(@RejectQTY, 0)))
		    if (ISNULL(@PREVQTY, 0) < (ISNULL(@SCNQTY, 0) - ISNULL(@RejectQTY, 0)))
            begin

                select 'More than ' + @PrevSVAP + ' qty ' + CONVERT(VARCHAR(10), @PrevQty) + ' available qty: '
                    + CONVERT(VARCHAR(10),(ISNULL(@PrevQty,0) - ISNULL(@SCNQTY,0))), 1 as ERROR
                commit transaction
                return

            end
		  /*  else
		    begin

		        /* Start - original */
			    EXEC [dbo].[prdScanWIPSP_MOD2] @VAP, @SVAP, @RCVPL, @PTNo, @USERID, @SCANDT, @AUTHOR, @SHIFT, @ISSPL, @QTY, @Reject, 0 --@ElqcSeq
		        /* End - original */

            end
			*/
		END

END TRY
BEGIN CATCH
	SELECT ERROR_MESSAGE()
END CATCH
go




CREATE PROCEDURE [dbo].[stg_ordSyncMO_ByDelDt]
	--[dbo].[ordSyncMO_ByDelDt] 'test'
	-- Add the parameters for the stored procedure here
--	@SrcERP		varchar(10),
--	@PlantCd	varchar(10),
	@UserId		NVARCHAR(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	
	SET NOCOUNT ON;

	--Declare @UserId as nvarchar(50)
	--Set @UserId = 'conrad'

	BEGIN TRY

	DECLARE @RecId AS varchar(100)
	DECLARE @CheckpointTemplate varchar(50)
	
	Select top 1 @CheckpointTemplate = Template_ID from VAPSVAP_Template_Hdr Where isnull(Deleted,0) = 0 and Template_ID in (Select Template_ID from VAPSVAP_Template_Det)
	
	
	Set @RecId = NEWID()

	INSERT INTO [dbo].[stg_SyncLog]([Recid],[RunTime],[CreatedBy],[Remarks])
     VALUES(@RecId, getdate(), @UserId, 'ordSyncMO_ByDelDt - Initialize.')

		--Insert StyleImage
		INSERT INTO [dbo].[Style_Image]
           ([Style_No])
		SELECT DISTINCT sIO.Style_No
		FROM (Select distinct IONo, Style_No, Cust_Desc from IO_Det) AS sIO LEFT OUTER JOIN
            dbo.Style_Image AS sh ON sIO.Style_No = sh.Style_No
			WHERE (sh.Style_No IS NULL)

		--For Testing
		--Select distinct top 1 iod.IONo into #IOs from IODet iod with (nolock) 
		--		Left outer join MOHdr mh with (nolock) ON iod.IONo = mh.IONo
		--	 Where 
		--	 mh.IONo is null
		--	 and iod.IONo = '11530801'
		--	 --and iod.PODDT between '5/1/2019' and '5/5/2019' 
		--	 and iod.Qty > 0

		--For Prod
		Select distinct ioh.IONo into #IOs from IO_Hdr ioh with (nolock) inner join IO_Det iod with (nolock) on ioh.IONo = iod.IONo
				Left outer join MO_Det md with (nolock) ON iod.Item_No = md.Item_No
			 Where 
			 md.Item_No is null
			 --and ioh.CreatedDt >= '5/1/2019' 
			 and iod.Qty > 0
			 and 'PODDt' = (Select top 1 Split_Type from Cust_Grp_Split_Config Where Mfg_Loc = ioh.Mfg_Loc and Cust_Grp = ioh.Cus_Grp and Effective_Dt <= ioh.time_Created)

			---Insert New MOHdr for New IO or CO
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByDelDt - Insert MO Header.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MO_Hdr]
		([sbu_id],[plan_completed],[re_routed],[MONo],[IONo],[Split_No],[Plant],[Mfg_Loc],[Style_No],[Prod_Type],[MO_Status],[Board_Color]--,[LPDDt]
		,[PSD_Dt],[Cus_Del_Dt],[Rev_Cus_Del_Dt],[Transit_Days],[Req_Ex_Fty_Dt],[Prod_Days],[Req_Prod_Start],[Mat_Prep_Lead],[Main_Mat_Lead]
		--,[ReqMatETA]
		,[Req_Main_MatETA],[Sub_Mat_Lead],[Req_Sub_MatETA],[Eff],[Prod_Min],[MerchSMV],[TcSMV],[PlanSMV],[Pre_Sew]
		,[Post_Sew],[Remarks]--,[LevelNo],[End_State]
		,[Active],[Created_By],[Time_Created],[CONo],[Prod_Month],[Rev_Ex_Fty_Dt],[Ref_Auto_Create_MO])

		Select 1,0,0,x.IONo + right('00'+cast(row_number() over (partition by x.IONo order by x.IONo) + isnull(s.MaxSplitNo,0) AS varchar(3)),3) AS MONo, 
		x.IONo, row_number() over (partition by x.IONo order by x.IONo) + isnull(s.MaxSplitNo,0) AS SplitNo, ioh.Plant_id,ioh.Mfg_Loc_id, ioh.Style_No
		, (select code from m_prod_type where id = ioh.Prod_Type_id)
		, 'Created', ioh.Board_Color--, ioh.LPDDt
		,ioh.PSD_Dt,ioh.Cust_Del_Dt AS CusDelDt,ioh.Cust_Del_Dt as RevCusDelDt,ot.Transit_Days,dateadd(d,-1*ot.Transit_Days,ioh.Cust_Del_Dt) AS ReqExFtyDt, ot.Prod_Days, 
		dateadd(d,-1*(ot.Transit_Days+ot.Prod_Days),ioh.Cust_Del_Dt) AS ReqProdStart, ot.Mat_Prep_Lead, ot.Main_Mat_Lead,
		--dateadd(d,-1*(ot.Transit_Days+ot.Prod_Days+ot.Mat_Prep_Lead),ioh.Cust_Del_Dt) AS ReqMatETA,
		dateadd(d,-1*(ot.Transit_Days+ot.Prod_Days+ot.Mat_Prep_Lead+ot.Main_Mat_Lead),ioh.Cust_Del_Dt) AS ReqMainMatETA,
		ot.Sub_Mat_Lead, dateadd(d,-1*(ot.Transit_Days+ot.Prod_Days+ot.Sub_Mat_Lead),ioh.Cust_Del_Dt) AS ReqSubMatETA, 0 As Eff, 0 As ProdMin, ioh.Merch_SMV, ioh.Tc_SMV, isnull(sty.SMV,ioh.Plan_SMV) as PlanSMV, 0 AS PreSew,
		0 As PostSew, ioh.Remarks--, 1 as LevelNo, 1 AS EndState
		, 1 As Active, @UserId AS CreatedBy, getdate() As CreatedDt, x.CONo, cast(cast(month(x.PODDt) AS varchar) + '/1/' + cast(year(x.PODDt) as varchar) as datetime) AS PlanMonth
		,x.Dlv_Dt,x.Dlv_Dt
		From (
				SELECT /*DISTINCT*/ dbo.IO_Det.IONo, dbo.IO_Det.Dlv_Dt, null as CONo, min(dbo.IO_Det.POD_Dt) as PODDt
				FROM dbo.IO_Det INNER JOIN dbo.IO_Hdr ON dbo.IO_Det.IONo = dbo.IO_Hdr.IONo 
						LEFT OUTER JOIN
							(Select DISTINCT h.IONo, d.Dlv_Dt from dbo.MO_Hdr h inner join dbo.MO_Det d on h.MONo = d.MONo) mhd
								ON dbo.IO_Det.IONo = mhd.IONo AND dbo.IO_Det.Dlv_Dt = mhd.Dlv_Dt
				WHERE (mhd.IONo IS NULL) 
				and dbo.IO_Det.Qty > 0
				--and not exists (Select 'x' from MODet MD inner join MOHdr MH On MD.MONo = MH.MONo 
				--					Where MH.IONo = dbo.IODet.IONo and MD.DlvDt = dbo.IODet.DlvDt)
				GROUP BY dbo.IO_Det.IONo, dbo.IO_Det.Dlv_Dt
			 ) x inner join IO_Hdr ioh on x.IONo = ioh.IONo inner join m_Order_Types ot on ioh.Order_Type_id = ot.id 
			 left outer join (Select IONo, Max(Split_No) as MaxSplitNo from MO_Hdr group by IONo) s on x.IONo = s.IONo
		Where 
		--x.IONo = '10047701'	
		x.IONo in (Select IONo from #IOs)		

		--Insert MODet for No MODet yet
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByDelDt - Insert MO Details to New MO.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MO_Det]
		([sbu_id],[MO_id],[mono],[Item_No],[CPO_No],[CPO_Item],[CPO_Dt],[Cust_Style],[Cust_Desc],[Cust_Color],[Cust_Size],[Cust_Dest],[Ship_To_Cust]
		,[Style_No],[Color],[Size],[Dest],[Qty],[Dlv_Dt],[PSD_Dt],[LPD_Dt],[Sold_To_Cust],[Bill_To_Cust],[Ship_Mode],[Garm_Qty],[CM_Price]
		,[Act_Qty],[Priority],[CONo],[POD_Dt],[Remarks],[Webbing],[Created_By],[Time_Created],RS_Dt,VSL_Dt
		,Ex_Fty_Dt)  --,Sales_Ord_Type)

		SELECT io_det.sbu_id,mhd.mo_id, mhd.MONo, dbo.IO_Det.Item_No, dbo.IO_Det.CPO_No, dbo.IO_Det.CPO_Item, dbo.IO_Det.CPO_Dt, dbo.IO_Det.Cust_Style, dbo.IO_Det.Cust_Desc, dbo.IO_Det.Cust_Color, 
				dbo.IO_Det.Cust_Size, dbo.IO_Det.Cust_Dest, dbo.IO_Det.Ship_To_Cust, dbo.IO_Det.Style_No, dbo.IO_Det.Color, dbo.IO_Det.Size, dbo.IO_Det.Dest, dbo.IO_Det.Qty, 
				dbo.IO_Det.Dlv_Dt, dbo.IO_Det.PSD_Dt, dbo.IO_Det.LPD_Dt, dbo.IO_Det.Sold_To_Cust, dbo.IO_Det.Bill_To_Cust, dbo.IO_Det.Ship_Mode, isnull(dbo.IO_Det.Garm_Qty,1), dbo.IO_Det.CM_Price, 
				dbo.IO_Det.Act_Qty, 0 AS Priority, dbo.IO_Det.CONo, dbo.IO_Det.POD_Dt, dbo.IO_Det.Remarks, dbo.IO_Det.Webbing
				, @UserId AS CreatedBy, getdate() AS CreatedDt, dbo.IO_Det.RS_Dt, dbo.IO_Det.VSL_Dt,
				dbo.IO_Det.Ex_Fty_Dt--, dbo.IO_Det.Sales_Ord_Type
		FROM dbo.IO_Det 
			INNER JOIN
				dbo.IO_Hdr ON dbo.IO_Det.IONo = dbo.IO_Hdr.IONo 
			INNER JOIN
				(
				Select min(h.MONo) as MONo, h.IONo, h.Ref_Auto_Create_MO as Dlv_Dt from dbo.MO_Hdr h left outer join dbo.MO_Det d on h.MONo = d.MONo 
				Where d.MONo is null
				--and h.LevelNo = 1
				and h.IONo in (Select IONo from #IOs)
				Group By h.IONo, h.Ref_Auto_Create_MO
				) mhd ON dbo.IO_Hdr.IONo = mhd.IONo AND dbo.IO_Det.Dlv_Dt = mhd.Dlv_Dt 
			LEFT OUTER JOIN
				(SELECT DISTINCT Item_No FROM dbo.MO_Det) AS mod ON dbo.IO_Det.Item_No = mod.Item_No
		WHERE 
		dbo.IO_Det.IONo in (Select IONo from #IOs)
		AND (mod.Item_No IS NULL) 
		AND dbo.IO_Det.Qty > 0

		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByDelDt - Insert MO Details to Existing MO.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MO_Det]
		([sbu_id],[MO_id],[mono],[Item_No],[CPO_No],[CPO_Item],[CPO_Dt],[Cust_Style],[Cust_Desc],[Cust_Color],[Cust_Size],[Cust_Dest],[Ship_To_Cust]
		,[Style_No],[Color],[Size],[Dest],[Qty],[Dlv_Dt],[PSD_Dt],[LPD_Dt],[Sold_To_Cust],[Bill_To_Cust],[Ship_Mode],[Garm_Qty],[CM_Price]
		,[Act_Qty],[Priority],[CONo],[POD_Dt],[Remarks],[Webbing],[Created_By],[Time_Created],RS_Dt,VSL_Dt
		,Ex_Fty_Dt)  --,Sales_Ord_Type)
		SELECT io_det.sbu_id,mhd.mo_id, mhd.MONo, dbo.IO_Det.Item_No, dbo.IO_Det.CPO_No, dbo.IO_Det.CPO_Item, dbo.IO_Det.CPO_Dt, dbo.IO_Det.Cust_Style, dbo.IO_Det.Cust_Desc, dbo.IO_Det.Cust_Color, 
				dbo.IO_Det.Cust_Size, dbo.IO_Det.Cust_Dest, dbo.IO_Det.Ship_To_Cust, dbo.IO_Det.Style_No, dbo.IO_Det.Color, dbo.IO_Det.Size, dbo.IO_Det.Dest, dbo.IO_Det.Qty, 
				dbo.IO_Det.Dlv_Dt, dbo.IO_Det.PSD_Dt, dbo.IO_Det.LPD_Dt, dbo.IO_Det.Sold_To_Cust, dbo.IO_Det.Bill_To_Cust, dbo.IO_Det.Ship_Mode, isnull(dbo.IO_Det.Garm_Qty,1), dbo.IO_Det.CM_Price, 
				dbo.IO_Det.Act_Qty, 0 AS Priority, dbo.IO_Det.CONo, dbo.IO_Det.POD_Dt, dbo.IO_Det.Remarks, dbo.IO_Det.Webbing
				, @UserId AS CreatedBy, getdate() AS CreatedDt, dbo.IO_Det.RS_Dt, dbo.IO_Det.VSL_Dt,
				dbo.IO_Det.Ex_Fty_Dt--, dbo.IO_Det.Sales_Ord_Type
		FROM dbo.IO_Det 
			INNER JOIN
				dbo.IO_Hdr ON dbo.IO_Det.IONo = dbo.IO_Hdr.IONo 
			INNER JOIN
				(
				Select min(h.MONo) as MONo, h.IONo, d.PODDT as Dlv_Dt from dbo.MO_Hdr h inner join dbo.MO_Det d on h.MONo = d.MONo 
				Where --h.LevelNo = 1 and 
				h.IONo in (Select IONo from #IOs) 
				and d.Qty > 0
				Group By h.IONo, d.POD_DT) mhd 
				ON dbo.IO_Hdr.IONo = mhd.IONo AND dbo.IO_Det.DlvDt = mhd.Dlv_Dt 
			LEFT OUTER JOIN
				(SELECT DISTINCT ItemNo FROM dbo.MO_Det) AS mod ON dbo.IO_Det.Item_No = mod.Item_No
		WHERE 
		dbo.IO_Det.IONo in (Select IONo from #IOs)
		and (mod.Item_No IS NULL) 
		and dbo.IO_Det.Qty > 0

		--Update MOHdr ExFtyDt
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByDelDt - Update ExFtyDt.', TimeFinish = getdate() Where RecId = @RecId
		Update MO_Hdr Set Rev_Ex_Fty_Dt = isnull(d.Ex_Fty_Dt,Rev_Ex_Fty_Dt)
		from MO_Hdr h 
		Outer apply (Select min(Ex_Fty_Dt) as Ex_Fty_Dt from MO_Det with (nolock) Where MONo = h.MONo and Qty > 0) d
		Where IONo in (Select IONo from #IOs) 
/* remarks by donel table not existing
		--Insert MOColor
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByDelDt - Insert MO Colors.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MO_Color]
				   ([MONo]
				   ,[Color]
				   ,[Color_Desc])
		SELECT dbo.MODet.MONo, dbo.IODet.Color, max(dbo.IODet.ColorDesc) as ColorDesc
		FROM dbo.IOHdr 
			INNER JOIN
				#IOs i ON dbo.IOHdr.IONo = i.IONo
			INNER JOIN 
				dbo.IODet ON dbo.IOHdr.IONo = dbo.IODet.IONo 
			INNER JOIN
				dbo.MODet ON dbo.IODet.ItemNo = dbo.MODet.ItemNo 
			LEFT OUTER JOIN
				dbo.MOColor ON dbo.MODet.MONo = dbo.MOColor.MONo AND dbo.IODet.Color = dbo.MOColor.Color
		WHERE 
			(dbo.MOColor.Color IS NULL) 
			and dbo.IODet.Qty > 0 
		GROUP BY dbo.MODet.MONo, dbo.IODet.Color
*/
		--Delete Duplicate MODetPriority
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByDelDt - Delete MO Detail Priorities with discrepancy.', TimeFinish = getdate() Where RecId = @RecId
		Delete from MO_Det_Priority Where MONo in (select distinct mp.MONo from 
													(Select MONo, CONo, min(Dlv_Dt) as Dlv_Dt from MO_Det 
														where Qty > 0 group by MONo, CONo) md 
													inner join MO_Det_Priority mp 
													on md.MONo = mp.MONo 
													and md.CONo = mp.CONo 
													and md.Dlv_Dt <> mp.Dlv_Dt)
								AND MONo in (Select MONo from MO_Hdr Where IONo in (Select IONo from #IOs))		

		--Insert MODetPriority
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByDelDt - Insert MO Detail Priorities.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MO_Det_Priority]
				   ([sbu_id],[MONo],[mo_id]
				   ,[CONo]
				   ,[Dlv_Dt]
				   ,[Priority]
				   ,[Created_By]
				   ,[Created_Dt])
		Select sbu_id,MONo,MO_id, CONo, Dlv_Dt, row_number() over (partition by MONo order by MONo) + isnull(MaxPriority,0) AS COPriority, @UserId, getdate()
		from 
			(
			SELECT DISTINCT dbo.MO_Det.sbu_id,dbo.MO_Det.MONo,dbo.MO_Det.MO_id, dbo.MO_Det.CONo, dbo.MO_Det.Dlv_Dt, isnull(x.MaxPriority, 0) AS MaxPriority
			FROM            dbo.MO_Det LEFT OUTER JOIN
									 dbo.MO_Det_Priority ON dbo.MO_Det.MONo = dbo.MO_Det_Priority.MONo AND dbo.MO_Det.CONo = dbo.MO_Det_Priority.CONo
									 LEFT OUTER JOIN (Select MONo, Max(Priority) as MaxPriority from MO_Det_Priority group by MONo) x on MO_Det.MONo = x.MONo
			WHERE        (dbo.MO_Det_Priority.CONo IS NULL) AND dbo.MO_Det.Dlv_Dt is not null and dbo.MO_Det.Qty > 0
			AND dbo.MO_Det.MONo in (Select MONo from MO_Hdr Where IONo in (Select IONo from #IOs))
			) modPriority


		--Insert MOEvents
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByDelDt - Insert MO Events/Critical Path.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MO_Events]
				   ([MONO]  
				   --,[Rec_Id]
				   ,[Event_Seq]
				   ,[Key_Event]
				   ,[Req_Duration]
				   ,[Responsible]
				   ,[VAP]  
				   ,[Remarks]
				   --,[Deleted]
				   ,[Predecessor]
				   ,[Successor]
				   ,[Created_By]
				   ,[Time_Created]
				   ,[Level_No]
				   ,[Pass_Type]
				   ,[Seq_No]
				   ,[Orig_Req_Duration]
				   ,[Active])
		SELECT h.MONo--, newid()
				, e.EventSeq, e.KeyEvent, e.ReqDuration, e.Responsible, e.VAP, e.Remarks
					--,e.Deleted
					, e.Predecessor, e.Successor, @UserId as CreatedBy, getdate() as CreatedDt
					,e.LevelNo, e.PassType, e.SeqNo, e.ReqDuration, e.Active
		FROM dbo.MO_Hdr AS h CROSS JOIN dbo.[View_Event] AS e 
		WHERE (h.MONo IN (
						  SELECT distinct h.MONo 
						  FROM dbo.MO_Hdr AS h LEFT OUTER JOIN dbo.MO_Events AS e ON h.MONo = e.MONo
						  inner join IO_Hdr ih on h.Iono = ih.IONo
						  WHERE (e.MONo IS NULL)
						  and ih.IONo in (Select distinct IONo from IO_Det Where Qty > 0 and IONo in (Select IONo from #IOs))
						  )
				)
		and h.Mfg_Loc in (Select Mfg_Loc from m_Mfg_Locs Where Local = 1)


		--Insert MOSpsMachine
		--Update dbo.SyncLog set Remarks = 'ordSyncMO_ByDelDt - Update MOEvents PO RS/RF.', TimeFinish = getdate() Where RecId = @RecId
		--Exec dbo.ordUpdateMOEventsPODD @Userid


		--Insert MOSpsMachine
		--Update dbo.SyncLog set Remarks = 'ordSyncMO_ByDelDt - Insert MO Special Machines.', TimeFinish = getdate() Where RecId = @RecId
		--INSERT INTO [dbo].[MOSpsMachine]
		--		   ([MONo]
		--		   ,[SpsMachineCd]
		--		   ,[SMV])
		--SELECT h.MONo, m.SpsMachineCd, m.SMV
		--FROM dbo.MOHdr AS h INNER JOIN dbo.StyleMachine AS m ON h.StyleNo = m.StyleNo
		--WHERE (h.MONo IN (
		--				  SELECT distinct h.MONo 
		--				  FROM dbo.MOHdr AS h LEFT OUTER JOIN dbo.MOSpsMachine AS e ON h.MONo = e.MONo
		--				  WHERE (e.MONo IS NULL))
		--				  )
		--AND h.MONo in (Select MONo from MOHdr Where IONo in (Select IONo from IOHdr Where CusGrp = 'SKE'))
		--and h.MONo in (Select distinct MONo from MODet Where Qty > 0)


		--Insert MOVAPSVAP
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByDelDt - Insert MO Checkpoints.', TimeFinish = getdate() Where RecId = @RecId
		INSERT INTO [dbo].[MOVAPSVAP]
				   ([sbu_id],[MONo],[mo_id]
				   ,[Seq]
				   ,[VAP]
				   ,[SVAP]
				   ,[GVAP]
				   ,[VAP_id]
				   ,[SVAP_id]
				   ,[GVAP_id]
				   --,[WBT]
				   --,[Lean]
				   --,[WPT]
				   ,[Load_On]
				   ,[Load_Off]
				   ,[Reqd]
				   --,[Subcon]
				   ,[Seq2]
				   ,[Active]
				   --,[Simultaneous]
				   ,[Created_By]
				   ,[Time_Created]
				   --,[Output_VAP]
				   --,[Output_SVAP]
				   )		
		SELECT h.sbu_id,
		h.MONo,h.id, v.Seq, v.VAP, v.SVAP, v.GVAP--, v.WBT, v.Lean, v.WPT
		, v.VAP_id, v.SVAP_id, v.GVAP_id
		, v.LoadOn, v.LoadOff, v.Reqd--, v.Subcon
		, v.Seq2, v.Active--, v.Simultaneous, 
				,@UserId, getdate()--, v.OutputVAP, v.OutputSVAP

		FROM dbo.MO_Hdr AS h 
		--INNER JOIN  VAPSVAPTemplateStyle AS i ON h.StyleNo = i.Style 
		--	AND EffDt  = (SELECT TOP 1 EffDt FROM  VAPSVAPTemplateStyle WHERE Style = h.StyleNo AND EffDt <= GETDATE() ORDER BY EFFDT DESC)
		INNER JOIN dbo.VAPSVAP_Template_Det AS v ON @CheckpointTemplate = v.Template_ID
		WHERE (h.MONo IN (
						  SELECT distinct h.MONo 
						  FROM dbo.MO_Hdr AS h LEFT OUTER JOIN dbo.MO_VAP_SVAP AS e ON h.MONo = e.MONo
						  WHERE (e.MONo IS NULL))
						  )
		AND h.MONo in (Select MONo from MO_Hdr Where IONo in (Select IONo from #IOs))
		and h.MONo in (Select distinct MONo from MO_Det Where Qty > 0)

		--Insert MOGVAP
		Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByDelDt - Insert MO GVAP.', TimeFinish = getdate() Where RecId = @RecId
		DECLARE @Cnt AS int
		DECLARE @RowNo AS int
		DECLARE @MONo AS varchar(20)

		SELECT row_number() over (order by h.MONo) As RowNo, h.MONo INTO #MONo
		FROM dbo.MO_Hdr AS h LEFT OUTER JOIN dbo.MO_GVAP AS g ON h.MONo = g.MONo
		WHERE (g.MONo IS NULL)
		AND h.MONo in (Select MONo from MO_Hdr Where IONo in (Select IONo from #IOs))
		and h.MONo in (Select distinct MONo from MO_Det Where Qty > 0)


		Select @Cnt = count(1) from #MONo
		Set @RowNo = 1

		If @cnt > 0
		BEGIN
			WHILE @Cnt >= @RowNo --1 >= 2
			BEGIN
				Select @MONo = MONo from #MONo Where RowNo = @RowNo
				/*
				EXEC ordCreateMOGVAP @MONo
				EXEC ordUpdateDiffMO_CPMO @MONo, @UserId
				EXEC ordUpdateMO_CP @MONo, @UserId
				*/
				Set @RowNo = @RowNo + 1

			END
		END
		
		drop table #IOs

	Update dbo.stg_SyncLog set Remarks = 'ordSyncMO_ByDelDt - Completed.', TimeFinish = getdate() Where RecId = @RecId
	
	END TRY
	
	BEGIN CATCH
		IF (@@TRANCOUNT > 0)
		--SELECT 1 AS ERROR_MSG
			--SELECT ERROR_MESSAGE() AS ERROR_MSG
			Update dbo.stg_SyncLog set Remarks = left('ordSyncMO_ByDelDt - ' + ERROR_MESSAGE(),2000), TimeFinish = getdate() Where Recid = @RecId
			--ROLLBACK TRANSACTION	
	END CATCH	
	
END


go

/*********************************************************************************************
Who Is Active? v11.17 (2016-10-18)
(C) 2007-2016, Adam Machanic

Feedback: mailto:amachanic@gmail.com
Updates: http://whoisactive.com

License: 
	Who is Active? is free to download and use for personal, educational, and internal 
	corporate purposes, provided that this header is preserved. Redistribution or sale 
	of Who is Active?, in whole or in part, is prohibited without the author's express 
	written consent.
*********************************************************************************************/
CREATE PROCEDURE dbo.sp_WhoIsActive
(
--~
	--Filters--Both inclusive and exclusive
	--Set either filter to '' to disable
	--Valid filter types are: session, program, database, login, and host
	--Session is a session ID, and either 0 or '' can be used to indicate "all" sessions
	--All other filter types support % or _ as wildcards
	@filter sysname = '',
	@filter_type VARCHAR(10) = 'session',
	@not_filter sysname = '',
	@not_filter_type VARCHAR(10) = 'session',

	--Retrieve data about the calling session?
	@show_own_spid BIT = 0,

	--Retrieve data about system sessions?
	@show_system_spids BIT = 0,

	--Controls how sleeping SPIDs are handled, based on the idea of levels of interest
	--0 does not pull any sleeping SPIDs
	--1 pulls only those sleeping SPIDs that also have an open transaction
	--2 pulls all sleeping SPIDs
	@show_sleeping_spids TINYINT = 1,

	--If 1, gets the full stored procedure or running batch, when available
	--If 0, gets only the actual statement that is currently running in the batch or procedure
	@get_full_inner_text BIT = 0,

	--Get associated query plans for running tasks, if available
	--If @get_plans = 1, gets the plan based on the request's statement offset
	--If @get_plans = 2, gets the entire plan based on the request's plan_handle
	@get_plans TINYINT = 0,

	--Get the associated outer ad hoc query or stored procedure call, if available
	@get_outer_command BIT = 0,

	--Enables pulling transaction log write info and transaction duration
	@get_transaction_info BIT = 0,

	--Get information on active tasks, based on three interest levels
	--Level 0 does not pull any task-related information
	--Level 1 is a lightweight mode that pulls the top non-CXPACKET wait, giving preference to blockers
	--Level 2 pulls all available task-based metrics, including: 
	--number of active tasks, current wait stats, physical I/O, context switches, and blocker information
	@get_task_info TINYINT = 1,

	--Gets associated locks for each request, aggregated in an XML format
	@get_locks BIT = 0,

	--Get average time for past runs of an active query
	--(based on the combination of plan handle, sql handle, and offset)
	@get_avg_time BIT = 0,

	--Get additional non-performance-related information about the session or request
	--text_size, language, date_format, date_first, quoted_identifier, arithabort, ansi_null_dflt_on, 
	--ansi_defaults, ansi_warnings, ansi_padding, ansi_nulls, concat_null_yields_null, 
	--transaction_isolation_level, lock_timeout, deadlock_priority, row_count, command_type
	--
	--If a SQL Agent job is running, an subnode called agent_info will be populated with some or all of
	--the following: job_id, job_name, step_id, step_name, msdb_query_error (in the event of an error)
	--
	--If @get_task_info is set to 2 and a lock wait is detected, a subnode called block_info will be
	--populated with some or all of the following: lock_type, database_name, object_id, file_id, hobt_id, 
	--applock_hash, metadata_resource, metadata_class_id, object_name, schema_name
	@get_additional_info BIT = 0,

	--Walk the blocking chain and count the number of 
	--total SPIDs blocked all the way down by a given session
	--Also enables task_info Level 1, if @get_task_info is set to 0
	@find_block_leaders BIT = 0,

	--Pull deltas on various metrics
	--Interval in seconds to wait before doing the second data pull
	@delta_interval TINYINT = 0,

	--List of desired output columns, in desired order
	--Note that the final output will be the intersection of all enabled features and all 
	--columns in the list. Therefore, only columns associated with enabled features will 
	--actually appear in the output. Likewise, removing columns from this list may effectively
	--disable features, even if they are turned on
	--
	--Each element in this list must be one of the valid output column names. Names must be
	--delimited by square brackets. White space, formatting, and additional characters are
	--allowed, as long as the list contains exact matches of delimited valid column names.
	@output_column_list VARCHAR(8000) = '[dd%][session_id][sql_text][sql_command][login_name][wait_info][tasks][tran_log%][cpu%][temp%][block%][reads%][writes%][context%][physical%][query_plan][locks][%]',

	--Column(s) by which to sort output, optionally with sort directions. 
		--Valid column choices:
		--session_id, physical_io, reads, physical_reads, writes, tempdb_allocations,
		--tempdb_current, CPU, context_switches, used_memory, physical_io_delta, 
		--reads_delta, physical_reads_delta, writes_delta, tempdb_allocations_delta, 
		--tempdb_current_delta, CPU_delta, context_switches_delta, used_memory_delta, 
		--tasks, tran_start_time, open_tran_count, blocking_session_id, blocked_session_count,
		--percent_complete, host_name, login_name, database_name, start_time, login_time
		--
		--Note that column names in the list must be bracket-delimited. Commas and/or white
		--space are not required. 
	@sort_order VARCHAR(500) = '[start_time] ASC',

	--Formats some of the output columns in a more "human readable" form
	--0 disables outfput format
	--1 formats the output for variable-width fonts
	--2 formats the output for fixed-width fonts
	@format_output TINYINT = 1,

	--If set to a non-blank value, the script will attempt to insert into the specified 
	--destination table. Please note that the script will not verify that the table exists, 
	--or that it has the correct schema, before doing the insert.
	--Table can be specified in one, two, or three-part format
	@destination_table VARCHAR(4000) = '',

	--If set to 1, no data collection will happen and no result set will be returned; instead,
	--a CREATE TABLE statement will be returned via the @schema parameter, which will match 
	--the schema of the result set that would be returned by using the same collection of the
	--rest of the parameters. The CREATE TABLE statement will have a placeholder token of 
	--<table_name> in place of an actual table name.
	@return_schema BIT = 0,
	@schema VARCHAR(MAX) = NULL OUTPUT,

	--Help! What do I do?
	@help BIT = 0
--~
)
/*
OUTPUT COLUMNS
--------------
Formatted/Non:	[session_id] [smallint] NOT NULL
	Session ID (a.k.a. SPID)

Formatted:		[dd hh:mm:ss.mss] [varchar](15) NULL
Non-Formatted:	<not returned>
	For an active request, time the query has been running
	For a sleeping session, time since the last batch completed

Formatted:		[dd hh:mm:ss.mss (avg)] [varchar](15) NULL
Non-Formatted:	[avg_elapsed_time] [int] NULL
	(Requires @get_avg_time option)
	How much time has the active portion of the query taken in the past, on average?

Formatted:		[physical_io] [varchar](30) NULL
Non-Formatted:	[physical_io] [bigint] NULL
	Shows the number of physical I/Os, for active requests

Formatted:		[reads] [varchar](30) NULL
Non-Formatted:	[reads] [bigint] NULL
	For an active request, number of reads done for the current query
	For a sleeping session, total number of reads done over the lifetime of the session

Formatted:		[physical_reads] [varchar](30) NULL
Non-Formatted:	[physical_reads] [bigint] NULL
	For an active request, number of physical reads done for the current query
	For a sleeping session, total number of physical reads done over the lifetime of the session

Formatted:		[writes] [varchar](30) NULL
Non-Formatted:	[writes] [bigint] NULL
	For an active request, number of writes done for the current query
	For a sleeping session, total number of writes done over the lifetime of the session

Formatted:		[tempdb_allocations] [varchar](30) NULL
Non-Formatted:	[tempdb_allocations] [bigint] NULL
	For an active request, number of TempDB writes done for the current query
	For a sleeping session, total number of TempDB writes done over the lifetime of the session

Formatted:		[tempdb_current] [varchar](30) NULL
Non-Formatted:	[tempdb_current] [bigint] NULL
	For an active request, number of TempDB pages currently allocated for the query
	For a sleeping session, number of TempDB pages currently allocated for the session

Formatted:		[CPU] [varchar](30) NULL
Non-Formatted:	[CPU] [int] NULL
	For an active request, total CPU time consumed by the current query
	For a sleeping session, total CPU time consumed over the lifetime of the session

Formatted:		[context_switches] [varchar](30) NULL
Non-Formatted:	[context_switches] [bigint] NULL
	Shows the number of context switches, for active requests

Formatted:		[used_memory] [varchar](30) NOT NULL
Non-Formatted:	[used_memory] [bigint] NOT NULL
	For an active request, total memory consumption for the current query
	For a sleeping session, total current memory consumption

Formatted:		[physical_io_delta] [varchar](30) NULL
Non-Formatted:	[physical_io_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of physical I/Os reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[reads_delta] [varchar](30) NULL
Non-Formatted:	[reads_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of reads reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[physical_reads_delta] [varchar](30) NULL
Non-Formatted:	[physical_reads_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of physical reads reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[writes_delta] [varchar](30) NULL
Non-Formatted:	[writes_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of writes reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[tempdb_allocations_delta] [varchar](30) NULL
Non-Formatted:	[tempdb_allocations_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of TempDB writes reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[tempdb_current_delta] [varchar](30) NULL
Non-Formatted:	[tempdb_current_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the number of allocated TempDB pages reported on the first and second 
	collections. If the request started after the first collection, the value will be NULL

Formatted:		[CPU_delta] [varchar](30) NULL
Non-Formatted:	[CPU_delta] [int] NULL
	(Requires @delta_interval option)
	Difference between the CPU time reported on the first and second collections. 
	If the request started after the first collection, the value will be NULL

Formatted:		[context_switches_delta] [varchar](30) NULL
Non-Formatted:	[context_switches_delta] [bigint] NULL
	(Requires @delta_interval option)
	Difference between the context switches count reported on the first and second collections
	If the request started after the first collection, the value will be NULL

Formatted:		[used_memory_delta] [varchar](30) NULL
Non-Formatted:	[used_memory_delta] [bigint] NULL
	Difference between the memory usage reported on the first and second collections
	If the request started after the first collection, the value will be NULL

Formatted:		[tasks] [varchar](30) NULL
Non-Formatted:	[tasks] [smallint] NULL
	Number of worker tasks currently allocated, for active requests

Formatted/Non:	[status] [varchar](30) NOT NULL
	Activity status for the session (running, sleeping, etc)

Formatted/Non:	[wait_info] [nvarchar](4000) NULL
	Aggregates wait information, in the following format:
		(Ax: Bms/Cms/Dms)E
	A is the number of waiting tasks currently waiting on resource type E. B/C/D are wait
	times, in milliseconds. If only one thread is waiting, its wait time will be shown as B.
	If two tasks are waiting, each of their wait times will be shown (B/C). If three or more 
	tasks are waiting, the minimum, average, and maximum wait times will be shown (B/C/D).
	If wait type E is a page latch wait and the page is of a "special" type (e.g. PFS, GAM, SGAM), 
	the page type will be identified.
	If wait type E is CXPACKET, the nodeId from the query plan will be identified

Formatted/Non:	[locks] [xml] NULL
	(Requires @get_locks option)
	Aggregates lock information, in XML format.
	The lock XML includes the lock mode, locked object, and aggregates the number of requests. 
	Attempts are made to identify locked objects by name

Formatted/Non:	[tran_start_time] [datetime] NULL
	(Requires @get_transaction_info option)
	Date and time that the first transaction opened by a session caused a transaction log 
	write to occur.

Formatted/Non:	[tran_log_writes] [nvarchar](4000) NULL
	(Requires @get_transaction_info option)
	Aggregates transaction log write information, in the following format:
	A:wB (C kB)
	A is a database that has been touched by an active transaction
	B is the number of log writes that have been made in the database as a result of the transaction
	C is the number of log kilobytes consumed by the log records

Formatted:		[open_tran_count] [varchar](30) NULL
Non-Formatted:	[open_tran_count] [smallint] NULL
	Shows the number of open transactions the session has open

Formatted:		[sql_command] [xml] NULL
Non-Formatted:	[sql_command] [nvarchar](max) NULL
	(Requires @get_outer_command option)
	Shows the "outer" SQL command, i.e. the text of the batch or RPC sent to the server, 
	if available

Formatted:		[sql_text] [xml] NULL
Non-Formatted:	[sql_text] [nvarchar](max) NULL
	Shows the SQL text for active requests or the last statement executed
	for sleeping sessions, if available in either case.
	If @get_full_inner_text option is set, shows the full text of the batch.
	Otherwise, shows only the active statement within the batch.
	If the query text is locked, a special timeout message will be sent, in the following format:
		<timeout_exceeded />
	If an error occurs, an error message will be sent, in the following format:
		<error message="message" />

Formatted/Non:	[query_plan] [xml] NULL
	(Requires @get_plans option)
	Shows the query plan for the request, if available.
	If the plan is locked, a special timeout message will be sent, in the following format:
		<timeout_exceeded />
	If an error occurs, an error message will be sent, in the following format:
		<error message="message" />

Formatted/Non:	[blocking_session_id] [smallint] NULL
	When applicable, shows the blocking SPID

Formatted:		[blocked_session_count] [varchar](30) NULL
Non-Formatted:	[blocked_session_count] [smallint] NULL
	(Requires @find_block_leaders option)
	The total number of SPIDs blocked by this session,
	all the way down the blocking chain.

Formatted:		[percent_complete] [varchar](30) NULL
Non-Formatted:	[percent_complete] [real] NULL
	When applicable, shows the percent complete (e.g. for backups, restores, and some rollbacks)

Formatted/Non:	[host_name] [sysname] NOT NULL
	Shows the host name for the connection

Formatted/Non:	[login_name] [sysname] NOT NULL
	Shows the login name for the connection

Formatted/Non:	[database_name] [sysname] NULL
	Shows the connected database

Formatted/Non:	[program_name] [sysname] NULL
	Shows the reported program/application name

Formatted/Non:	[additional_info] [xml] NULL
	(Requires @get_additional_info option)
	Returns additional non-performance-related session/request information
	If the script finds a SQL Agent job running, the name of the job and job step will be reported
	If @get_task_info = 2 and the script finds a lock wait, the locked object will be reported

Formatted/Non:	[start_time] [datetime] NOT NULL
	For active requests, shows the time the request started
	For sleeping sessions, shows the time the last batch completed

Formatted/Non:	[login_time] [datetime] NOT NULL
	Shows the time that the session connected

Formatted/Non:	[request_id] [int] NULL
	For active requests, shows the request_id
	Should be 0 unless MARS is being used

Formatted/Non:	[collection_time] [datetime] NOT NULL
	Time that this script's final SELECT ran
*/
AS
BEGIN;
	SET NOCOUNT ON; 
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET QUOTED_IDENTIFIER ON;
	SET ANSI_PADDING ON;
	SET CONCAT_NULL_YIELDS_NULL ON;
	SET ANSI_WARNINGS ON;
	SET NUMERIC_ROUNDABORT OFF;
	SET ARITHABORT ON;

	IF
		@filter IS NULL
		OR @filter_type IS NULL
		OR @not_filter IS NULL
		OR @not_filter_type IS NULL
		OR @show_own_spid IS NULL
		OR @show_system_spids IS NULL
		OR @show_sleeping_spids IS NULL
		OR @get_full_inner_text IS NULL
		OR @get_plans IS NULL
		OR @get_outer_command IS NULL
		OR @get_transaction_info IS NULL
		OR @get_task_info IS NULL
		OR @get_locks IS NULL
		OR @get_avg_time IS NULL
		OR @get_additional_info IS NULL
		OR @find_block_leaders IS NULL
		OR @delta_interval IS NULL
		OR @format_output IS NULL
		OR @output_column_list IS NULL
		OR @sort_order IS NULL
		OR @return_schema IS NULL
		OR @destination_table IS NULL
		OR @help IS NULL
	BEGIN;
		RAISERROR('Input parameters cannot be NULL', 16, 1);
		RETURN;
	END;
	
	IF @filter_type NOT IN ('session', 'program', 'database', 'login', 'host')
	BEGIN;
		RAISERROR('Valid filter types are: session, program, database, login, host', 16, 1);
		RETURN;
	END;
	
	IF @filter_type = 'session' AND @filter LIKE '%[^0123456789]%'
	BEGIN;
		RAISERROR('Session filters must be valid integers', 16, 1);
		RETURN;
	END;
	
	IF @not_filter_type NOT IN ('session', 'program', 'database', 'login', 'host')
	BEGIN;
		RAISERROR('Valid filter types are: session, program, database, login, host', 16, 1);
		RETURN;
	END;
	
	IF @not_filter_type = 'session' AND @not_filter LIKE '%[^0123456789]%'
	BEGIN;
		RAISERROR('Session filters must be valid integers', 16, 1);
		RETURN;
	END;
	
	IF @show_sleeping_spids NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @show_sleeping_spids are: 0, 1, or 2', 16, 1);
		RETURN;
	END;
	
	IF @get_plans NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @get_plans are: 0, 1, or 2', 16, 1);
		RETURN;
	END;

	IF @get_task_info NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @get_task_info are: 0, 1, or 2', 16, 1);
		RETURN;
	END;

	IF @format_output NOT IN (0, 1, 2)
	BEGIN;
		RAISERROR('Valid values for @format_output are: 0, 1, or 2', 16, 1);
		RETURN;
	END;
	
	IF @help = 1
	BEGIN;
		DECLARE 
			@header VARCHAR(MAX),
			@params VARCHAR(MAX),
			@outputs VARCHAR(MAX);

		SELECT 
			@header =
				REPLACE
				(
					REPLACE
					(
						CONVERT
						(
							VARCHAR(MAX),
							SUBSTRING
							(
								t.text, 
								CHARINDEX('/' + REPLICATE('*', 93), t.text) + 94,
								CHARINDEX(REPLICATE('*', 93) + '/', t.text) - (CHARINDEX('/' + REPLICATE('*', 93), t.text) + 94)
							)
						),
						CHAR(13)+CHAR(10),
						CHAR(13)
					),
					'	',
					''
				),
			@params =
				CHAR(13) +
					REPLACE
					(
						REPLACE
						(
							CONVERT
							(
								VARCHAR(MAX),
								SUBSTRING
								(
									t.text, 
									CHARINDEX('--~', t.text) + 5, 
									CHARINDEX('--~', t.text, CHARINDEX('--~', t.text) + 5) - (CHARINDEX('--~', t.text) + 5)
								)
							),
							CHAR(13)+CHAR(10),
							CHAR(13)
						),
						'	',
						''
					),
				@outputs = 
					CHAR(13) +
						REPLACE
						(
							REPLACE
							(
								REPLACE
								(
									CONVERT
									(
										VARCHAR(MAX),
										SUBSTRING
										(
											t.text, 
											CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32,
											CHARINDEX('*/', t.text, CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32) - (CHARINDEX('OUTPUT COLUMNS'+CHAR(13)+CHAR(10)+'--------------', t.text) + 32)
										)
									),
									CHAR(9),
									CHAR(255)
								),
								CHAR(13)+CHAR(10),
								CHAR(13)
							),
							'	',
							''
						) +
						CHAR(13)
		FROM sys.dm_exec_requests AS r
		CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS t
		WHERE
			r.session_id = @@SPID;

		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@header) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		)
		SELECT
			RTRIM(LTRIM(
				SUBSTRING
				(
					@header,
					number + 1,
					CHARINDEX(CHAR(13), @header, number + 1) - number - 1
				)
			)) AS [------header---------------------------------------------------------------------------------------------------------------]
		FROM numbers
		WHERE
			SUBSTRING(@header, number, 1) = CHAR(13);

		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@params) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		),
		tokens AS
		(
			SELECT 
				RTRIM(LTRIM(
					SUBSTRING
					(
						@params,
						number + 1,
						CHARINDEX(CHAR(13), @params, number + 1) - number - 1
					)
				)) AS token,
				number,
				CASE
					WHEN SUBSTRING(@params, number + 1, 1) = CHAR(13) THEN number
					ELSE COALESCE(NULLIF(CHARINDEX(',' + CHAR(13) + CHAR(13), @params, number), 0), LEN(@params)) 
				END AS param_group,
				ROW_NUMBER() OVER
				(
					PARTITION BY
						CHARINDEX(',' + CHAR(13) + CHAR(13), @params, number),
						SUBSTRING(@params, number+1, 1)
					ORDER BY 
						number
				) AS group_order
			FROM numbers
			WHERE
				SUBSTRING(@params, number, 1) = CHAR(13)
		),
		parsed_tokens AS
		(
			SELECT
				MIN
				(
					CASE
						WHEN token LIKE '@%' THEN token
						ELSE NULL
					END
				) AS parameter,
				MIN
				(
					CASE
						WHEN token LIKE '--%' THEN RIGHT(token, LEN(token) - 2)
						ELSE NULL
					END
				) AS description,
				param_group,
				group_order
			FROM tokens
			WHERE
				NOT 
				(
					token = '' 
					AND group_order > 1
				)
			GROUP BY
				param_group,
				group_order
		)
		SELECT
			CASE
				WHEN description IS NULL AND parameter IS NULL THEN '-------------------------------------------------------------------------'
				WHEN param_group = MAX(param_group) OVER() THEN parameter
				ELSE COALESCE(LEFT(parameter, LEN(parameter) - 1), '')
			END AS [------parameter----------------------------------------------------------],
			CASE
				WHEN description IS NULL AND parameter IS NULL THEN '----------------------------------------------------------------------------------------------------------------------'
				ELSE COALESCE(description, '')
			END AS [------description-----------------------------------------------------------------------------------------------------]
		FROM parsed_tokens
		ORDER BY
			param_group, 
			group_order;
		
		WITH
		a0 AS
		(SELECT 1 AS n UNION ALL SELECT 1),
		a1 AS
		(SELECT 1 AS n FROM a0 AS a, a0 AS b),
		a2 AS
		(SELECT 1 AS n FROM a1 AS a, a1 AS b),
		a3 AS
		(SELECT 1 AS n FROM a2 AS a, a2 AS b),
		a4 AS
		(SELECT 1 AS n FROM a3 AS a, a3 AS b),
		numbers AS
		(
			SELECT TOP(LEN(@outputs) - 1)
				ROW_NUMBER() OVER
				(
					ORDER BY (SELECT NULL)
				) AS number
			FROM a4
			ORDER BY
				number
		),
		tokens AS
		(
			SELECT 
				RTRIM(LTRIM(
					SUBSTRING
					(
						@outputs,
						number + 1,
						CASE
							WHEN 
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) < 
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2, @outputs, number + 1), 0), LEN(@outputs))
								THEN COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) - number - 1
							ELSE
								COALESCE(NULLIF(CHARINDEX(CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2, @outputs, number + 1), 0), LEN(@outputs)) - number - 1
						END
					)
				)) AS token,
				number,
				COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs)) AS output_group,
				ROW_NUMBER() OVER
				(
					PARTITION BY 
						COALESCE(NULLIF(CHARINDEX(CHAR(13) + 'Formatted', @outputs, number + 1), 0), LEN(@outputs))
					ORDER BY
						number
				) AS output_group_order
			FROM numbers
			WHERE
				SUBSTRING(@outputs, number, 10) = CHAR(13) + 'Formatted'
				OR SUBSTRING(@outputs, number, 2) = CHAR(13) + CHAR(255) COLLATE Latin1_General_Bin2
		),
		output_tokens AS
		(
			SELECT 
				*,
				CASE output_group_order
					WHEN 2 THEN MAX(CASE output_group_order WHEN 1 THEN token ELSE NULL END) OVER (PARTITION BY output_group)
					ELSE ''
				END COLLATE Latin1_General_Bin2 AS column_info
			FROM tokens
		)
		SELECT
			CASE output_group_order
				WHEN 1 THEN '-----------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN
							SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+1, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info))
						ELSE
							SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)+2) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info)-1)

					END
				ELSE ''
			END AS formatted_column_name,
			CASE output_group_order
				WHEN 1 THEN '-----------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN
							SUBSTRING(column_info, CHARINDEX(']', column_info)+2, LEN(column_info))
						ELSE
							SUBSTRING(column_info, CHARINDEX(']', column_info)+2, CHARINDEX('Non-Formatted:', column_info, CHARINDEX(']', column_info)+2) - CHARINDEX(']', column_info)-3)
					END
				ELSE ''
			END AS formatted_column_type,
			CASE output_group_order
				WHEN 1 THEN '---------------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN ''
						ELSE
							CASE
								WHEN SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, 1) = '<' THEN
									SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, CHARINDEX('>', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:'
, column_info))+1) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info)))
								ELSE
									SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, CHARINDEX(']', column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:'
, column_info))+1) - CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info)))
							END
					END
				ELSE ''
			END AS unformatted_column_name,
			CASE output_group_order
				WHEN 1 THEN '---------------------------------------'
				WHEN 2 THEN 
					CASE
						WHEN CHARINDEX('Formatted/Non:', column_info) = 1 THEN ''
						ELSE
							CASE
								WHEN SUBSTRING(column_info, CHARINDEX(CHAR(255) COLLATE Latin1_General_Bin2, column_info, CHARINDEX('Non-Formatted:', column_info))+1, 1) = '<' THEN ''
								ELSE
									SUBSTRING(column_info, CHARINDEX(']', column_info, CHARINDEX('Non-Formatted:', column_info))+2, CHARINDEX('Non-Formatted:', column_info, CHARINDEX(']', column_info)+2) - CHARINDEX(']', column_info)-3)
							END
					END
				ELSE ''
			END AS unformatted_column_type,
			CASE output_group_order
				WHEN 1 THEN '----------------------------------------------------------------------------------------------------------------------'
				ELSE REPLACE(token, CHAR(255) COLLATE Latin1_General_Bin2, '')
			END AS [------description-----------------------------------------------------------------------------------------------------]
		FROM output_tokens
		WHERE
			NOT 
			(
				output_group_order = 1 
				AND output_group = LEN(@outputs)
			)
		ORDER BY
			output_group,
			CASE output_group_order
				WHEN 1 THEN 99
				ELSE output_group_order
			END;

		RETURN;
	END;

	WITH
	a0 AS
	(SELECT 1 AS n UNION ALL SELECT 1),
	a1 AS
	(SELECT 1 AS n FROM a0 AS a, a0 AS b),
	a2 AS
	(SELECT 1 AS n FROM a1 AS a, a1 AS b),
	a3 AS
	(SELECT 1 AS n FROM a2 AS a, a2 AS b),
	a4 AS
	(SELECT 1 AS n FROM a3 AS a, a3 AS b),
	numbers AS
	(
		SELECT TOP(LEN(@output_column_list))
			ROW_NUMBER() OVER
			(
				ORDER BY (SELECT NULL)
			) AS number
		FROM a4
		ORDER BY
			number
	),
	tokens AS
	(
		SELECT 
			'|[' +
				SUBSTRING
				(
					@output_column_list,
					number + 1,
					CHARINDEX(']', @output_column_list, number) - number - 1
				) + '|]' AS token,
			number
		FROM numbers
		WHERE
			SUBSTRING(@output_column_list, number, 1) = '['
	),
	ordered_columns AS
	(
		SELECT
			x.column_name,
			ROW_NUMBER() OVER
			(
				PARTITION BY
					x.column_name
				ORDER BY
					tokens.number,
					x.default_order
			) AS r,
			ROW_NUMBER() OVER
			(
				ORDER BY
					tokens.number,
					x.default_order
			) AS s
		FROM tokens
		JOIN
		(
			SELECT '[session_id]' AS column_name, 1 AS default_order
			UNION ALL
			SELECT '[dd hh:mm:ss.mss]', 2
			WHERE
				@format_output IN (1, 2)
			UNION ALL
			SELECT '[dd hh:mm:ss.mss (avg)]', 3
			WHERE
				@format_output IN (1, 2)
				AND @get_avg_time = 1
			UNION ALL
			SELECT '[avg_elapsed_time]', 4
			WHERE
				@format_output = 0
				AND @get_avg_time = 1
			UNION ALL
			SELECT '[physical_io]', 5
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[reads]', 6
			UNION ALL
			SELECT '[physical_reads]', 7
			UNION ALL
			SELECT '[writes]', 8
			UNION ALL
			SELECT '[tempdb_allocations]', 9
			UNION ALL
			SELECT '[tempdb_current]', 10
			UNION ALL
			SELECT '[CPU]', 11
			UNION ALL
			SELECT '[context_switches]', 12
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[used_memory]', 13
			UNION ALL
			SELECT '[physical_io_delta]', 14
			WHERE
				@delta_interval > 0	
				AND @get_task_info = 2
			UNION ALL
			SELECT '[reads_delta]', 15
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[physical_reads_delta]', 16
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[writes_delta]', 17
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tempdb_allocations_delta]', 18
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tempdb_current_delta]', 19
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[CPU_delta]', 20
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[context_switches_delta]', 21
			WHERE
				@delta_interval > 0
				AND @get_task_info = 2
			UNION ALL
			SELECT '[used_memory_delta]', 22
			WHERE
				@delta_interval > 0
			UNION ALL
			SELECT '[tasks]', 23
			WHERE
				@get_task_info = 2
			UNION ALL
			SELECT '[status]', 24
			UNION ALL
			SELECT '[wait_info]', 25
			WHERE
				@get_task_info > 0
				OR @find_block_leaders = 1
			UNION ALL
			SELECT '[locks]', 26
			WHERE
				@get_locks = 1
			UNION ALL
			SELECT '[tran_start_time]', 27
			WHERE
				@get_transaction_info = 1
			UNION ALL
			SELECT '[tran_log_writes]', 28
			WHERE
				@get_transaction_info = 1
			UNION ALL
			SELECT '[open_tran_count]', 29
			UNION ALL
			SELECT '[sql_command]', 30
			WHERE
				@get_outer_command = 1
			UNION ALL
			SELECT '[sql_text]', 31
			UNION ALL
			SELECT '[query_plan]', 32
			WHERE
				@get_plans >= 1
			UNION ALL
			SELECT '[blocking_session_id]', 33
			WHERE
				@get_task_info > 0
				OR @find_block_leaders = 1
			UNION ALL
			SELECT '[blocked_session_count]', 34
			WHERE
				@find_block_leaders = 1
			UNION ALL
			SELECT '[percent_complete]', 35
			UNION ALL
			SELECT '[host_name]', 36
			UNION ALL
			SELECT '[login_name]', 37
			UNION ALL
			SELECT '[database_name]', 38
			UNION ALL
			SELECT '[program_name]', 39
			UNION ALL
			SELECT '[additional_info]', 40
			WHERE
				@get_additional_info = 1
			UNION ALL
			SELECT '[start_time]', 41
			UNION ALL
			SELECT '[login_time]', 42
			UNION ALL
			SELECT '[request_id]', 43
			UNION ALL
			SELECT '[collection_time]', 44
		) AS x ON 
			x.column_name LIKE token ESCAPE '|'
	)
	SELECT
		@output_column_list =
			STUFF
			(
				(
					SELECT
						',' + column_name as [text()]
					FROM ordered_columns
					WHERE
						r = 1
					ORDER BY
						s
					FOR XML
						PATH('')
				),
				1,
				1,
				''
			);
	
	IF COALESCE(RTRIM(@output_column_list), '') = ''
	BEGIN;
		RAISERROR('No valid column matches found in @output_column_list or no columns remain due to selected options.', 16, 1);
		RETURN;
	END;
	
	IF @destination_table <> ''
	BEGIN;
		SET @destination_table = 
			--database
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 3)) + '.', '') +
			--schema
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 2)) + '.', '') +
			--table
			COALESCE(QUOTENAME(PARSENAME(@destination_table, 1)), '');
			
		IF COALESCE(RTRIM(@destination_table), '') = ''
		BEGIN;
			RAISERROR('Destination table not properly formatted.', 16, 1);
			RETURN;
		END;
	END;

	WITH
	a0 AS
	(SELECT 1 AS n UNION ALL SELECT 1),
	a1 AS
	(SELECT 1 AS n FROM a0 AS a, a0 AS b),
	a2 AS
	(SELECT 1 AS n FROM a1 AS a, a1 AS b),
	a3 AS
	(SELECT 1 AS n FROM a2 AS a, a2 AS b),
	a4 AS
	(SELECT 1 AS n FROM a3 AS a, a3 AS b),
	numbers AS
	(
		SELECT TOP(LEN(@sort_order))
			ROW_NUMBER() OVER
			(
				ORDER BY (SELECT NULL)
			) AS number
		FROM a4
		ORDER BY
			number
	),
	tokens AS
	(
		SELECT 
			'|[' +
				SUBSTRING
				(
					@sort_order,
					number + 1,
					CHARINDEX(']', @sort_order, number) - number - 1
				) + '|]' AS token,
			SUBSTRING
			(
				@sort_order,
				CHARINDEX(']', @sort_order, number) + 1,
				COALESCE(NULLIF(CHARINDEX('[', @sort_order, CHARINDEX(']', @sort_order, number)), 0), LEN(@sort_order)) - CHARINDEX(']', @sort_order, number)
			) AS next_chunk,
			number
		FROM numbers
		WHERE
			SUBSTRING(@sort_order, number, 1) = '['
	),
	ordered_columns AS
	(
		SELECT
			x.column_name +
				CASE
					WHEN tokens.next_chunk LIKE '%asc%' THEN ' ASC'
					WHEN tokens.next_chunk LIKE '%desc%' THEN ' DESC'
					ELSE ''
				END AS column_name,
			ROW_NUMBER() OVER
			(
				PARTITION BY
					x.column_name
				ORDER BY
					tokens.number
			) AS r,
			tokens.number
		FROM tokens
		JOIN
		(
			SELECT '[session_id]' AS column_name
			UNION ALL
			SELECT '[physical_io]'
			UNION ALL
			SELECT '[reads]'
			UNION ALL
			SELECT '[physical_reads]'
			UNION ALL
			SELECT '[writes]'
			UNION ALL
			SELECT '[tempdb_allocations]'
			UNION ALL
			SELECT '[tempdb_current]'
			UNION ALL
			SELECT '[CPU]'
			UNION ALL
			SELECT '[context_switches]'
			UNION ALL
			SELECT '[used_memory]'
			UNION ALL
			SELECT '[physical_io_delta]'
			UNION ALL
			SELECT '[reads_delta]'
			UNION ALL
			SELECT '[physical_reads_delta]'
			UNION ALL
			SELECT '[writes_delta]'
			UNION ALL
			SELECT '[tempdb_allocations_delta]'
			UNION ALL
			SELECT '[tempdb_current_delta]'
			UNION ALL
			SELECT '[CPU_delta]'
			UNION ALL
			SELECT '[context_switches_delta]'
			UNION ALL
			SELECT '[used_memory_delta]'
			UNION ALL
			SELECT '[tasks]'
			UNION ALL
			SELECT '[tran_start_time]'
			UNION ALL
			SELECT '[open_tran_count]'
			UNION ALL
			SELECT '[blocking_session_id]'
			UNION ALL
			SELECT '[blocked_session_count]'
			UNION ALL
			SELECT '[percent_complete]'
			UNION ALL
			SELECT '[host_name]'
			UNION ALL
			SELECT '[login_name]'
			UNION ALL
			SELECT '[database_name]'
			UNION ALL
			SELECT '[start_time]'
			UNION ALL
			SELECT '[login_time]'
		) AS x ON 
			x.column_name LIKE token ESCAPE '|'
	)
	SELECT
		@sort_order = COALESCE(z.sort_order, '')
	FROM
	(
		SELECT
			STUFF
			(
				(
					SELECT
						',' + column_name as [text()]
					FROM ordered_columns
					WHERE
						r = 1
					ORDER BY
						number
					FOR XML
						PATH('')
				),
				1,
				1,
				''
			) AS sort_order
	) AS z;

	CREATE TABLE #sessions
	(
		recursion SMALLINT NOT NULL,
		session_id SMALLINT NOT NULL,
		request_id INT NOT NULL,
		session_number INT NOT NULL,
		elapsed_time INT NOT NULL,
		avg_elapsed_time INT NULL,
		physical_io BIGINT NULL,
		reads BIGINT NULL,
		physical_reads BIGINT NULL,
		writes BIGINT NULL,
		tempdb_allocations BIGINT NULL,
		tempdb_current BIGINT NULL,
		CPU INT NULL,
		thread_CPU_snapshot BIGINT NULL,
		context_switches BIGINT NULL,
		used_memory BIGINT NOT NULL, 
		tasks SMALLINT NULL,
		status VARCHAR(30) NOT NULL,
		wait_info NVARCHAR(4000) NULL,
		locks XML NULL,
		transaction_id BIGINT NULL,
		tran_start_time DATETIME NULL,
		tran_log_writes NVARCHAR(4000) NULL,
		open_tran_count SMALLINT NULL,
		sql_command XML NULL,
		sql_handle VARBINARY(64) NULL,
		statement_start_offset INT NULL,
		statement_end_offset INT NULL,
		sql_text XML NULL,
		plan_handle VARBINARY(64) NULL,
		query_plan XML NULL,
		blocking_session_id SMALLINT NULL,
		blocked_session_count SMALLINT NULL,
		percent_complete REAL NULL,
		host_name sysname NULL,
		login_name sysname NOT NULL,
		database_name sysname NULL,
		program_name sysname NULL,
		additional_info XML NULL,
		start_time DATETIME NOT NULL,
		login_time DATETIME NULL,
		last_request_start_time DATETIME NULL,
		PRIMARY KEY CLUSTERED (session_id, request_id, recursion) WITH (IGNORE_DUP_KEY = ON),
		UNIQUE NONCLUSTERED (transaction_id, session_id, request_id, recursion) WITH (IGNORE_DUP_KEY = ON)
	);

	IF @return_schema = 0
	BEGIN;
		--Disable unnecessary autostats on the table
		CREATE STATISTICS s_session_id ON #sessions (session_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_request_id ON #sessions (request_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_transaction_id ON #sessions (transaction_id)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_session_number ON #sessions (session_number)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_status ON #sessions (status)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_start_time ON #sessions (start_time)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_last_request_start_time ON #sessions (last_request_start_time)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;
		CREATE STATISTICS s_recursion ON #sessions (recursion)
		WITH SAMPLE 0 ROWS, NORECOMPUTE;

		DECLARE @recursion SMALLINT;
		SET @recursion = 
			CASE @delta_interval
				WHEN 0 THEN 1
				ELSE -1
			END;

		DECLARE @first_collection_ms_ticks BIGINT;
		DECLARE @last_collection_start DATETIME;

		--Used for the delta pull
		REDO:;
		
		IF 
			@get_locks = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[locks|]%' ESCAPE '|'
		BEGIN;
			SELECT
				y.resource_type,
				y.database_name,
				y.object_id,
				y.file_id,
				y.page_type,
				y.hobt_id,
				y.allocation_unit_id,
				y.index_id,
				y.schema_id,
				y.principal_id,
				y.request_mode,
				y.request_status,
				y.session_id,
				y.resource_description,
				y.request_count,
				s.request_id,
				s.start_time,
				CONVERT(sysname, NULL) AS object_name,
				CONVERT(sysname, NULL) AS index_name,
				CONVERT(sysname, NULL) AS schema_name,
				CONVERT(sysname, NULL) AS principal_name,
				CONVERT(NVARCHAR(2048), NULL) AS query_error
			INTO #locks
			FROM
			(
				SELECT
					sp.spid AS session_id,
					CASE sp.status
						WHEN 'sleeping' THEN CONVERT(INT, 0)
						ELSE sp.request_id
					END AS request_id,
					CASE sp.status
						WHEN 'sleeping' THEN sp.last_batch
						ELSE COALESCE(req.start_time, sp.last_batch)
					END AS start_time,
					sp.dbid
				FROM sys.sysprocesses AS sp
				OUTER APPLY
				(
					SELECT TOP(1)
						CASE
							WHEN 
							(
								sp.hostprocess > ''
								OR r.total_elapsed_time < 0
							) THEN
								r.start_time
							ELSE
								DATEADD
								(
									ms, 
									1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())), 
									DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
								)
						END AS start_time
					FROM sys.dm_exec_requests AS r
					WHERE
						r.session_id = sp.spid
						AND r.request_id = sp.request_id
				) AS req
				WHERE
					--Process inclusive filter
					1 =
						CASE
							WHEN @filter <> '' THEN
								CASE @filter_type
									WHEN 'session' THEN
										CASE
											WHEN
												CONVERT(SMALLINT, @filter) = 0
												OR sp.spid = CONVERT(SMALLINT, @filter)
													THEN 1
											ELSE 0
										END
									WHEN 'program' THEN
										CASE
											WHEN sp.program_name LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'login' THEN
										CASE
											WHEN sp.loginame LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'host' THEN
										CASE
											WHEN sp.hostname LIKE @filter THEN 1
											ELSE 0
										END
									WHEN 'database' THEN
										CASE
											WHEN DB_NAME(sp.dbid) LIKE @filter THEN 1
											ELSE 0
										END
									ELSE 0
								END
							ELSE 1
						END
					--Process exclusive filter
					AND 0 =
						CASE
							WHEN @not_filter <> '' THEN
								CASE @not_filter_type
									WHEN 'session' THEN
										CASE
											WHEN sp.spid = CONVERT(SMALLINT, @not_filter) THEN 1
											ELSE 0
										END
									WHEN 'program' THEN
										CASE
											WHEN sp.program_name LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'login' THEN
										CASE
											WHEN sp.loginame LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'host' THEN
										CASE
											WHEN sp.hostname LIKE @not_filter THEN 1
											ELSE 0
										END
									WHEN 'database' THEN
										CASE
											WHEN DB_NAME(sp.dbid) LIKE @not_filter THEN 1
											ELSE 0
										END
									ELSE 0
								END
							ELSE 0
						END
					AND 
					(
						@show_own_spid = 1
						OR sp.spid <> @@SPID
					)
					AND 
					(
						@show_system_spids = 1
						OR sp.hostprocess > ''
					)
					AND sp.ecid = 0
			) AS s
			INNER HASH JOIN
			(
				SELECT
					x.resource_type,
					x.database_name,
					x.object_id,
					x.file_id,
					CASE
						WHEN x.page_no = 1 OR x.page_no % 8088 = 0 THEN 'PFS'
						WHEN x.page_no = 2 OR x.page_no % 511232 = 0 THEN 'GAM'
						WHEN x.page_no = 3 OR (x.page_no - 1) % 511232 = 0 THEN 'SGAM'
						WHEN x.page_no = 6 OR (x.page_no - 6) % 511232 = 0 THEN 'DCM'
						WHEN x.page_no = 7 OR (x.page_no - 7) % 511232 = 0 THEN 'BCM'
						WHEN x.page_no IS NOT NULL THEN '*'
						ELSE NULL
					END AS page_type,
					x.hobt_id,
					x.allocation_unit_id,
					x.index_id,
					x.schema_id,
					x.principal_id,
					x.request_mode,
					x.request_status,
					x.session_id,
					x.request_id,
					CASE
						WHEN COALESCE(x.object_id, x.file_id, x.hobt_id, x.allocation_unit_id, x.index_id, x.schema_id, x.principal_id) IS NULL THEN NULLIF(resource_description, '')
						ELSE NULL
					END AS resource_description,
					COUNT(*) AS request_count
				FROM
				(
					SELECT
						tl.resource_type +
							CASE
								WHEN tl.resource_subtype = '' THEN ''
								ELSE '.' + tl.resource_subtype
							END AS resource_type,
						COALESCE(DB_NAME(tl.resource_database_id), N'(null)') AS database_name,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_type = 'OBJECT' THEN tl.resource_associated_entity_id
								WHEN tl.resource_description LIKE '%object_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('object_id = ', tl.resource_description) + 12), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('object_id = ', tl.resource_description) + 12),
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('object_id = ', tl.resource_description) + 12)
										)
									)
								ELSE NULL
							END
						) AS object_id,
						CONVERT
						(
							INT,
							CASE 
								WHEN tl.resource_type = 'FILE' THEN CONVERT(INT, tl.resource_description)
								WHEN tl.resource_type IN ('PAGE', 'EXTENT', 'RID') THEN LEFT(tl.resource_description, CHARINDEX(':', tl.resource_description)-1)
								ELSE NULL
							END
						) AS file_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_type IN ('PAGE', 'EXTENT', 'RID') THEN 
									SUBSTRING
									(
										tl.resource_description, 
										CHARINDEX(':', tl.resource_description) + 1, 
										COALESCE
										(
											NULLIF
											(
												CHARINDEX(':', tl.resource_description, CHARINDEX(':', tl.resource_description) + 1), 
												0
											), 
											DATALENGTH(tl.resource_description)+1
										) - (CHARINDEX(':', tl.resource_description) + 1)
									)
								ELSE NULL
							END
						) AS page_no,
						CASE
							WHEN tl.resource_type IN ('PAGE', 'KEY', 'RID', 'HOBT') THEN tl.resource_associated_entity_id
							ELSE NULL
						END AS hobt_id,
						CASE
							WHEN tl.resource_type = 'ALLOCATION_UNIT' THEN tl.resource_associated_entity_id
							ELSE NULL
						END AS allocation_unit_id,
						CONVERT
						(
							INT,
							CASE
								WHEN
									/*TODO: Deal with server principals*/ 
									tl.resource_subtype <> 'SERVER_PRINCIPAL' 
									AND tl.resource_description LIKE '%index_id or stats_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('index_id or stats_id = ', tl.resource_description) + 23)
										)
									)
								ELSE NULL
							END 
						) AS index_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_description LIKE '%schema_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('schema_id = ', tl.resource_description) + 12), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('schema_id = ', tl.resource_description) + 12), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('schema_id = ', tl.resource_description) + 12)
										)
									)
								ELSE NULL
							END 
						) AS schema_id,
						CONVERT
						(
							INT,
							CASE
								WHEN tl.resource_description LIKE '%principal_id = %' THEN
									(
										SUBSTRING
										(
											tl.resource_description, 
											(CHARINDEX('principal_id = ', tl.resource_description) + 15), 
											COALESCE
											(
												NULLIF
												(
													CHARINDEX(',', tl.resource_description, CHARINDEX('principal_id = ', tl.resource_description) + 15), 
													0
												), 
												DATALENGTH(tl.resource_description)+1
											) - (CHARINDEX('principal_id = ', tl.resource_description) + 15)
										)
									)
								ELSE NULL
							END
						) AS principal_id,
						tl.request_mode,
						tl.request_status,
						tl.request_session_id AS session_id,
						tl.request_request_id AS request_id,

						/*TODO: Applocks, other resource_descriptions*/
						RTRIM(tl.resource_description) AS resource_description,
						tl.resource_associated_entity_id
						/*********************************************/
					FROM 
					(
						SELECT 
							request_session_id,
							CONVERT(VARCHAR(120), resource_type) COLLATE Latin1_General_Bin2 AS resource_type,
							CONVERT(VARCHAR(120), resource_subtype) COLLATE Latin1_General_Bin2 AS resource_subtype,
							resource_database_id,
							CONVERT(VARCHAR(512), resource_description) COLLATE Latin1_General_Bin2 AS resource_description,
							resource_associated_entity_id,
							CONVERT(VARCHAR(120), request_mode) COLLATE Latin1_General_Bin2 AS request_mode,
							CONVERT(VARCHAR(120), request_status) COLLATE Latin1_General_Bin2 AS request_status,
							request_request_id
						FROM sys.dm_tran_locks
					) AS tl
				) AS x
				GROUP BY
					x.resource_type,
					x.database_name,
					x.object_id,
					x.file_id,
					CASE
						WHEN x.page_no = 1 OR x.page_no % 8088 = 0 THEN 'PFS'
						WHEN x.page_no = 2 OR x.page_no % 511232 = 0 THEN 'GAM'
						WHEN x.page_no = 3 OR (x.page_no - 1) % 511232 = 0 THEN 'SGAM'
						WHEN x.page_no = 6 OR (x.page_no - 6) % 511232 = 0 THEN 'DCM'
						WHEN x.page_no = 7 OR (x.page_no - 7) % 511232 = 0 THEN 'BCM'
						WHEN x.page_no IS NOT NULL THEN '*'
						ELSE NULL
					END,
					x.hobt_id,
					x.allocation_unit_id,
					x.index_id,
					x.schema_id,
					x.principal_id,
					x.request_mode,
					x.request_status,
					x.session_id,
					x.request_id,
					CASE
						WHEN COALESCE(x.object_id, x.file_id, x.hobt_id, x.allocation_unit_id, x.index_id, x.schema_id, x.principal_id) IS NULL THEN NULLIF(resource_description, '')
						ELSE NULL
					END
			) AS y ON
				y.session_id = s.session_id
				AND y.request_id = s.request_id
			OPTION (HASH GROUP);

			--Disable unnecessary autostats on the table
			CREATE STATISTICS s_database_name ON #locks (database_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_id ON #locks (object_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_hobt_id ON #locks (hobt_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_allocation_unit_id ON #locks (allocation_unit_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_index_id ON #locks (index_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_id ON #locks (schema_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_principal_id ON #locks (principal_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_id ON #locks (request_id)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_start_time ON #locks (start_time)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_resource_type ON #locks (resource_type)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_name ON #locks (object_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_name ON #locks (schema_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_page_type ON #locks (page_type)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_mode ON #locks (request_mode)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_request_status ON #locks (request_status)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_resource_description ON #locks (resource_description)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_index_name ON #locks (index_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_principal_name ON #locks (principal_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
		END;
		
		DECLARE 
			@sql VARCHAR(MAX), 
			@sql_n NVARCHAR(MAX);

		SET @sql = 
			CONVERT(VARCHAR(MAX), '') +
			'DECLARE @blocker BIT;
			SET @blocker = 0;
			DECLARE @i INT;
			SET @i = 2147483647;

			DECLARE @sessions TABLE
			(
				session_id SMALLINT NOT NULL,
				request_id INT NOT NULL,
				login_time DATETIME,
				last_request_end_time DATETIME,
				status VARCHAR(30),
				statement_start_offset INT,
				statement_end_offset INT,
				sql_handle BINARY(20),
				host_name NVARCHAR(128),
				login_name NVARCHAR(128),
				program_name NVARCHAR(128),
				database_id SMALLINT,
				memory_usage INT,
				open_tran_count SMALLINT, 
				' +
				CASE
					WHEN 
					(
						@get_task_info <> 0 
						OR @find_block_leaders = 1 
					) THEN
						'wait_type NVARCHAR(32),
						wait_resource NVARCHAR(256),
						wait_time BIGINT, 
						'
					ELSE 
						''
				END +
				'blocked SMALLINT,
				is_user_process BIT,
				cmd VARCHAR(32),
				PRIMARY KEY CLUSTERED (session_id, request_id) WITH (IGNORE_DUP_KEY = ON)
			);

			DECLARE @blockers TABLE
			(
				session_id INT NOT NULL PRIMARY KEY WITH (IGNORE_DUP_KEY = ON)
			);

			BLOCKERS:;

			INSERT @sessions
			(
				session_id,
				request_id,
				login_time,
				last_request_end_time,
				status,
				statement_start_offset,
				statement_end_offset,
				sql_handle,
				host_name,
				login_name,
				program_name,
				database_id,
				memory_usage,
				open_tran_count, 
				' +
				CASE
					WHEN 
					(
						@get_task_info <> 0
						OR @find_block_leaders = 1 
					) THEN
						'wait_type,
						wait_resource,
						wait_time, 
						'
					ELSE
						''
				END +
				'blocked,
				is_user_process,
				cmd 
			)
			SELECT TOP(@i)
				spy.session_id,
				spy.request_id,
				spy.login_time,
				spy.last_request_end_time,
				spy.status,
				spy.statement_start_offset,
				spy.statement_end_offset,
				spy.sql_handle,
				spy.host_name,
				spy.login_name,
				spy.program_name,
				spy.database_id,
				spy.memory_usage,
				spy.open_tran_count,
				' +
				CASE
					WHEN 
					(
						@get_task_info <> 0  
						OR @find_block_leaders = 1 
					) THEN
						'spy.wait_type,
						CASE
							WHEN
								spy.wait_type LIKE N''PAGE%LATCH_%''
								OR spy.wait_type = N''CXPACKET''
								OR spy.wait_type LIKE N''LATCH[_]%''
								OR spy.wait_type = N''OLEDB'' THEN
									spy.wait_resource
							ELSE
								NULL
						END AS wait_resource,
						spy.wait_time, 
						'
					ELSE
						''
				END +
				'spy.blocked,
				spy.is_user_process,
				spy.cmd
			FROM
			(
				SELECT TOP(@i)
					spx.*, 
					' +
					CASE
						WHEN 
						(
							@get_task_info <> 0 
							OR @find_block_leaders = 1 
						) THEN
							'ROW_NUMBER() OVER
							(
								PARTITION BY
									spx.session_id,
									spx.request_id
								ORDER BY
									CASE
										WHEN spx.wait_type LIKE N''LCK[_]%'' THEN 
											1
										ELSE
											99
									END,
									spx.wait_time DESC,
									spx.blocked DESC
							) AS r 
							'
						ELSE 
							'1 AS r 
							'
					END +
				'FROM
				(
					SELECT TOP(@i)
						sp0.session_id,
						sp0.request_id,
						sp0.login_time,
						sp0.last_request_end_time,
						LOWER(sp0.status) AS status,
						CASE
							WHEN sp0.cmd = ''CREATE INDEX'' THEN
								0
							ELSE
								sp0.stmt_start
						END AS statement_start_offset,
						CASE
							WHEN sp0.cmd = N''CREATE INDEX'' THEN
								-1
							ELSE
								COALESCE(NULLIF(sp0.stmt_end, 0), -1)
						END AS statement_end_offset,
						sp0.sql_handle,
						sp0.host_name,
						sp0.login_name,
						sp0.program_name,
						sp0.database_id,
						sp0.memory_usage,
						sp0.open_tran_count, 
						' +
						CASE
							WHEN 
							(
								@get_task_info <> 0 
								OR @find_block_leaders = 1 
							) THEN
								'CASE
									WHEN sp0.wait_time > 0 AND sp0.wait_type <> N''CXPACKET'' THEN
										sp0.wait_type
									ELSE
										NULL
								END AS wait_type,
								CASE
									WHEN sp0.wait_time > 0 AND sp0.wait_type <> N''CXPACKET'' THEN 
										sp0.wait_resource
									ELSE
										NULL
								END AS wait_resource,
								CASE
									WHEN sp0.wait_type <> N''CXPACKET'' THEN
										sp0.wait_time
									ELSE
										0
								END AS wait_time, 
								'
							ELSE
								''
						END +
						'sp0.blocked,
						sp0.is_user_process,
						sp0.cmd
					FROM
					(
						SELECT TOP(@i)
							sp1.session_id,
							sp1.request_id,
							sp1.login_time,
							sp1.last_request_end_time,
							sp1.status,
							sp1.cmd,
							sp1.stmt_start,
							sp1.stmt_end,
							MAX(NULLIF(sp1.sql_handle, 0x00)) OVER (PARTITION BY sp1.session_id, sp1.request_id) AS sql_handle,
							sp1.host_name,
							MAX(sp1.login_name) OVER (PARTITION BY sp1.session_id, sp1.request_id) AS login_name,
							sp1.program_name,
							sp1.database_id,
							MAX(sp1.memory_usage)  OVER (PARTITION BY sp1.session_id, sp1.request_id) AS memory_usage,
							MAX(sp1.open_tran_count)  OVER (PARTITION BY sp1.session_id, sp1.request_id) AS open_tran_count,
							sp1.wait_type,
							sp1.wait_resource,
							sp1.wait_time,
							sp1.blocked,
							sp1.hostprocess,
							sp1.is_user_process
						FROM
						(
							SELECT TOP(@i)
								sp2.spid AS session_id,
								CASE sp2.status
									WHEN ''sleeping'' THEN
										CONVERT(INT, 0)
									ELSE
										sp2.request_id
								END AS request_id,
								MAX(sp2.login_time) AS login_time,
								MAX(sp2.last_batch) AS last_request_end_time,
								MAX(CONVERT(VARCHAR(30), RTRIM(sp2.status)) COLLATE Latin1_General_Bin2) AS status,
								MAX(CONVERT(VARCHAR(32), RTRIM(sp2.cmd)) COLLATE Latin1_General_Bin2) AS cmd,
								MAX(sp2.stmt_start) AS stmt_start,
								MAX(sp2.stmt_end) AS stmt_end,
								MAX(sp2.sql_handle) AS sql_handle,
								MAX(CONVERT(sysname, RTRIM(sp2.hostname)) COLLATE SQL_Latin1_General_CP1_CI_AS) AS host_name,
								MAX(CONVERT(sysname, RTRIM(sp2.loginame)) COLLATE SQL_Latin1_General_CP1_CI_AS) AS login_name,
								MAX
								(
									CASE
										WHEN blk.queue_id IS NOT NULL THEN
											N''Service Broker
												database_id: '' + CONVERT(NVARCHAR, blk.database_id) +
												N'' queue_id: '' + CONVERT(NVARCHAR, blk.queue_id)
										ELSE
											CONVERT
											(
												sysname,
												RTRIM(sp2.program_name)
											)
									END COLLATE SQL_Latin1_General_CP1_CI_AS
								) AS program_name,
								MAX(sp2.dbid) AS database_id,
								MAX(sp2.memusage) AS memory_usage,
								MAX(sp2.open_tran) AS open_tran_count,
								RTRIM(sp2.lastwaittype) AS wait_type,
								RTRIM(sp2.waitresource) AS wait_resource,
								MAX(sp2.waittime) AS wait_time,
								COALESCE(NULLIF(sp2.blocked, sp2.spid), 0) AS blocked,
								MAX
								(
									CASE
										WHEN blk.session_id = sp2.spid THEN
											''blocker''
										ELSE
											RTRIM(sp2.hostprocess)
									END
								) AS hostprocess,
								CONVERT
								(
									BIT,
									MAX
									(
										CASE
											WHEN sp2.hostprocess > '''' THEN
												1
											ELSE
												0
										END
									)
								) AS is_user_process
							FROM
							(
								SELECT TOP(@i)
									session_id,
									CONVERT(INT, NULL) AS queue_id,
									CONVERT(INT, NULL) AS database_id
								FROM @blockers

								UNION ALL

								SELECT TOP(@i)
									CONVERT(SMALLINT, 0),
									CONVERT(INT, NULL) AS queue_id,
									CONVERT(INT, NULL) AS database_id
								WHERE
									@blocker = 0

								UNION ALL

								SELECT TOP(@i)
									CONVERT(SMALLINT, spid),
									queue_id,
									database_id
								FROM sys.dm_broker_activated_tasks
								WHERE
									@blocker = 0
							) AS blk
							INNER JOIN sys.sysprocesses AS sp2 ON
								sp2.spid = blk.session_id
								OR
								(
									blk.session_id = 0
									AND @blocker = 0
								)
							' +
							CASE 
								WHEN 
								(
									@get_task_info = 0 
									AND @find_block_leaders = 0
								) THEN
									'WHERE
										sp2.ecid = 0 
									' 
								ELSE
									''
							END +
							'GROUP BY
								sp2.spid,
								CASE sp2.status
									WHEN ''sleeping'' THEN
										CONVERT(INT, 0)
									ELSE
										sp2.request_id
								END,
								RTRIM(sp2.lastwaittype),
								RTRIM(sp2.waitresource),
								COALESCE(NULLIF(sp2.blocked, sp2.spid), 0)
						) AS sp1
					) AS sp0
					WHERE
						@blocker = 1
						OR
						(1=1 
						' +
							--inclusive filter
							CASE
								WHEN @filter <> '' THEN
									CASE @filter_type
										WHEN 'session' THEN
											CASE
												WHEN CONVERT(SMALLINT, @filter) <> 0 THEN
													'AND sp0.session_id = CONVERT(SMALLINT, @filter) 
													'
												ELSE
													''
											END
										WHEN 'program' THEN
											'AND sp0.program_name LIKE @filter 
											'
										WHEN 'login' THEN
											'AND sp0.login_name LIKE @filter 
											'
										WHEN 'host' THEN
											'AND sp0.host_name LIKE @filter 
											'
										WHEN 'database' THEN
											'AND DB_NAME(sp0.database_id) LIKE @filter 
											'
										ELSE
											''
									END
								ELSE
									''
							END +
							--exclusive filter
							CASE
								WHEN @not_filter <> '' THEN
									CASE @not_filter_type
										WHEN 'session' THEN
											CASE
												WHEN CONVERT(SMALLINT, @not_filter) <> 0 THEN
													'AND sp0.session_id <> CONVERT(SMALLINT, @not_filter) 
													'
												ELSE
													''
											END
										WHEN 'program' THEN
											'AND sp0.program_name NOT LIKE @not_filter 
											'
										WHEN 'login' THEN
											'AND sp0.login_name NOT LIKE @not_filter 
											'
										WHEN 'host' THEN
											'AND sp0.host_name NOT LIKE @not_filter 
											'
										WHEN 'database' THEN
											'AND DB_NAME(sp0.database_id) NOT LIKE @not_filter 
											'
										ELSE
											''
									END
								ELSE
									''
							END +
							CASE @show_own_spid
								WHEN 1 THEN
									''
								ELSE
									'AND sp0.session_id <> @@spid 
									'
							END +
							CASE 
								WHEN @show_system_spids = 0 THEN
									'AND sp0.hostprocess > '''' 
									' 
								ELSE
									''
							END +
							CASE @show_sleeping_spids
								WHEN 0 THEN
									'AND sp0.status <> ''sleeping'' 
									'
								WHEN 1 THEN
									'AND
									(
										sp0.status <> ''sleeping''
										OR sp0.open_tran_count > 0
									)
									'
								ELSE
									''
							END +
						')
				) AS spx
			) AS spy
			WHERE
				spy.r = 1; 
			' + 
			CASE @recursion
				WHEN 1 THEN 
					'IF @@ROWCOUNT > 0
					BEGIN;
						INSERT @blockers
						(
							session_id
						)
						SELECT TOP(@i)
							blocked
						FROM @sessions
						WHERE
							NULLIF(blocked, 0) IS NOT NULL

						EXCEPT

						SELECT TOP(@i)
							session_id
						FROM @sessions; 
						' +

						CASE
							WHEN
							(
								@get_task_info > 0
								OR @find_block_leaders = 1
							) THEN
								'IF @@ROWCOUNT > 0
								BEGIN;
									SET @blocker = 1;
									GOTO BLOCKERS;
								END; 
								'
							ELSE 
								''
						END +
					'END; 
					'
				ELSE 
					''
			END +
			'SELECT TOP(@i)
				@recursion AS recursion,
				x.session_id,
				x.request_id,
				DENSE_RANK() OVER
				(
					ORDER BY
						x.session_id
				) AS session_number,
				' +
				CASE
					WHEN @output_column_list LIKE '%|[dd hh:mm:ss.mss|]%' ESCAPE '|' THEN 
						'x.elapsed_time '
					ELSE 
						'0 '
				END + 
					'AS elapsed_time, 
					' +
				CASE
					WHEN
						(
							@output_column_list LIKE '%|[dd hh:mm:ss.mss (avg)|]%' ESCAPE '|' OR 
							@output_column_list LIKE '%|[avg_elapsed_time|]%' ESCAPE '|'
						)
						AND @recursion = 1
							THEN 
								'x.avg_elapsed_time / 1000 '
					ELSE 
						'NULL '
				END + 
					'AS avg_elapsed_time, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[physical_io|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[physical_io_delta|]%' ESCAPE '|'
							THEN 
								'x.physical_io '
					ELSE 
						'NULL '
				END + 
					'AS physical_io, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[reads|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[reads_delta|]%' ESCAPE '|'
							THEN 
								'x.reads '
					ELSE 
						'0 '
				END + 
					'AS reads, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[physical_reads|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[physical_reads_delta|]%' ESCAPE '|'
							THEN 
								'x.physical_reads '
					ELSE 
						'0 '
				END + 
					'AS physical_reads, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[writes|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[writes_delta|]%' ESCAPE '|'
							THEN 
								'x.writes '
					ELSE 
						'0 '
				END + 
					'AS writes, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tempdb_allocations|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[tempdb_allocations_delta|]%' ESCAPE '|'
							THEN 
								'x.tempdb_allocations '
					ELSE 
						'0 '
				END + 
					'AS tempdb_allocations, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tempdb_current|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[tempdb_current_delta|]%' ESCAPE '|'
							THEN 
								'x.tempdb_current '
					ELSE 
						'0 '
				END + 
					'AS tempdb_current, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[CPU|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
							THEN
								'x.CPU '
					ELSE
						'0 '
				END + 
					'AS CPU, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
						AND @get_task_info = 2
							THEN 
								'x.thread_CPU_snapshot '
					ELSE 
						'0 '
				END + 
					'AS thread_CPU_snapshot, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[context_switches|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[context_switches_delta|]%' ESCAPE '|'
							THEN 
								'x.context_switches '
					ELSE 
						'NULL '
				END + 
					'AS context_switches, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[used_memory|]%' ESCAPE '|'
						OR @output_column_list LIKE '%|[used_memory_delta|]%' ESCAPE '|'
							THEN 
								'x.used_memory '
					ELSE 
						'0 '
				END + 
					'AS used_memory, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[tasks|]%' ESCAPE '|'
						AND @recursion = 1
							THEN 
								'x.tasks '
					ELSE 
						'NULL '
				END + 
					'AS tasks, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[status|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[sql_command|]%' ESCAPE '|'
						)
						AND @recursion = 1
							THEN 
								'x.status '
					ELSE 
						''''' '
				END + 
					'AS status, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[wait_info|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								CASE @get_task_info
									WHEN 2 THEN
										'COALESCE(x.task_wait_info, x.sys_wait_info) '
									ELSE
										'x.sys_wait_info '
								END
					ELSE 
						'NULL '
				END + 
					'AS wait_info, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[tran_start_time|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[tran_log_writes|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 
								'x.transaction_id '
					ELSE 
						'NULL '
				END + 
					'AS transaction_id, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[open_tran_count|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.open_tran_count '
					ELSE 
						'NULL '
				END + 
					'AS open_tran_count, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.sql_handle '
					ELSE 
						'NULL '
				END + 
					'AS sql_handle, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 
								'x.statement_start_offset '
					ELSE 
						'NULL '
				END + 
					'AS statement_start_offset, 
					' +
				CASE
					WHEN 
						(
							@output_column_list LIKE '%|[sql_text|]%' ESCAPE '|' 
							OR @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						)
						AND @recursion = 1
							THEN 
								'x.statement_end_offset '
					ELSE 
						'NULL '
				END + 
					'AS statement_end_offset, 
					' +
				'NULL AS sql_text, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[query_plan|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.plan_handle '
					ELSE 
						'NULL '
				END + 
					'AS plan_handle, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[blocking_session_id|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'NULLIF(x.blocking_session_id, 0) '
					ELSE 
						'NULL '
				END + 
					'AS blocking_session_id, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[percent_complete|]%' ESCAPE '|'
						AND @recursion = 1
							THEN 
								'x.percent_complete '
					ELSE 
						'NULL '
				END + 
					'AS percent_complete, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[host_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.host_name '
					ELSE 
						''''' '
				END + 
					'AS host_name, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[login_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.login_name '
					ELSE 
						''''' '
				END + 
					'AS login_name, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[database_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'DB_NAME(x.database_id) '
					ELSE 
						'NULL '
				END + 
					'AS database_name, 
					' +
				CASE
					WHEN 
						@output_column_list LIKE '%|[program_name|]%' ESCAPE '|' 
						AND @recursion = 1
							THEN 
								'x.program_name '
					ELSE 
						''''' '
				END + 
					'AS program_name, 
					' +
				CASE
					WHEN
						@output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
						AND @recursion = 1
							THEN
								'(
									SELECT TOP(@i)
										x.text_size,
										x.language,
										x.date_format,
										x.date_first,
										CASE x.quoted_identifier
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS quoted_identifier,
										CASE x.arithabort
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS arithabort,
										CASE x.ansi_null_dflt_on
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_null_dflt_on,
										CASE x.ansi_defaults
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_defaults,
										CASE x.ansi_warnings
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_warnings,
										CASE x.ansi_padding
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_padding,
										CASE ansi_nulls
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS ansi_nulls,
										CASE x.concat_null_yields_null
											WHEN 0 THEN ''OFF''
											WHEN 1 THEN ''ON''
										END AS concat_null_yields_null,
										CASE x.transaction_isolation_level
											WHEN 0 THEN ''Unspecified''
											WHEN 1 THEN ''ReadUncomitted''
											WHEN 2 THEN ''ReadCommitted''
											WHEN 3 THEN ''Repeatable''
											WHEN 4 THEN ''Serializable''
											WHEN 5 THEN ''Snapshot''
										END AS transaction_isolation_level,
										x.lock_timeout,
										x.deadlock_priority,
										x.row_count,
										x.command_type, 
										master.dbo.fn_varbintohexstr(x.sql_handle) AS sql_handle,
										master.dbo.fn_varbintohexstr(x.plan_handle) AS plan_handle,
										' +
										CASE
											WHEN @output_column_list LIKE '%|[program_name|]%' ESCAPE '|' THEN
												'(
													SELECT TOP(1)
														CONVERT(uniqueidentifier, CONVERT(XML, '''').value(''xs:hexBinary( substring(sql:column("agent_info.job_id_string"), 0) )'', ''binary(16)'')) AS job_id,
														agent_info.step_id,
														(
															SELECT TOP(1)
																NULL
															FOR XML
																PATH(''job_name''),
																TYPE
														),
														(
															SELECT TOP(1)
																NULL
															FOR XML
																PATH(''step_name''),
																TYPE
														)
													FROM
													(
														SELECT TOP(1)
															SUBSTRING(x.program_name, CHARINDEX(''0x'', x.program_name) + 2, 32) AS job_id_string,
															SUBSTRING(x.program_name, CHARINDEX('': Step '', x.program_name) + 7, CHARINDEX('')'', x.program_name, CHARINDEX('': Step '', x.program_name)) - (CHARINDEX('': Step '', x.program_name) + 7)) AS step_id
														WHERE
															x.program_name LIKE N''SQLAgent - TSQL JobStep (Job 0x%''
													) AS agent_info
													FOR XML
														PATH(''agent_job_info''),
														TYPE
												),
												'
											ELSE ''
										END +
										CASE
											WHEN @get_task_info = 2 THEN
												'CONVERT(XML, x.block_info) AS block_info, 
												'
											ELSE
												''
										END +
										'x.host_process_id 
									FOR XML
										PATH(''additional_info''),
										TYPE
								) '
					ELSE
						'NULL '
				END + 
					'AS additional_info, 
				x.start_time, 
					' +
				CASE
					WHEN
						@output_column_list LIKE '%|[login_time|]%' ESCAPE '|'
						AND @recursion = 1
							THEN
								'x.login_time '
					ELSE 
						'NULL '
				END + 
					'AS login_time, 
				x.last_request_start_time
			FROM
			(
				SELECT TOP(@i)
					y.*,
					CASE
						WHEN DATEDIFF(hour, y.start_time, GETDATE()) > 576 THEN
							DATEDIFF(second, GETDATE(), y.start_time)
						ELSE DATEDIFF(ms, y.start_time, GETDATE())
					END AS elapsed_time,
					COALESCE(tempdb_info.tempdb_allocations, 0) AS tempdb_allocations,
					COALESCE
					(
						CASE
							WHEN tempdb_info.tempdb_current < 0 THEN 0
							ELSE tempdb_info.tempdb_current
						END,
						0
					) AS tempdb_current, 
					' +
					CASE
						WHEN 
							(
								@get_task_info <> 0
								OR @find_block_leaders = 1
							) THEN
								'N''('' + CONVERT(NVARCHAR, y.wait_duration_ms) + N''ms)'' +
									y.wait_type +
										CASE
											WHEN y.wait_type LIKE N''PAGE%LATCH_%'' THEN
												N'':'' +
												COALESCE(DB_NAME(CONVERT(INT, LEFT(y.resource_description, CHARINDEX(N'':'', y.resource_description) - 1))), N''(null)'') +
												N'':'' +
												SUBSTRING(y.resource_description, CHARINDEX(N'':'', y.resource_description) + 1, LEN(y.resource_description) - CHARINDEX(N'':'', REVERSE(y.resource_description)) - CHARINDEX(N'':'', y.resource_description)) +
												N''('' +
													CASE
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 1 OR
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) % 8088 = 0
																THEN 
																	N''PFS''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 2 OR
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) % 511232 = 0
																THEN 
																	N''GAM''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 3 OR
															(CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) - 1) % 511232 = 0
																THEN
																	N''SGAM''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 6 OR
															(CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) - 6) % 511232 = 0 
																THEN 
																	N''DCM''
														WHEN
															CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) = 7 OR
															(CONVERT(INT, RIGHT(y.resource_description, CHARINDEX(N'':'', REVERSE(y.resource_description)) - 1)) - 7) % 511232 = 0 
																THEN 
																	N''BCM''
														ELSE 
															N''*''
													END +
												N'')''
											WHEN y.wait_type = N''CXPACKET'' THEN
												N'':'' + SUBSTRING(y.resource_description, CHARINDEX(N''nodeId'', y.resource_description) + 7, 4)
											WHEN y.wait_type LIKE N''LATCH[_]%'' THEN
												N'' ['' + LEFT(y.resource_description, COALESCE(NULLIF(CHARINDEX(N'' '', y.resource_description), 0), LEN(y.resource_description) + 1) - 1) + N'']''
											WHEN
												y.wait_type = N''OLEDB''
												AND y.resource_description LIKE N''%(SPID=%)'' THEN
													N''['' + LEFT(y.resource_description, CHARINDEX(N''(SPID='', y.resource_description) - 2) +
														N'':'' + SUBSTRING(y.resource_description, CHARINDEX(N''(SPID='', y.resource_description) + 6, CHARINDEX(N'')'', y.resource_description, (CHARINDEX(N''(SPID='', y.resource_description) + 6)) - (CHARINDEX(N''(SPID='', y.resource_description)
 + 6)) + '']''
											ELSE
												N''''
										END COLLATE Latin1_General_Bin2 AS sys_wait_info, 
										'
							ELSE
								''
						END +
						CASE
							WHEN @get_task_info = 2 THEN
								'tasks.physical_io,
								tasks.context_switches,
								tasks.tasks,
								tasks.block_info,
								tasks.wait_info AS task_wait_info,
								tasks.thread_CPU_snapshot,
								'
							ELSE
								'' 
					END +
					CASE 
						WHEN NOT (@get_avg_time = 1 AND @recursion = 1) THEN
							'CONVERT(INT, NULL) '
						ELSE 
							'qs.total_elapsed_time / qs.execution_count '
					END + 
						'AS avg_elapsed_time 
				FROM
				(
					SELECT TOP(@i)
						sp.session_id,
						sp.request_id,
						COALESCE(r.logical_reads, s.logical_reads) AS reads,
						COALESCE(r.reads, s.reads) AS physical_reads,
						COALESCE(r.writes, s.writes) AS writes,
						COALESCE(r.CPU_time, s.CPU_time) AS CPU,
						sp.memory_usage + COALESCE(r.granted_query_memory, 0) AS used_memory,
						LOWER(sp.status) AS status,
						COALESCE(r.sql_handle, sp.sql_handle) AS sql_handle,
						COALESCE(r.statement_start_offset, sp.statement_start_offset) AS statement_start_offset,
						COALESCE(r.statement_end_offset, sp.statement_end_offset) AS statement_end_offset,
						' +
						CASE
							WHEN 
							(
								@get_task_info <> 0
								OR @find_block_leaders = 1 
							) THEN
								'sp.wait_type COLLATE Latin1_General_Bin2 AS wait_type,
								sp.wait_resource COLLATE Latin1_General_Bin2 AS resource_description,
								sp.wait_time AS wait_duration_ms, 
								'
							ELSE
								''
						END +
						'NULLIF(sp.blocked, 0) AS blocking_session_id,
						r.plan_handle,
						NULLIF(r.percent_complete, 0) AS percent_complete,
						sp.host_name,
						sp.login_name,
						sp.program_name,
						s.host_process_id,
						COALESCE(r.text_size, s.text_size) AS text_size,
						COALESCE(r.language, s.language) AS language,
						COALESCE(r.date_format, s.date_format) AS date_format,
						COALESCE(r.date_first, s.date_first) AS date_first,
						COALESCE(r.quoted_identifier, s.quoted_identifier) AS quoted_identifier,
						COALESCE(r.arithabort, s.arithabort) AS arithabort,
						COALESCE(r.ansi_null_dflt_on, s.ansi_null_dflt_on) AS ansi_null_dflt_on,
						COALESCE(r.ansi_defaults, s.ansi_defaults) AS ansi_defaults,
						COALESCE(r.ansi_warnings, s.ansi_warnings) AS ansi_warnings,
						COALESCE(r.ansi_padding, s.ansi_padding) AS ansi_padding,
						COALESCE(r.ansi_nulls, s.ansi_nulls) AS ansi_nulls,
						COALESCE(r.concat_null_yields_null, s.concat_null_yields_null) AS concat_null_yields_null,
						COALESCE(r.transaction_isolation_level, s.transaction_isolation_level) AS transaction_isolation_level,
						COALESCE(r.lock_timeout, s.lock_timeout) AS lock_timeout,
						COALESCE(r.deadlock_priority, s.deadlock_priority) AS deadlock_priority,
						COALESCE(r.row_count, s.row_count) AS row_count,
						COALESCE(r.command, sp.cmd) AS command_type,
						COALESCE
						(
							CASE
								WHEN
								(
									s.is_user_process = 0
									AND r.total_elapsed_time >= 0
								) THEN
									DATEADD
									(
										ms,
										1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())),
										DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
									)
							END,
							NULLIF(COALESCE(r.start_time, sp.last_request_end_time), CONVERT(DATETIME, ''19000101'', 112)),
							(
								SELECT TOP(1)
									DATEADD(second, -(ms_ticks / 1000), GETDATE())
								FROM sys.dm_os_sys_info
							)
						) AS start_time,
						sp.login_time,
						CASE
							WHEN s.is_user_process = 1 THEN
								s.last_request_start_time
							ELSE
								COALESCE
								(
									DATEADD
									(
										ms,
										1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())),
										DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
									),
									s.last_request_start_time
								)
						END AS last_request_start_time,
						r.transaction_id,
						sp.database_id,
						sp.open_tran_count
					FROM @sessions AS sp
					LEFT OUTER LOOP JOIN sys.dm_exec_sessions AS s ON
						s.session_id = sp.session_id
						AND s.login_time = sp.login_time
					LEFT OUTER LOOP JOIN sys.dm_exec_requests AS r ON
						sp.status <> ''sleeping''
						AND r.session_id = sp.session_id
						AND r.request_id = sp.request_id
						AND
						(
							(
								s.is_user_process = 0
								AND sp.is_user_process = 0
							)
							OR
							(
								r.start_time = s.last_request_start_time
								AND s.last_request_end_time <= sp.last_request_end_time
							)
						)
				) AS y
				' + 
				CASE 
					WHEN @get_task_info = 2 THEN
						CONVERT(VARCHAR(MAX), '') +
						'LEFT OUTER HASH JOIN
						(
							SELECT TOP(@i)
								task_nodes.task_node.value(''(session_id/text())[1]'', ''SMALLINT'') AS session_id,
								task_nodes.task_node.value(''(request_id/text())[1]'', ''INT'') AS request_id,
								task_nodes.task_node.value(''(physical_io/text())[1]'', ''BIGINT'') AS physical_io,
								task_nodes.task_node.value(''(context_switches/text())[1]'', ''BIGINT'') AS context_switches,
								task_nodes.task_node.value(''(tasks/text())[1]'', ''INT'') AS tasks,
								task_nodes.task_node.value(''(block_info/text())[1]'', ''NVARCHAR(4000)'') AS block_info,
								task_nodes.task_node.value(''(waits/text())[1]'', ''NVARCHAR(4000)'') AS wait_info,
								task_nodes.task_node.value(''(thread_CPU_snapshot/text())[1]'', ''BIGINT'') AS thread_CPU_snapshot
							FROM
							(
								SELECT TOP(@i)
									CONVERT
									(
										XML,
										REPLACE
										(
											CONVERT(NVARCHAR(MAX), tasks_raw.task_xml_raw) COLLATE Latin1_General_Bin2,
											N''</waits></tasks><tasks><waits>'',
											N'', ''
										)
									) AS task_xml
								FROM
								(
									SELECT TOP(@i)
										CASE waits.r
											WHEN 1 THEN
												waits.session_id
											ELSE
												NULL
										END AS [session_id],
										CASE waits.r
											WHEN 1 THEN
												waits.request_id
											ELSE
												NULL
										END AS [request_id],											
										CASE waits.r
											WHEN 1 THEN
												waits.physical_io
											ELSE
												NULL
										END AS [physical_io],
										CASE waits.r
											WHEN 1 THEN
												waits.context_switches
											ELSE
												NULL
										END AS [context_switches],
										CASE waits.r
											WHEN 1 THEN
												waits.thread_CPU_snapshot
											ELSE
												NULL
										END AS [thread_CPU_snapshot],
										CASE waits.r
											WHEN 1 THEN
												waits.tasks
											ELSE
												NULL
										END AS [tasks],
										CASE waits.r
											WHEN 1 THEN
												waits.block_info
											ELSE
												NULL
										END AS [block_info],
										REPLACE
										(
											REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
											REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
											REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
												CONVERT
												(
													NVARCHAR(MAX),
													N''('' +
														CONVERT(NVARCHAR, num_waits) + N''x: '' +
														CASE num_waits
															WHEN 1 THEN
																CONVERT(NVARCHAR, min_wait_time) + N''ms''
															WHEN 2 THEN
																CASE
																	WHEN min_wait_time <> max_wait_time THEN
																		CONVERT(NVARCHAR, min_wait_time) + N''/'' + CONVERT(NVARCHAR, max_wait_time) + N''ms''
																	ELSE
																		CONVERT(NVARCHAR, max_wait_time) + N''ms''
																END
															ELSE
																CASE
																	WHEN min_wait_time <> max_wait_time THEN
																		CONVERT(NVARCHAR, min_wait_time) + N''/'' + CONVERT(NVARCHAR, avg_wait_time) + N''/'' + CONVERT(NVARCHAR, max_wait_time) + N''ms''
																	ELSE 
																		CONVERT(NVARCHAR, max_wait_time) + N''ms''
																END
														END +
													N'')'' + wait_type COLLATE Latin1_General_Bin2
												),
												NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''),
												NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''),
												NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''),
											NCHAR(0),
											N''''
										) AS [waits]
									FROM
									(
										SELECT TOP(@i)
											w1.*,
											ROW_NUMBER() OVER
											(
												PARTITION BY
													w1.session_id,
													w1.request_id
												ORDER BY
													w1.block_info DESC,
													w1.num_waits DESC,
													w1.wait_type
											) AS r
										FROM
										(
											SELECT TOP(@i)
												task_info.session_id,
												task_info.request_id,
												task_info.physical_io,
												task_info.context_switches,
												task_info.thread_CPU_snapshot,
												task_info.num_tasks AS tasks,
												CASE
													WHEN task_info.runnable_time IS NOT NULL THEN
														''RUNNABLE''
													ELSE
														wt2.wait_type
												END AS wait_type,
												NULLIF(COUNT(COALESCE(task_info.runnable_time, wt2.waiting_task_address)), 0) AS num_waits,
												MIN(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS min_wait_time,
												AVG(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS avg_wait_time,
												MAX(COALESCE(task_info.runnable_time, wt2.wait_duration_ms)) AS max_wait_time,
												MAX(wt2.block_info) AS block_info
											FROM
											(
												SELECT TOP(@i)
													t.session_id,
													t.request_id,
													SUM(CONVERT(BIGINT, t.pending_io_count)) OVER (PARTITION BY t.session_id, t.request_id) AS physical_io,
													SUM(CONVERT(BIGINT, t.context_switches_count)) OVER (PARTITION BY t.session_id, t.request_id) AS context_switches, 
													' +
													CASE
														WHEN @output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
															THEN
																'SUM(tr.usermode_time + tr.kernel_time) OVER (PARTITION BY t.session_id, t.request_id) '
														ELSE
															'CONVERT(BIGINT, NULL) '
													END + 
														' AS thread_CPU_snapshot, 
													COUNT(*) OVER (PARTITION BY t.session_id, t.request_id) AS num_tasks,
													t.task_address,
													t.task_state,
													CASE
														WHEN
															t.task_state = ''RUNNABLE''
															AND w.runnable_time > 0 THEN
																w.runnable_time
														ELSE
															NULL
													END AS runnable_time
												FROM sys.dm_os_tasks AS t
												CROSS APPLY
												(
													SELECT TOP(1)
														sp2.session_id
													FROM @sessions AS sp2
													WHERE
														sp2.session_id = t.session_id
														AND sp2.request_id = t.request_id
														AND sp2.status <> ''sleeping''
												) AS sp20
												LEFT OUTER HASH JOIN
												(
													SELECT TOP(@i)
														(
															SELECT TOP(@i)
																ms_ticks
															FROM sys.dm_os_sys_info
														) -
															w0.wait_resumed_ms_ticks AS runnable_time,
														w0.worker_address,
														w0.thread_address,
														w0.task_bound_ms_ticks
													FROM sys.dm_os_workers AS w0
													WHERE
														w0.state = ''RUNNABLE''
														OR @first_collection_ms_ticks >= w0.task_bound_ms_ticks
												) AS w ON
													w.worker_address = t.worker_address 
												' +
												CASE
													WHEN @output_column_list LIKE '%|[CPU_delta|]%' ESCAPE '|'
														THEN
															'LEFT OUTER HASH JOIN sys.dm_os_threads AS tr ON
																tr.thread_address = w.thread_address
																AND @first_collection_ms_ticks >= w.task_bound_ms_ticks
															'
													ELSE
														''
												END +
											') AS task_info
											LEFT OUTER HASH JOIN
											(
												SELECT TOP(@i)
													wt1.wait_type,
													wt1.waiting_task_address,
													MAX(wt1.wait_duration_ms) AS wait_duration_ms,
													MAX(wt1.block_info) AS block_info
												FROM
												(
													SELECT DISTINCT TOP(@i)
														wt.wait_type +
															CASE
																WHEN wt.wait_type LIKE N''PAGE%LATCH_%'' THEN
																	'':'' +
																	COALESCE(DB_NAME(CONVERT(INT, LEFT(wt.resource_description, CHARINDEX(N'':'', wt.resource_description) - 1))), N''(null)'') +
																	N'':'' +
																	SUBSTRING(wt.resource_description, CHARINDEX(N'':'', wt.resource_description) + 1, LEN(wt.resource_description) - CHARINDEX(N'':'', REVERSE(wt.resource_description)) - CHARINDEX(N'':'', wt.resource_description)) +
																	N''('' +
																		CASE
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 1 OR
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) % 8088 = 0
																					THEN 
																						N''PFS''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 2 OR
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) % 511232 = 0 
																					THEN 
																						N''GAM''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 3 OR
																				(CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) - 1) % 511232 = 0 
																					THEN 
																						N''SGAM''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 6 OR
																				(CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) - 6) % 511232 = 0 
																					THEN 
																						N''DCM''
																			WHEN
																				CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) = 7 OR
																				(CONVERT(INT, RIGHT(wt.resource_description, CHARINDEX(N'':'', REVERSE(wt.resource_description)) - 1)) - 7) % 511232 = 0
																					THEN 
																						N''BCM''
																			ELSE
																				N''*''
																		END +
																	N'')''
																WHEN wt.wait_type = N''CXPACKET'' THEN
																	N'':'' + SUBSTRING(wt.resource_description, CHARINDEX(N''nodeId'', wt.resource_description) + 7, 4)
																WHEN wt.wait_type LIKE N''LATCH[_]%'' THEN
																	N'' ['' + LEFT(wt.resource_description, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description), 0), LEN(wt.resource_description) + 1) - 1) + N'']''
																ELSE 
																	N''''
															END COLLATE Latin1_General_Bin2 AS wait_type,
														CASE
															WHEN
															(
																wt.blocking_session_id IS NOT NULL
																AND wt.wait_type LIKE N''LCK[_]%''
															) THEN
																(
																	SELECT TOP(@i)
																		x.lock_type,
																		REPLACE
																		(
																			REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
																			REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
																			REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
																				DB_NAME
																				(
																					CONVERT
																					(
																						INT,
																						SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''dbid='', wt.resource_description), 0) + 5, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''dbid='', wt.resource_description) + 5), 0), LEN(wt.resource_des
cription) + 1) - CHARINDEX(N''dbid='', wt.resource_description) - 5)
																					)
																				),
																				NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''),
																				NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''),
																				NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''),
																			NCHAR(0),
																			N''''
																		) AS database_name,
																		CASE x.lock_type
																			WHEN N''objectlock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''objid='', wt.resource_description), 0) + 6, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''objid='', wt.resource_description) + 6), 0), LEN(wt.resource_des
cription) + 1) - CHARINDEX(N''objid='', wt.resource_description) - 6)
																			ELSE
																				NULL
																		END AS object_id,
																		CASE x.lock_type
																			WHEN N''filelock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''fileid='', wt.resource_description), 0) + 7, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''fileid='', wt.resource_description) + 7), 0), LEN(wt.resource_d
escription) + 1) - CHARINDEX(N''fileid='', wt.resource_description) - 7)
																			ELSE
																				NULL
																		END AS file_id,
																		CASE
																			WHEN x.lock_type in (N''pagelock'', N''extentlock'', N''ridlock'') THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''associatedObjectId='', wt.resource_description), 0) + 19, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''associatedObjectId='', wt.resource_description) + 
19), 0), LEN(wt.resource_description) + 1) - CHARINDEX(N''associatedObjectId='', wt.resource_description) - 19)
																			WHEN x.lock_type in (N''keylock'', N''hobtlock'', N''allocunitlock'') THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''hobtid='', wt.resource_description), 0) + 7, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''hobtid='', wt.resource_description) + 7), 0), LEN(wt.resource_d
escription) + 1) - CHARINDEX(N''hobtid='', wt.resource_description) - 7)
																			ELSE
																				NULL
																		END AS hobt_id,
																		CASE x.lock_type
																			WHEN N''applicationlock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''hash='', wt.resource_description), 0) + 5, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''hash='', wt.resource_description) + 5), 0), LEN(wt.resource_descr
iption) + 1) - CHARINDEX(N''hash='', wt.resource_description) - 5)
																			ELSE
																				NULL
																		END AS applock_hash,
																		CASE x.lock_type
																			WHEN N''metadatalock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''subresource='', wt.resource_description), 0) + 12, COALESCE(NULLIF(CHARINDEX(N'' '', wt.resource_description, CHARINDEX(N''subresource='', wt.resource_description) + 12), 0), LEN(w
t.resource_description) + 1) - CHARINDEX(N''subresource='', wt.resource_description) - 12)
																			ELSE
																				NULL
																		END AS metadata_resource,
																		CASE x.lock_type
																			WHEN N''metadatalock'' THEN
																				SUBSTRING(wt.resource_description, NULLIF(CHARINDEX(N''classid='', wt.resource_description), 0) + 8, COALESCE(NULLIF(CHARINDEX(N'' dbid='', wt.resource_description) - CHARINDEX(N''classid='', wt.resource_description), 0), LEN(wt.resour
ce_description) + 1) - 8)
																			ELSE
																				NULL
																		END AS metadata_class_id
																	FROM
																	(
																		SELECT TOP(1)
																			LEFT(wt.resource_description, CHARINDEX(N'' '', wt.resource_description) - 1) COLLATE Latin1_General_Bin2 AS lock_type
																	) AS x
																	FOR XML
																		PATH('''')
																)
															ELSE NULL
														END AS block_info,
														wt.wait_duration_ms,
														wt.waiting_task_address
													FROM
													(
														SELECT TOP(@i)
															wt0.wait_type COLLATE Latin1_General_Bin2 AS wait_type,
															wt0.resource_description COLLATE Latin1_General_Bin2 AS resource_description,
															wt0.wait_duration_ms,
															wt0.waiting_task_address,
															CASE
																WHEN wt0.blocking_session_id = p.blocked THEN
																	wt0.blocking_session_id
																ELSE
																	NULL
															END AS blocking_session_id
														FROM sys.dm_os_waiting_tasks AS wt0
														CROSS APPLY
														(
															SELECT TOP(1)
																s0.blocked
															FROM @sessions AS s0
															WHERE
																s0.session_id = wt0.session_id
																AND COALESCE(s0.wait_type, N'''') <> N''OLEDB''
																AND wt0.wait_type <> N''OLEDB''
														) AS p
													) AS wt
												) AS wt1
												GROUP BY
													wt1.wait_type,
													wt1.waiting_task_address
											) AS wt2 ON
												wt2.waiting_task_address = task_info.task_address
												AND wt2.wait_duration_ms > 0
												AND task_info.runnable_time IS NULL
											GROUP BY
												task_info.session_id,
												task_info.request_id,
												task_info.physical_io,
												task_info.context_switches,
												task_info.thread_CPU_snapshot,
												task_info.num_tasks,
												CASE
													WHEN task_info.runnable_time IS NOT NULL THEN
														''RUNNABLE''
													ELSE
														wt2.wait_type
												END
										) AS w1
									) AS waits
									ORDER BY
										waits.session_id,
										waits.request_id,
										waits.r
									FOR XML
										PATH(N''tasks''),
										TYPE
								) AS tasks_raw (task_xml_raw)
							) AS tasks_final
							CROSS APPLY tasks_final.task_xml.nodes(N''/tasks'') AS task_nodes (task_node)
							WHERE
								task_nodes.task_node.exist(N''session_id'') = 1
						) AS tasks ON
							tasks.session_id = y.session_id
							AND tasks.request_id = y.request_id 
						'
					ELSE
						''
				END +
				'LEFT OUTER HASH JOIN
				(
					SELECT TOP(@i)
						t_info.session_id,
						COALESCE(t_info.request_id, -1) AS request_id,
						SUM(t_info.tempdb_allocations) AS tempdb_allocations,
						SUM(t_info.tempdb_current) AS tempdb_current
					FROM
					(
						SELECT TOP(@i)
							tsu.session_id,
							tsu.request_id,
							tsu.user_objects_alloc_page_count +
								tsu.internal_objects_alloc_page_count AS tempdb_allocations,
							tsu.user_objects_alloc_page_count +
								tsu.internal_objects_alloc_page_count -
								tsu.user_objects_dealloc_page_count -
								tsu.internal_objects_dealloc_page_count AS tempdb_current
						FROM sys.dm_db_task_space_usage AS tsu
						CROSS APPLY
						(
							SELECT TOP(1)
								s0.session_id
							FROM @sessions AS s0
							WHERE
								s0.session_id = tsu.session_id
						) AS p

						UNION ALL

						SELECT TOP(@i)
							ssu.session_id,
							NULL AS request_id,
							ssu.user_objects_alloc_page_count +
								ssu.internal_objects_alloc_page_count AS tempdb_allocations,
							ssu.user_objects_alloc_page_count +
								ssu.internal_objects_alloc_page_count -
								ssu.user_objects_dealloc_page_count -
								ssu.internal_objects_dealloc_page_count AS tempdb_current
						FROM sys.dm_db_session_space_usage AS ssu
						CROSS APPLY
						(
							SELECT TOP(1)
								s0.session_id
							FROM @sessions AS s0
							WHERE
								s0.session_id = ssu.session_id
						) AS p
					) AS t_info
					GROUP BY
						t_info.session_id,
						COALESCE(t_info.request_id, -1)
				) AS tempdb_info ON
					tempdb_info.session_id = y.session_id
					AND tempdb_info.request_id =
						CASE
							WHEN y.status = N''sleeping'' THEN
								-1
							ELSE
								y.request_id
						END
				' +
				CASE 
					WHEN 
						NOT 
						(
							@get_avg_time = 1 
							AND @recursion = 1
						) THEN 
							''
					ELSE
						'LEFT OUTER HASH JOIN
						(
							SELECT TOP(@i)
								*
							FROM sys.dm_exec_query_stats
						) AS qs ON
							qs.sql_handle = y.sql_handle
							AND qs.plan_handle = y.plan_handle
							AND qs.statement_start_offset = y.statement_start_offset
							AND qs.statement_end_offset = y.statement_end_offset
						'
				END + 
			') AS x
			OPTION (KEEPFIXED PLAN, OPTIMIZE FOR (@i = 1)); ';

		SET @sql_n = CONVERT(NVARCHAR(MAX), @sql);

		SET @last_collection_start = GETDATE();

		IF @recursion = -1
		BEGIN;
			SELECT
				@first_collection_ms_ticks = ms_ticks
			FROM sys.dm_os_sys_info;
		END;

		INSERT #sessions
		(
			recursion,
			session_id,
			request_id,
			session_number,
			elapsed_time,
			avg_elapsed_time,
			physical_io,
			reads,
			physical_reads,
			writes,
			tempdb_allocations,
			tempdb_current,
			CPU,
			thread_CPU_snapshot,
			context_switches,
			used_memory,
			tasks,
			status,
			wait_info,
			transaction_id,
			open_tran_count,
			sql_handle,
			statement_start_offset,
			statement_end_offset,		
			sql_text,
			plan_handle,
			blocking_session_id,
			percent_complete,
			host_name,
			login_name,
			database_name,
			program_name,
			additional_info,
			start_time,
			login_time,
			last_request_start_time
		)
		EXEC sp_executesql 
			@sql_n,
			N'@recursion SMALLINT, @filter sysname, @not_filter sysname, @first_collection_ms_ticks BIGINT',
			@recursion, @filter, @not_filter, @first_collection_ms_ticks;

		--Collect transaction information?
		IF
			@recursion = 1
			AND
			(
				@output_column_list LIKE '%|[tran_start_time|]%' ESCAPE '|'
				OR @output_column_list LIKE '%|[tran_log_writes|]%' ESCAPE '|' 
			)
		BEGIN;	
			DECLARE @i INT;
			SET @i = 2147483647;

			UPDATE s
			SET
				tran_start_time =
					CONVERT
					(
						DATETIME,
						LEFT
						(
							x.trans_info,
							NULLIF(CHARINDEX(NCHAR(254) COLLATE Latin1_General_Bin2, x.trans_info) - 1, -1)
						),
						121
					),
				tran_log_writes =
					RIGHT
					(
						x.trans_info,
						LEN(x.trans_info) - CHARINDEX(NCHAR(254) COLLATE Latin1_General_Bin2, x.trans_info)
					)
			FROM
			(
				SELECT TOP(@i)
					trans_nodes.trans_node.value('(session_id/text())[1]', 'SMALLINT') AS session_id,
					COALESCE(trans_nodes.trans_node.value('(request_id/text())[1]', 'INT'), 0) AS request_id,
					trans_nodes.trans_node.value('(trans_info/text())[1]', 'NVARCHAR(4000)') AS trans_info				
				FROM
				(
					SELECT TOP(@i)
						CONVERT
						(
							XML,
							REPLACE
							(
								CONVERT(NVARCHAR(MAX), trans_raw.trans_xml_raw) COLLATE Latin1_General_Bin2, 
								N'</trans_info></trans><trans><trans_info>', N''
							)
						)
					FROM
					(
						SELECT TOP(@i)
							CASE u_trans.r
								WHEN 1 THEN u_trans.session_id
								ELSE NULL
							END AS [session_id],
							CASE u_trans.r
								WHEN 1 THEN u_trans.request_id
								ELSE NULL
							END AS [request_id],
							CONVERT
							(
								NVARCHAR(MAX),
								CASE
									WHEN u_trans.database_id IS NOT NULL THEN
										CASE u_trans.r
											WHEN 1 THEN COALESCE(CONVERT(NVARCHAR, u_trans.transaction_start_time, 121) + NCHAR(254), N'')
											ELSE N''
										END + 
											REPLACE
											(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
												REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
													CONVERT(VARCHAR(128), COALESCE(DB_NAME(u_trans.database_id), N'(null)')),
													NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
													NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
													NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
												NCHAR(0),
												N'?'
											) +
											N': ' +
										CONVERT(NVARCHAR, u_trans.log_record_count) + N' (' + CONVERT(NVARCHAR, u_trans.log_kb_used) + N' kB)' +
										N','
									ELSE
										N'N/A,'
								END COLLATE Latin1_General_Bin2
							) AS [trans_info]
						FROM
						(
							SELECT TOP(@i)
								trans.*,
								ROW_NUMBER() OVER
								(
									PARTITION BY
										trans.session_id,
										trans.request_id
									ORDER BY
										trans.transaction_start_time DESC
								) AS r
							FROM
							(
								SELECT TOP(@i)
									session_tran_map.session_id,
									session_tran_map.request_id,
									s_tran.database_id,
									COALESCE(SUM(s_tran.database_transaction_log_record_count), 0) AS log_record_count,
									COALESCE(SUM(s_tran.database_transaction_log_bytes_used), 0) / 1024 AS log_kb_used,
									MIN(s_tran.database_transaction_begin_time) AS transaction_start_time
								FROM
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_active_transactions
									WHERE
										transaction_begin_time <= @last_collection_start
								) AS a_tran
								INNER HASH JOIN
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_database_transactions
									WHERE
										database_id < 32767
								) AS s_tran ON
									s_tran.transaction_id = a_tran.transaction_id
								LEFT OUTER HASH JOIN
								(
									SELECT TOP(@i)
										*
									FROM sys.dm_tran_session_transactions
								) AS tst ON
									s_tran.transaction_id = tst.transaction_id
								CROSS APPLY
								(
									SELECT TOP(1)
										s3.session_id,
										s3.request_id
									FROM
									(
										SELECT TOP(1)
											s1.session_id,
											s1.request_id
										FROM #sessions AS s1
										WHERE
											s1.transaction_id = s_tran.transaction_id
											AND s1.recursion = 1
											
										UNION ALL
									
										SELECT TOP(1)
											s2.session_id,
											s2.request_id
										FROM #sessions AS s2
										WHERE
											s2.session_id = tst.session_id
											AND s2.recursion = 1
									) AS s3
									ORDER BY
										s3.request_id
								) AS session_tran_map
								GROUP BY
									session_tran_map.session_id,
									session_tran_map.request_id,
									s_tran.database_id
							) AS trans
						) AS u_trans
						FOR XML
							PATH('trans'),
							TYPE
					) AS trans_raw (trans_xml_raw)
				) AS trans_final (trans_xml)
				CROSS APPLY trans_final.trans_xml.nodes('/trans') AS trans_nodes (trans_node)
			) AS x
			INNER HASH JOIN #sessions AS s ON
				s.session_id = x.session_id
				AND s.request_id = x.request_id
			OPTION (OPTIMIZE FOR (@i = 1));
		END;

		--Variables for text and plan collection
		DECLARE	
			@session_id SMALLINT,
			@request_id INT,
			@sql_handle VARBINARY(64),
			@plan_handle VARBINARY(64),
			@statement_start_offset INT,
			@statement_end_offset INT,
			@start_time DATETIME,
			@database_name sysname;

		IF 
			@recursion = 1
			AND @output_column_list LIKE '%|[sql_text|]%' ESCAPE '|'
		BEGIN;
			DECLARE sql_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT 
					session_id,
					request_id,
					sql_handle,
					statement_start_offset,
					statement_end_offset
				FROM #sessions
				WHERE
					recursion = 1
					AND sql_handle IS NOT NULL
			OPTION (KEEPFIXED PLAN);

			OPEN sql_cursor;

			FETCH NEXT FROM sql_cursor
			INTO 
				@session_id,
				@request_id,
				@sql_handle,
				@statement_start_offset,
				@statement_end_offset;

			--Wait up to 5 ms for the SQL text, then give up
			SET LOCK_TIMEOUT 5;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					UPDATE s
					SET
						s.sql_text =
						(
							SELECT
								REPLACE
								(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
										N'--' + NCHAR(13) + NCHAR(10) +
										CASE 
											WHEN @get_full_inner_text = 1 THEN est.text
											WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN est.text
											WHEN SUBSTRING(est.text, (@statement_start_offset/2), 2) LIKE N'[a-zA-Z0-9][a-zA-Z0-9]' THEN est.text
											ELSE
												CASE
													WHEN @statement_start_offset > 0 THEN
														SUBSTRING
														(
															est.text,
															((@statement_start_offset/2) + 1),
															(
																CASE
																	WHEN @statement_end_offset = -1 THEN 2147483647
																	ELSE ((@statement_end_offset - @statement_start_offset)/2) + 1
																END
															)
														)
													ELSE RTRIM(LTRIM(est.text))
												END
										END +
										NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2,
										NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
										NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
										NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
									NCHAR(0),
									N''
								) AS [processing-instruction(query)]
							FOR XML
								PATH(''),
								TYPE
						),
						s.statement_start_offset = 
							CASE 
								WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN 0
								WHEN SUBSTRING(CONVERT(VARCHAR(MAX), est.text), (@statement_start_offset/2), 2) LIKE '[a-zA-Z0-9][a-zA-Z0-9]' THEN 0
								ELSE @statement_start_offset
							END,
						s.statement_end_offset = 
							CASE 
								WHEN LEN(est.text) < (@statement_end_offset / 2) + 1 THEN -1
								WHEN SUBSTRING(CONVERT(VARCHAR(MAX), est.text), (@statement_start_offset/2), 2) LIKE '[a-zA-Z0-9][a-zA-Z0-9]' THEN -1
								ELSE @statement_end_offset
							END
					FROM 
						#sessions AS s,
						(
							SELECT TOP(1)
								text
							FROM
							(
								SELECT 
									text, 
									0 AS row_num
								FROM sys.dm_exec_sql_text(@sql_handle)
								
								UNION ALL
								
								SELECT 
									NULL,
									1 AS row_num
							) AS est0
							ORDER BY
								row_num
						) AS est
					WHERE 
						s.session_id = @session_id
						AND s.request_id = @request_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END TRY
				BEGIN CATCH;
					UPDATE s
					SET
						s.sql_text = 
							CASE ERROR_NUMBER() 
								WHEN 1222 THEN '<timeout_exceeded />'
								ELSE '<error message="' + ERROR_MESSAGE() + '" />'
							END
					FROM #sessions AS s
					WHERE 
						s.session_id = @session_id
						AND s.request_id = @request_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END CATCH;

				FETCH NEXT FROM sql_cursor
				INTO
					@session_id,
					@request_id,
					@sql_handle,
					@statement_start_offset,
					@statement_end_offset;
			END;

			--Return this to the default
			SET LOCK_TIMEOUT -1;

			CLOSE sql_cursor;
			DEALLOCATE sql_cursor;
		END;

		IF 
			@get_outer_command = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[sql_command|]%' ESCAPE '|'
		BEGIN;
			DECLARE @buffer_results TABLE
			(
				EventType VARCHAR(30),
				Parameters INT,
				EventInfo NVARCHAR(4000),
				start_time DATETIME,
				session_number INT IDENTITY(1,1) NOT NULL PRIMARY KEY
			);

			DECLARE buffer_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT 
					session_id,
					MAX(start_time) AS start_time
				FROM #sessions
				WHERE
					recursion = 1
				GROUP BY
					session_id
				ORDER BY
					session_id
				OPTION (KEEPFIXED PLAN);

			OPEN buffer_cursor;

			FETCH NEXT FROM buffer_cursor
			INTO 
				@session_id,
				@start_time;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					--In SQL Server 2008, DBCC INPUTBUFFER will throw 
					--an exception if the session no longer exists
					INSERT @buffer_results
					(
						EventType,
						Parameters,
						EventInfo
					)
					EXEC sp_executesql
						N'DBCC INPUTBUFFER(@session_id) WITH NO_INFOMSGS;',
						N'@session_id SMALLINT',
						@session_id;

					UPDATE br
					SET
						br.start_time = @start_time
					FROM @buffer_results AS br
					WHERE
						br.session_number = 
						(
							SELECT MAX(br2.session_number)
							FROM @buffer_results br2
						);
				END TRY
				BEGIN CATCH
				END CATCH;

				FETCH NEXT FROM buffer_cursor
				INTO 
					@session_id,
					@start_time;
			END;

			UPDATE s
			SET
				sql_command = 
				(
					SELECT 
						REPLACE
						(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								CONVERT
								(
									NVARCHAR(MAX),
									N'--' + NCHAR(13) + NCHAR(10) + br.EventInfo + NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2
								),
								NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
								NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
								NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
							NCHAR(0),
							N''
						) AS [processing-instruction(query)]
					FROM @buffer_results AS br
					WHERE 
						br.session_number = s.session_number
						AND br.start_time = s.start_time
						AND 
						(
							(
								s.start_time = s.last_request_start_time
								AND EXISTS
								(
									SELECT *
									FROM sys.dm_exec_requests r2
									WHERE
										r2.session_id = s.session_id
										AND r2.request_id = s.request_id
										AND r2.start_time = s.start_time
								)
							)
							OR 
							(
								s.request_id = 0
								AND EXISTS
								(
									SELECT *
									FROM sys.dm_exec_sessions s2
									WHERE
										s2.session_id = s.session_id
										AND s2.last_request_start_time = s.last_request_start_time
								)
							)
						)
					FOR XML
						PATH(''),
						TYPE
				)
			FROM #sessions AS s
			WHERE
				recursion = 1
			OPTION (KEEPFIXED PLAN);

			CLOSE buffer_cursor;
			DEALLOCATE buffer_cursor;
		END;

		IF 
			@get_plans >= 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[query_plan|]%' ESCAPE '|'
		BEGIN;
			DECLARE plan_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT
					session_id,
					request_id,
					plan_handle,
					statement_start_offset,
					statement_end_offset
				FROM #sessions
				WHERE
					recursion = 1
					AND plan_handle IS NOT NULL
			OPTION (KEEPFIXED PLAN);

			OPEN plan_cursor;

			FETCH NEXT FROM plan_cursor
			INTO 
				@session_id,
				@request_id,
				@plan_handle,
				@statement_start_offset,
				@statement_end_offset;

			--Wait up to 5 ms for a query plan, then give up
			SET LOCK_TIMEOUT 5;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					UPDATE s
					SET
						s.query_plan =
						(
							SELECT
								CONVERT(xml, query_plan)
							FROM sys.dm_exec_text_query_plan
							(
								@plan_handle, 
								CASE @get_plans
									WHEN 1 THEN
										@statement_start_offset
									ELSE
										0
								END, 
								CASE @get_plans
									WHEN 1 THEN
										@statement_end_offset
									ELSE
										-1
								END
							)
						)
					FROM #sessions AS s
					WHERE 
						s.session_id = @session_id
						AND s.request_id = @request_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END TRY
				BEGIN CATCH;
					IF ERROR_NUMBER() = 6335
					BEGIN;
						UPDATE s
						SET
							s.query_plan =
							(
								SELECT
									N'--' + NCHAR(13) + NCHAR(10) + 
									N'-- Could not render showplan due to XML data type limitations. ' + NCHAR(13) + NCHAR(10) + 
									N'-- To see the graphical plan save the XML below as a .SQLPLAN file and re-open in SSMS.' + NCHAR(13) + NCHAR(10) +
									N'--' + NCHAR(13) + NCHAR(10) +
										REPLACE(qp.query_plan, N'<RelOp', NCHAR(13)+NCHAR(10)+N'<RelOp') + 
										NCHAR(13) + NCHAR(10) + N'--' COLLATE Latin1_General_Bin2 AS [processing-instruction(query_plan)]
								FROM sys.dm_exec_text_query_plan
								(
									@plan_handle, 
									CASE @get_plans
										WHEN 1 THEN
											@statement_start_offset
										ELSE
											0
									END, 
									CASE @get_plans
										WHEN 1 THEN
											@statement_end_offset
										ELSE
											-1
									END
								) AS qp
								FOR XML
									PATH(''),
									TYPE
							)
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
							AND s.request_id = @request_id
							AND s.recursion = 1
						OPTION (KEEPFIXED PLAN);
					END;
					ELSE
					BEGIN;
						UPDATE s
						SET
							s.query_plan = 
								CASE ERROR_NUMBER() 
									WHEN 1222 THEN '<timeout_exceeded />'
									ELSE '<error message="' + ERROR_MESSAGE() + '" />'
								END
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
							AND s.request_id = @request_id
							AND s.recursion = 1
						OPTION (KEEPFIXED PLAN);
					END;
				END CATCH;

				FETCH NEXT FROM plan_cursor
				INTO
					@session_id,
					@request_id,
					@plan_handle,
					@statement_start_offset,
					@statement_end_offset;
			END;

			--Return this to the default
			SET LOCK_TIMEOUT -1;

			CLOSE plan_cursor;
			DEALLOCATE plan_cursor;
		END;

		IF 
			@get_locks = 1 
			AND @recursion = 1
			AND @output_column_list LIKE '%|[locks|]%' ESCAPE '|'
		BEGIN;
			DECLARE locks_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT DISTINCT
					database_name
				FROM #locks
				WHERE
					EXISTS
					(
						SELECT *
						FROM #sessions AS s
						WHERE
							s.session_id = #locks.session_id
							AND recursion = 1
					)
					AND database_name <> '(null)'
				OPTION (KEEPFIXED PLAN);

			OPEN locks_cursor;

			FETCH NEXT FROM locks_cursor
			INTO 
				@database_name;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					SET @sql_n = CONVERT(NVARCHAR(MAX), '') +
						'UPDATE l ' +
						'SET ' +
							'object_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'o.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'index_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'i.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'schema_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										's.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'principal_name = ' + 
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'dp.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								') ' +
						'FROM #locks AS l ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.allocation_units AS au ON ' +
							'au.allocation_unit_id = l.allocation_unit_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p ON ' +
							'p.hobt_id = ' +
								'COALESCE ' +
								'( ' +
									'l.hobt_id, ' +
									'CASE ' +
										'WHEN au.type IN (1, 3) THEN au.container_id ' +
										'ELSE NULL ' +
									'END ' +
								') ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p1 ON ' +
							'l.hobt_id IS NULL ' +
							'AND au.type = 2 ' +
							'AND p1.partition_id = au.container_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.objects AS o ON ' +
							'o.object_id = COALESCE(l.object_id, p.object_id, p1.object_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.indexes AS i ON ' +
							'i.object_id = COALESCE(l.object_id, p.object_id, p1.object_id) ' +
							'AND i.index_id = COALESCE(l.index_id, p.index_id, p1.index_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.schemas AS s ON ' +
							's.schema_id = COALESCE(l.schema_id, o.schema_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.database_principals AS dp ON ' +
							'dp.principal_id = l.principal_id ' +
						'WHERE ' +
							'l.database_name = @database_name ' +
						'OPTION (KEEPFIXED PLAN); ';
					
					EXEC sp_executesql
						@sql_n,
						N'@database_name sysname',
						@database_name;
				END TRY
				BEGIN CATCH;
					UPDATE #locks
					SET
						query_error = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									CONVERT
									(
										NVARCHAR(MAX), 
										ERROR_MESSAGE() COLLATE Latin1_General_Bin2
									),
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N''
							)
					WHERE 
						database_name = @database_name
					OPTION (KEEPFIXED PLAN);
				END CATCH;

				FETCH NEXT FROM locks_cursor
				INTO
					@database_name;
			END;

			CLOSE locks_cursor;
			DEALLOCATE locks_cursor;

			CREATE CLUSTERED INDEX IX_SRD ON #locks (session_id, request_id, database_name);

			UPDATE s
			SET 
				s.locks =
				(
					SELECT 
						REPLACE
						(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
							REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								CONVERT
								(
									NVARCHAR(MAX), 
									l1.database_name COLLATE Latin1_General_Bin2
								),
								NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
								NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
								NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
							NCHAR(0),
							N''
						) AS [Database/@name],
						MIN(l1.query_error) AS [Database/@query_error],
						(
							SELECT 
								l2.request_mode AS [Lock/@request_mode],
								l2.request_status AS [Lock/@request_status],
								COUNT(*) AS [Lock/@request_count]
							FROM #locks AS l2
							WHERE 
								l1.session_id = l2.session_id
								AND l1.request_id = l2.request_id
								AND l2.database_name = l1.database_name
								AND l2.resource_type = 'DATABASE'
							GROUP BY
								l2.request_mode,
								l2.request_status
							FOR XML
								PATH(''),
								TYPE
						) AS [Database/Locks],
						(
							SELECT
								COALESCE(l3.object_name, '(null)') AS [Object/@name],
								l3.schema_name AS [Object/@schema_name],
								(
									SELECT
										l4.resource_type AS [Lock/@resource_type],
										l4.page_type AS [Lock/@page_type],
										l4.index_name AS [Lock/@index_name],
										CASE 
											WHEN l4.object_name IS NULL THEN l4.schema_name
											ELSE NULL
										END AS [Lock/@schema_name],
										l4.principal_name AS [Lock/@principal_name],
										l4.resource_description AS [Lock/@resource_description],
										l4.request_mode AS [Lock/@request_mode],
										l4.request_status AS [Lock/@request_status],
										SUM(l4.request_count) AS [Lock/@request_count]
									FROM #locks AS l4
									WHERE 
										l4.session_id = l3.session_id
										AND l4.request_id = l3.request_id
										AND l3.database_name = l4.database_name
										AND COALESCE(l3.object_name, '(null)') = COALESCE(l4.object_name, '(null)')
										AND COALESCE(l3.schema_name, '') = COALESCE(l4.schema_name, '')
										AND l4.resource_type <> 'DATABASE'
									GROUP BY
										l4.resource_type,
										l4.page_type,
										l4.index_name,
										CASE 
											WHEN l4.object_name IS NULL THEN l4.schema_name
											ELSE NULL
										END,
										l4.principal_name,
										l4.resource_description,
										l4.request_mode,
										l4.request_status
									FOR XML
										PATH(''),
										TYPE
								) AS [Object/Locks]
							FROM #locks AS l3
							WHERE 
								l3.session_id = l1.session_id
								AND l3.request_id = l1.request_id
								AND l3.database_name = l1.database_name
								AND l3.resource_type <> 'DATABASE'
							GROUP BY 
								l3.session_id,
								l3.request_id,
								l3.database_name,
								COALESCE(l3.object_name, '(null)'),
								l3.schema_name
							FOR XML
								PATH(''),
								TYPE
						) AS [Database/Objects]
					FROM #locks AS l1
					WHERE
						l1.session_id = s.session_id
						AND l1.request_id = s.request_id
						AND l1.start_time IN (s.start_time, s.last_request_start_time)
						AND s.recursion = 1
					GROUP BY 
						l1.session_id,
						l1.request_id,
						l1.database_name
					FOR XML
						PATH(''),
						TYPE
				)
			FROM #sessions s
			OPTION (KEEPFIXED PLAN);
		END;

		IF 
			@find_block_leaders = 1
			AND @recursion = 1
			AND @output_column_list LIKE '%|[blocked_session_count|]%' ESCAPE '|'
		BEGIN;
			WITH
			blockers AS
			(
				SELECT
					session_id,
					session_id AS top_level_session_id,
					CONVERT(VARCHAR(8000), '.' + CONVERT(VARCHAR(8000), session_id) + '.') AS the_path
				FROM #sessions
				WHERE
					recursion = 1

				UNION ALL

				SELECT
					s.session_id,
					b.top_level_session_id,
					CONVERT(VARCHAR(8000), b.the_path + CONVERT(VARCHAR(8000), s.session_id) + '.') AS the_path
				FROM blockers AS b
				JOIN #sessions AS s ON
					s.blocking_session_id = b.session_id
					AND s.recursion = 1
					AND b.the_path NOT LIKE '%.' + CONVERT(VARCHAR(8000), s.session_id) + '.%' COLLATE Latin1_General_Bin2
			)
			UPDATE s
			SET
				s.blocked_session_count = x.blocked_session_count
			FROM #sessions AS s
			JOIN
			(
				SELECT
					b.top_level_session_id AS session_id,
					COUNT(*) - 1 AS blocked_session_count
				FROM blockers AS b
				GROUP BY
					b.top_level_session_id
			) x ON
				s.session_id = x.session_id
			WHERE
				s.recursion = 1;
		END;

		IF
			@get_task_info = 2
			AND @output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
			AND @recursion = 1
		BEGIN;
			CREATE TABLE #blocked_requests
			(
				session_id SMALLINT NOT NULL,
				request_id INT NOT NULL,
				database_name sysname NOT NULL,
				object_id INT,
				hobt_id BIGINT,
				schema_id INT,
				schema_name sysname NULL,
				object_name sysname NULL,
				query_error NVARCHAR(2048),
				PRIMARY KEY (database_name, session_id, request_id)
			);

			CREATE STATISTICS s_database_name ON #blocked_requests (database_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_schema_name ON #blocked_requests (schema_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_object_name ON #blocked_requests (object_name)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
			CREATE STATISTICS s_query_error ON #blocked_requests (query_error)
			WITH SAMPLE 0 ROWS, NORECOMPUTE;
		
			INSERT #blocked_requests
			(
				session_id,
				request_id,
				database_name,
				object_id,
				hobt_id,
				schema_id
			)
			SELECT
				session_id,
				request_id,
				database_name,
				object_id,
				hobt_id,
				CONVERT(INT, SUBSTRING(schema_node, CHARINDEX(' = ', schema_node) + 3, LEN(schema_node))) AS schema_id
			FROM
			(
				SELECT
					session_id,
					request_id,
					agent_nodes.agent_node.value('(database_name/text())[1]', 'sysname') AS database_name,
					agent_nodes.agent_node.value('(object_id/text())[1]', 'int') AS object_id,
					agent_nodes.agent_node.value('(hobt_id/text())[1]', 'bigint') AS hobt_id,
					agent_nodes.agent_node.value('(metadata_resource/text()[.="SCHEMA"]/../../metadata_class_id/text())[1]', 'varchar(100)') AS schema_node
				FROM #sessions AS s
				CROSS APPLY s.additional_info.nodes('//block_info') AS agent_nodes (agent_node)
				WHERE
					s.recursion = 1
			) AS t
			WHERE
				t.database_name IS NOT NULL
				AND
				(
					t.object_id IS NOT NULL
					OR t.hobt_id IS NOT NULL
					OR t.schema_node IS NOT NULL
				);
			
			DECLARE blocks_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR
				SELECT DISTINCT
					database_name
				FROM #blocked_requests;
				
			OPEN blocks_cursor;
			
			FETCH NEXT FROM blocks_cursor
			INTO 
				@database_name;
			
			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					SET @sql_n = 
						CONVERT(NVARCHAR(MAX), '') +
						'UPDATE b ' +
						'SET ' +
							'b.schema_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										's.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								'), ' +
							'b.object_name = ' +
								'REPLACE ' +
								'( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
									'REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( ' +
										'o.name COLLATE Latin1_General_Bin2, ' +
										'NCHAR(31),N''?''),NCHAR(30),N''?''),NCHAR(29),N''?''),NCHAR(28),N''?''),NCHAR(27),N''?''),NCHAR(26),N''?''),NCHAR(25),N''?''),NCHAR(24),N''?''),NCHAR(23),N''?''),NCHAR(22),N''?''), ' +
										'NCHAR(21),N''?''),NCHAR(20),N''?''),NCHAR(19),N''?''),NCHAR(18),N''?''),NCHAR(17),N''?''),NCHAR(16),N''?''),NCHAR(15),N''?''),NCHAR(14),N''?''),NCHAR(12),N''?''), ' +
										'NCHAR(11),N''?''),NCHAR(8),N''?''),NCHAR(7),N''?''),NCHAR(6),N''?''),NCHAR(5),N''?''),NCHAR(4),N''?''),NCHAR(3),N''?''),NCHAR(2),N''?''),NCHAR(1),N''?''), ' +
									'NCHAR(0), ' +
									N''''' ' +
								') ' +
						'FROM #blocked_requests AS b ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.partitions AS p ON ' +
							'p.hobt_id = b.hobt_id ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.objects AS o ON ' +
							'o.object_id = COALESCE(p.object_id, b.object_id) ' +
						'LEFT OUTER JOIN ' + QUOTENAME(@database_name) + '.sys.schemas AS s ON ' +
							's.schema_id = COALESCE(o.schema_id, b.schema_id) ' +
						'WHERE ' +
							'b.database_name = @database_name; ';
					
					EXEC sp_executesql
						@sql_n,
						N'@database_name sysname',
						@database_name;
				END TRY
				BEGIN CATCH;
					UPDATE #blocked_requests
					SET
						query_error = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									CONVERT
									(
										NVARCHAR(MAX), 
										ERROR_MESSAGE() COLLATE Latin1_General_Bin2
									),
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N''
							)
					WHERE
						database_name = @database_name;
				END CATCH;

				FETCH NEXT FROM blocks_cursor
				INTO
					@database_name;
			END;
			
			CLOSE blocks_cursor;
			DEALLOCATE blocks_cursor;
			
			UPDATE s
			SET
				additional_info.modify
				('
					insert <schema_name>{sql:column("b.schema_name")}</schema_name>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.schema_name IS NOT NULL;

			UPDATE s
			SET
				additional_info.modify
				('
					insert <object_name>{sql:column("b.object_name")}</object_name>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.object_name IS NOT NULL;

			UPDATE s
			SET
				additional_info.modify
				('
					insert <query_error>{sql:column("b.query_error")}</query_error>
					as last
					into (/additional_info/block_info)[1]
				')
			FROM #sessions AS s
			INNER JOIN #blocked_requests AS b ON
				b.session_id = s.session_id
				AND b.request_id = s.request_id
				AND s.recursion = 1
			WHERE
				b.query_error IS NOT NULL;
		END;

		IF
			@output_column_list LIKE '%|[program_name|]%' ESCAPE '|'
			AND @output_column_list LIKE '%|[additional_info|]%' ESCAPE '|'
			AND @recursion = 1
		BEGIN;
			DECLARE @job_id UNIQUEIDENTIFIER;
			DECLARE @step_id INT;

			DECLARE agent_cursor
			CURSOR LOCAL FAST_FORWARD
			FOR 
				SELECT
					s.session_id,
					agent_nodes.agent_node.value('(job_id/text())[1]', 'uniqueidentifier') AS job_id,
					agent_nodes.agent_node.value('(step_id/text())[1]', 'int') AS step_id
				FROM #sessions AS s
				CROSS APPLY s.additional_info.nodes('//agent_job_info') AS agent_nodes (agent_node)
				WHERE
					s.recursion = 1
			OPTION (KEEPFIXED PLAN);
			
			OPEN agent_cursor;

			FETCH NEXT FROM agent_cursor
			INTO 
				@session_id,
				@job_id,
				@step_id;

			WHILE @@FETCH_STATUS = 0
			BEGIN;
				BEGIN TRY;
					DECLARE @job_name sysname;
					SET @job_name = NULL;
					DECLARE @step_name sysname;
					SET @step_name = NULL;
					
					SELECT
						@job_name = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									j.name,
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N'?'
							),
						@step_name = 
							REPLACE
							(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
								REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
									s.step_name,
									NCHAR(31),N'?'),NCHAR(30),N'?'),NCHAR(29),N'?'),NCHAR(28),N'?'),NCHAR(27),N'?'),NCHAR(26),N'?'),NCHAR(25),N'?'),NCHAR(24),N'?'),NCHAR(23),N'?'),NCHAR(22),N'?'),
									NCHAR(21),N'?'),NCHAR(20),N'?'),NCHAR(19),N'?'),NCHAR(18),N'?'),NCHAR(17),N'?'),NCHAR(16),N'?'),NCHAR(15),N'?'),NCHAR(14),N'?'),NCHAR(12),N'?'),
									NCHAR(11),N'?'),NCHAR(8),N'?'),NCHAR(7),N'?'),NCHAR(6),N'?'),NCHAR(5),N'?'),NCHAR(4),N'?'),NCHAR(3),N'?'),NCHAR(2),N'?'),NCHAR(1),N'?'),
								NCHAR(0),
								N'?'
							)
					FROM msdb.dbo.sysjobs AS j
					INNER JOIN msdb..sysjobsteps AS s ON
						j.job_id = s.job_id
					WHERE
						j.job_id = @job_id
						AND s.step_id = @step_id;

					IF @job_name IS NOT NULL
					BEGIN;
						UPDATE s
						SET
							additional_info.modify
							('
								insert text{sql:variable("@job_name")}
								into (/additional_info/agent_job_info/job_name)[1]
							')
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
						OPTION (KEEPFIXED PLAN);
						
						UPDATE s
						SET
							additional_info.modify
							('
								insert text{sql:variable("@step_name")}
								into (/additional_info/agent_job_info/step_name)[1]
							')
						FROM #sessions AS s
						WHERE 
							s.session_id = @session_id
						OPTION (KEEPFIXED PLAN);
					END;
				END TRY
				BEGIN CATCH;
					DECLARE @msdb_error_message NVARCHAR(256);
					SET @msdb_error_message = ERROR_MESSAGE();
				
					UPDATE s
					SET
						additional_info.modify
						('
							insert <msdb_query_error>{sql:variable("@msdb_error_message")}</msdb_query_error>
							as last
							into (/additional_info/agent_job_info)[1]
						')
					FROM #sessions AS s
					WHERE 
						s.session_id = @session_id
						AND s.recursion = 1
					OPTION (KEEPFIXED PLAN);
				END CATCH;

				FETCH NEXT FROM agent_cursor
				INTO 
					@session_id,
					@job_id,
					@step_id;
			END;

			CLOSE agent_cursor;
			DEALLOCATE agent_cursor;
		END; 
		
		IF 
			@delta_interval > 0 
			AND @recursion <> 1
		BEGIN;
			SET @recursion = 1;

			DECLARE @delay_time CHAR(12);
			SET @delay_time = CONVERT(VARCHAR, DATEADD(second, @delta_interval, 0), 114);
			WAITFOR DELAY @delay_time;

			GOTO REDO;
		END;
	END;

	SET @sql = 
		--Outer column list
		CONVERT
		(
			VARCHAR(MAX),
			CASE
				WHEN 
					@destination_table <> '' 
					AND @return_schema = 0 
						THEN 'INSERT ' + @destination_table + ' '
				ELSE ''
			END +
			'SELECT ' +
				@output_column_list + ' ' +
			CASE @return_schema
				WHEN 1 THEN 'INTO #session_schema '
				ELSE ''
			END
		--End outer column list
		) + 
		--Inner column list
		CONVERT
		(
			VARCHAR(MAX),
			'FROM ' +
			'( ' +
				'SELECT ' +
					'session_id, ' +
					--[dd hh:mm:ss.mss]
					CASE
						WHEN @format_output IN (1, 2) THEN
							'CASE ' +
								'WHEN elapsed_time < 0 THEN ' +
									'RIGHT ' +
									'( ' +
										'REPLICATE(''0'', max_elapsed_length) + CONVERT(VARCHAR, (-1 * elapsed_time) / 86400), ' +
										'max_elapsed_length ' +
									') + ' +
										'RIGHT ' +
										'( ' +
											'CONVERT(VARCHAR, DATEADD(second, (-1 * elapsed_time), 0), 120), ' +
											'9 ' +
										') + ' +
										'''.000'' ' +
								'ELSE ' +
									'RIGHT ' +
									'( ' +
										'REPLICATE(''0'', max_elapsed_length) + CONVERT(VARCHAR, elapsed_time / 86400000), ' +
										'max_elapsed_length ' +
									') + ' +
										'RIGHT ' +
										'( ' +
											'CONVERT(VARCHAR, DATEADD(second, elapsed_time / 1000, 0), 120), ' +
											'9 ' +
										') + ' +
										'''.'' + ' + 
										'RIGHT(''000'' + CONVERT(VARCHAR, elapsed_time % 1000), 3) ' +
							'END AS [dd hh:mm:ss.mss], '
						ELSE
							''
					END +
					--[dd hh:mm:ss.mss (avg)] / avg_elapsed_time
					CASE 
						WHEN  @format_output IN (1, 2) THEN 
							'RIGHT ' +
							'( ' +
								'''00'' + CONVERT(VARCHAR, avg_elapsed_time / 86400000), ' +
								'2 ' +
							') + ' +
								'RIGHT ' +
								'( ' +
									'CONVERT(VARCHAR, DATEADD(second, avg_elapsed_time / 1000, 0), 120), ' +
									'9 ' +
								') + ' +
								'''.'' + ' +
								'RIGHT(''000'' + CONVERT(VARCHAR, avg_elapsed_time % 1000), 3) AS [dd hh:mm:ss.mss (avg)], '
						ELSE
							'avg_elapsed_time, '
					END +
					--physical_io
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_io))) OVER() - LEN(CONVERT(VARCHAR, physical_io))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io), 1), 19)) AS '
						ELSE ''
					END + 'physical_io, ' +
					--reads
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, reads))) OVER() - LEN(CONVERT(VARCHAR, reads))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads), 1), 19)) AS '
						ELSE ''
					END + 'reads, ' +
					--physical_reads
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_reads))) OVER() - LEN(CONVERT(VARCHAR, physical_reads))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads), 1), 19)) AS '
						ELSE ''
					END + 'physical_reads, ' +
					--writes
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, writes))) OVER() - LEN(CONVERT(VARCHAR, writes))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes), 1), 19)) AS '
						ELSE ''
					END + 'writes, ' +
					--tempdb_allocations
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_allocations))) OVER() - LEN(CONVERT(VARCHAR, tempdb_allocations))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations), 1), 19)) AS '
						ELSE ''
					END + 'tempdb_allocations, ' +
					--tempdb_current
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_current))) OVER() - LEN(CONVERT(VARCHAR, tempdb_current))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current), 1), 19)) AS '
						ELSE ''
					END + 'tempdb_current, ' +
					--CPU
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, CPU))) OVER() - LEN(CONVERT(VARCHAR, CPU))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU), 1), 19)) AS '
						ELSE ''
					END + 'CPU, ' +
					--context_switches
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, context_switches))) OVER() - LEN(CONVERT(VARCHAR, context_switches))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches), 1), 19)) AS '
						ELSE ''
					END + 'context_switches, ' +
					--used_memory
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, used_memory))) OVER() - LEN(CONVERT(VARCHAR, used_memory))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory), 1), 19)) AS '
						ELSE ''
					END + 'used_memory, ' +
					CASE
						WHEN @output_column_list LIKE '%|_delta|]%' ESCAPE '|' THEN
							--physical_io_delta			
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND physical_io_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_io_delta))) OVER() - LEN(CONVERT(VARCHAR, physical_io_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io_delta), 1), 19)) ' 
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_io_delta), 1), 19)) '
											ELSE 'physical_io_delta '
										END +
								'ELSE NULL ' +
							'END AS physical_io_delta, ' +
							--reads_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND reads_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, reads_delta))) OVER() - LEN(CONVERT(VARCHAR, reads_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, reads_delta), 1), 19)) '
											ELSE 'reads_delta '
										END +
								'ELSE NULL ' +
							'END AS reads_delta, ' +
							--physical_reads_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND physical_reads_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, physical_reads_delta))) OVER() - LEN(CONVERT(VARCHAR, physical_reads_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, physical_reads_delta), 1), 19)) '
											ELSE 'physical_reads_delta '
										END + 
								'ELSE NULL ' +
							'END AS physical_reads_delta, ' +
							--writes_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND writes_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, writes_delta))) OVER() - LEN(CONVERT(VARCHAR, writes_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, writes_delta), 1), 19)) '
											ELSE 'writes_delta '
										END + 
								'ELSE NULL ' +
							'END AS writes_delta, ' +
							--tempdb_allocations_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND tempdb_allocations_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_allocations_delta))) OVER() - LEN(CONVERT(VARCHAR, tempdb_allocations_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_allocations_delta), 1), 19)) '
											ELSE 'tempdb_allocations_delta '
										END + 
								'ELSE NULL ' +
							'END AS tempdb_allocations_delta, ' +
							--tempdb_current_delta
							--this is the only one that can (legitimately) go negative 
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tempdb_current_delta))) OVER() - LEN(CONVERT(VARCHAR, tempdb_current_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tempdb_current_delta), 1), 19)) '
											ELSE 'tempdb_current_delta '
										END + 
								'ELSE NULL ' +
							'END AS tempdb_current_delta, ' +
							--CPU_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
										'THEN ' +
											'CASE ' +
												'WHEN ' +
													'thread_CPU_delta > CPU_delta ' +
													'AND thread_CPU_delta > 0 ' +
														'THEN ' +
															CASE @format_output
																WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, thread_CPU_delta + CPU_delta))) OVER() - LEN(CONVERT(VARCHAR, thread_CPU_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, thread_CPU_delta), 1), 19)) '
																WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, thread_CPU_delta), 1), 19)) '
																ELSE 'thread_CPU_delta '
															END + 
												'WHEN CPU_delta >= 0 THEN ' +
													CASE @format_output
														WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, thread_CPU_delta + CPU_delta))) OVER() - LEN(CONVERT(VARCHAR, CPU_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU_delta), 1), 19)) '
														WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, CPU_delta), 1), 19)) '
														ELSE 'CPU_delta '
													END + 
												'ELSE NULL ' +
											'END ' +
								'ELSE ' +
									'NULL ' +
							'END AS CPU_delta, ' +
							--context_switches_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND context_switches_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, context_switches_delta))) OVER() - LEN(CONVERT(VARCHAR, context_switches_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, context_switches_delta), 1), 19)) '
											ELSE 'context_switches_delta '
										END + 
								'ELSE NULL ' +
							'END AS context_switches_delta, ' +
							--used_memory_delta
							'CASE ' +
								'WHEN ' +
									'first_request_start_time = last_request_start_time ' + 
									'AND num_events = 2 ' +
									'AND used_memory_delta >= 0 ' +
										'THEN ' +
										CASE @format_output
											WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, used_memory_delta))) OVER() - LEN(CONVERT(VARCHAR, used_memory_delta))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory_delta), 1), 19)) '
											WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, used_memory_delta), 1), 19)) '
											ELSE 'used_memory_delta '
										END + 
								'ELSE NULL ' +
							'END AS used_memory_delta, '
						ELSE ''
					END +
					--tasks
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, tasks))) OVER() - LEN(CONVERT(VARCHAR, tasks))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tasks), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, tasks), 1), 19)) '
						ELSE ''
					END + 'tasks, ' +
					'status, ' +
					'wait_info, ' +
					'locks, ' +
					'tran_start_time, ' +
					'LEFT(tran_log_writes, LEN(tran_log_writes) - 1) AS tran_log_writes, ' +
					--open_tran_count
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, open_tran_count))) OVER() - LEN(CONVERT(VARCHAR, open_tran_count))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, open_tran_count), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, open_tran_count), 1), 19)) AS '
						ELSE ''
					END + 'open_tran_count, ' +
					--sql_command
					CASE @format_output 
						WHEN 0 THEN 'REPLACE(REPLACE(CONVERT(NVARCHAR(MAX), sql_command), ''<?query --''+CHAR(13)+CHAR(10), ''''), CHAR(13)+CHAR(10)+''--?>'', '''') AS '
						ELSE ''
					END + 'sql_command, ' +
					--sql_text
					CASE @format_output 
						WHEN 0 THEN 'REPLACE(REPLACE(CONVERT(NVARCHAR(MAX), sql_text), ''<?query --''+CHAR(13)+CHAR(10), ''''), CHAR(13)+CHAR(10)+''--?>'', '''') AS '
						ELSE ''
					END + 'sql_text, ' +
					'query_plan, ' +
					'blocking_session_id, ' +
					--blocked_session_count
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, blocked_session_count))) OVER() - LEN(CONVERT(VARCHAR, blocked_session_count))) + LEFT(CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1), 19)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, LEFT(CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1), 19)) AS '
						ELSE ''
					END + 'blocked_session_count, ' +
					--percent_complete
					CASE @format_output
						WHEN 1 THEN 'CONVERT(VARCHAR, SPACE(MAX(LEN(CONVERT(VARCHAR, CONVERT(MONEY, percent_complete), 2))) OVER() - LEN(CONVERT(VARCHAR, CONVERT(MONEY, percent_complete), 2))) + CONVERT(CHAR(22), CONVERT(MONEY, percent_complete), 2)) AS '
						WHEN 2 THEN 'CONVERT(VARCHAR, CONVERT(CHAR(22), CONVERT(MONEY, blocked_session_count), 1)) AS '
						ELSE ''
					END + 'percent_complete, ' +
					'host_name, ' +
					'login_name, ' +
					'database_name, ' +
					'program_name, ' +
					'additional_info, ' +
					'start_time, ' +
					'login_time, ' +
					'CASE ' +
						'WHEN status = N''sleeping'' THEN NULL ' +
						'ELSE request_id ' +
					'END AS request_id, ' +
					'GETDATE() AS collection_time '
		--End inner column list
		) +
		--Derived table and INSERT specification
		CONVERT
		(
			VARCHAR(MAX),
				'FROM ' +
				'( ' +
					'SELECT TOP(2147483647) ' +
						'*, ' +
						'CASE ' +
							'MAX ' +
							'( ' +
								'LEN ' +
								'( ' +
									'CONVERT ' +
									'( ' +
										'VARCHAR, ' +
										'CASE ' +
											'WHEN elapsed_time < 0 THEN ' +
												'(-1 * elapsed_time) / 86400 ' +
											'ELSE ' +
												'elapsed_time / 86400000 ' +
										'END ' +
									') ' +
								') ' +
							') OVER () ' +
								'WHEN 1 THEN 2 ' +
								'ELSE ' +
									'MAX ' +
									'( ' +
										'LEN ' +
										'( ' +
											'CONVERT ' +
											'( ' +
												'VARCHAR, ' +
												'CASE ' +
													'WHEN elapsed_time < 0 THEN ' +
														'(-1 * elapsed_time) / 86400 ' +
													'ELSE ' +
														'elapsed_time / 86400000 ' +
												'END ' +
											') ' +
										') ' +
									') OVER () ' +
						'END AS max_elapsed_length, ' +
						CASE
							WHEN @output_column_list LIKE '%|_delta|]%' ESCAPE '|' THEN
								'MAX(physical_io * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(physical_io * recursion) OVER (PARTITION BY session_id, request_id) AS physical_io_delta, ' +
								'MAX(reads * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(reads * recursion) OVER (PARTITION BY session_id, request_id) AS reads_delta, ' +
								'MAX(physical_reads * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(physical_reads * recursion) OVER (PARTITION BY session_id, request_id) AS physical_reads_delta, ' +
								'MAX(writes * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(writes * recursion) OVER (PARTITION BY session_id, request_id) AS writes_delta, ' +
								'MAX(tempdb_allocations * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(tempdb_allocations * recursion) OVER (PARTITION BY session_id, request_id) AS tempdb_allocations_delta, ' +
								'MAX(tempdb_current * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(tempdb_current * recursion) OVER (PARTITION BY session_id, request_id) AS tempdb_current_delta, ' +
								'MAX(CPU * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(CPU * recursion) OVER (PARTITION BY session_id, request_id) AS CPU_delta, ' +
								'MAX(thread_CPU_snapshot * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(thread_CPU_snapshot * recursion) OVER (PARTITION BY session_id, request_id) AS thread_CPU_delta, ' +
								'MAX(context_switches * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(context_switches * recursion) OVER (PARTITION BY session_id, request_id) AS context_switches_delta, ' +
								'MAX(used_memory * recursion) OVER (PARTITION BY session_id, request_id) + ' +
									'MIN(used_memory * recursion) OVER (PARTITION BY session_id, request_id) AS used_memory_delta, ' +
								'MIN(last_request_start_time) OVER (PARTITION BY session_id, request_id) AS first_request_start_time, '
							ELSE ''
						END +
						'COUNT(*) OVER (PARTITION BY session_id, request_id) AS num_events ' +
					'FROM #sessions AS s1 ' +
					CASE 
						WHEN @sort_order = '' THEN ''
						ELSE
							'ORDER BY ' +
								@sort_order
					END +
				') AS s ' +
				'WHERE ' +
					's.recursion = 1 ' +
			') x ' +
			'OPTION (KEEPFIXED PLAN); ' +
			'' +
			CASE @return_schema
				WHEN 1 THEN
					'SET @schema = ' +
						'''CREATE TABLE <table_name> ( '' + ' +
							'STUFF ' +
							'( ' +
								'( ' +
									'SELECT ' +
										''','' + ' +
										'QUOTENAME(COLUMN_NAME) + '' '' + ' +
										'DATA_TYPE + ' + 
										'CASE ' +
											'WHEN DATA_TYPE LIKE ''%char'' THEN ''('' + COALESCE(NULLIF(CONVERT(VARCHAR, CHARACTER_MAXIMUM_LENGTH), ''-1''), ''max'') + '') '' ' +
											'ELSE '' '' ' +
										'END + ' +
										'CASE IS_NULLABLE ' +
											'WHEN ''NO'' THEN ''NOT '' ' +
											'ELSE '''' ' +
										'END + ''NULL'' AS [text()] ' +
									'FROM tempdb.INFORMATION_SCHEMA.COLUMNS ' +
									'WHERE ' +
										'TABLE_NAME = (SELECT name FROM tempdb.sys.objects WHERE object_id = OBJECT_ID(''tempdb..#session_schema'')) ' +
										'ORDER BY ' +
											'ORDINAL_POSITION ' +
									'FOR XML ' +
										'PATH('''') ' +
								'), + ' +
								'1, ' +
								'1, ' +
								''''' ' +
							') + ' +
						''')''; ' 
				ELSE ''
			END
		--End derived table and INSERT specification
		);

	SET @sql_n = CONVERT(NVARCHAR(MAX), @sql);

	EXEC sp_executesql
		@sql_n,
		N'@schema VARCHAR(MAX) OUTPUT',
		@schema OUTPUT;
END;
go


CREATE PROCEDURE [dbo].[prdScanWIPSP_MOD2] (@VAP varchar(20), @SVAP varchar(20), @WS varchar(10), @PTNo varchar(13), @UserId varchar(20), @ScanDt datetime, @Authorized nvarchar(50), @DayNightShft varchar(15),@sWSIss varchar(10)
											,@Qty INT, @Reject bit = 0,@ElqcSeq int = 0)  
AS  

BEGIN  
	SET NOCOUNT ON
	BEGIN TRAN

	Declare @MONo				Varchar(20)        
	Declare @LayNo				Varchar(20)        
	--Declare @Qty				Int  
	Declare @MOVAP				Varchar(20)        
	Declare @MOSVAP				Varchar(20)  
	Declare @LastScannedVAP		Varchar(20)
	Declare @LastScannedSVAP	Varchar(20)
	Declare @GVAP	Varchar(20)
	Declare @LastScannedSeq		Smallint 
	Declare @AdjQty				Int  
	Declare @CountWIPVAPSVAP	Int
	Declare @CountMOVAPSVAP		Int
	Declare @LoadType			Bit
	Declare @DONo varchar(20)
	Declare @subVAP varchar(20)
	Declare @subSVAP varchar(20)
	Declare @subSeq varchar(100)
	Declare @subSeq2 varchar(100)

	Declare @subChkVAP varchar(20)
	Declare @subChkSVAP varchar(20)
	Declare @subChkSeq varchar(100)
	Declare @subChkSeq2 varchar(100)
	Declare @PrevGVAPCnt2 int
	Declare @subReq bit
	Declare @return nvarchar(100)
	Declare @rRfid bit
	Declare @return2 nvarchar(100)
	Declare @rRfid2 bit
	Declare @DisplayLvl1 nvarchar(100)
	Declare @DisplayLvl2 nvarchar(100)


	Declare @SubCon   bit
	Declare @CompBndl bit
	Declare @SucCnt int
	Declare @SucCnt2 int
	Declare @PrevGVAPCnt int
	Declare @Chkpntmsg nvarchar(100)
	Declare @Chkpntmsg2 nvarchar(100)
	Declare @DORcvVAP varchar(20)
	Declare @DOIssVAP varchar(20)
	Declare @LastCheckpointDt datetime
	Declare @PrevVAP varchar(20)
	Declare @PrevSVAP varchar(20)

	DECLARE @start_index INT
	DECLARE @end_index INT
	DECLARE @Full INT
	DECLARE @SCANQTY INT
	DECLARE @AdjDate datetime
	DECLARE @PVAP VARCHAR(20)
	DECLARE @PSVAP VARCHAR(20)
	DECLARE @PQTY INT
	Declare @rVAP varchar(50)
	Declare @PAdjQty INT
	Declare @RejectQty INT 
	Declare @ELQC_VAP varchar(20)
	DECLARE @BundleQty	INT

	

	If (@Authorized = 'RFID')
	Begin
		Select 'Successful'
		COMMIT TRAN
		RETURN  
	End
	Else
	Begin
		Select 'Successful', 0 As Error            
		COMMIT TRAN
		RETURN  
	End

End


go



CREATE PROCEDURE [dbo].[GetNoRangeNo] 
	-- Add the parameters for the stored procedure here
	@NoRangeCd varchar(50), 
	@USERID nvarchar(50)
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @No				AS VARCHAR(18)
	DECLARE @Count			AS INT
	DECLARE @HasKey			AS BIT
	DECLARE @KeyNoRangeCd	AS VARCHAR(50)
	DECLARE @KeyNo			AS VARCHAR(50)
	
	SELECT @Count = COUNT('X') FROM m_No_Range WHERE NoRange = @NoRangeCd AND Active = 1
	IF @Count <> 0
	BEGIN
		BEGIN TRANSACTION

		UPDATE m_No_Range WITH (ROWLOCK)
		SET
			[CurrentNo]=RIGHT(REPLICATE('0',LEN((SELECT [CurrentNo] FROM m_No_Range WHERE [IsExternal]=0 AND [NoRange]=@NoRangeCd AND CAST([CurrentNo] AS BIGINT)>=[NoRangeFrom] AND CAST([CurrentNo] AS BIGINT)<=[NoRangeTo] AND LEN([CurrentNo]) <= LEN([NoRangeTo]))))
			+CAST(((SELECT [CurrentNo] FROM m_No_Range WHERE [IsExternal]=0 AND [NoRange]=@NoRangeCd AND CAST([CurrentNo] AS BIGINT)>=[NoRangeFrom] AND CAST([CurrentNo] AS BIGINT)<=[NoRangeTo] AND LEN([CurrentNo]) <= LEN([NoRangeTo]))+CAST(1 AS BIGINT)) AS VARCHAR),
			LEN((SELECT [CurrentNo] FROM m_No_Range WHERE [IsExternal]=0 AND [NoRange]=@NoRangeCd AND CAST([CurrentNo] AS BIGINT)>=[NoRangeFrom] AND CAST([CurrentNo] AS BIGINT)<=[NoRangeTo] AND LEN([CurrentNo]) <= LEN([NoRangeTo])))),
			[time_Updated]=getdate(), [Updated_By]=@USERID
		WHERE
			[NoRange]=@NoRangeCd

		IF (@@ERROR > 0)
		BEGIN
			ROLLBACK TRANSACTION
			SELECT 0
			RETURN
		END

		COMMIT TRANSACTION

		SELECT @No=[CurrentNo] FROM m_No_Range WHERE [IsExternal]=0 AND [NoRange]=@NoRangeCd AND 
			CAST([CurrentNo] AS BIGINT)>=[NoRangeFrom] AND CAST([CurrentNo] as bigint)<=[NoRangeTo] AND
			LEN([CurrentNo]) <= LEN([NoRangeTo])
   
		SELECT @HasKey=HasKey, @KeyNoRangeCd=KeyNoRange FROM m_No_Range WHERE NoRange=@NoRangeCd AND Active=1
		IF @HasKey<>0 AND ISNULL(@KeyNoRangeCd,'')<>'' 
		BEGIN
			SELECT @KeyNo = NoRangeFrom FROM m_No_Range WHERE NoRange=@KeyNoRangeCd
			IF NOT EXISTS(SELECT 'X' FROM m_No_Range_Key WHERE NoRange = @KeyNoRangeCd AND RangeKey = @No)
				INSERT INTO m_No_Range_Key (NoRange,RangeKey,CurrentNo,time_Created,Created_By)    
					VALUES (@KeyNoRangeCd,@No,@KeyNo,GETDATE(),@USERID)    		
		END
	END
		
	SELECT @No
	
END

go

CREATE procedure usp_fg_calculate_loading_plan_qty
	@loadingPlanId varchar(20) = '0'
AS
	BEGIN TRY
	IF(@loadingPlanId = '0')
			BEGIN
					update fg_loading_plan_pl set loading_plan_qty = isnull(a.loading_plan_qty,0), need_recalculate = 0
					from (
							select a.id,  loading_plan_qty = sum(b.carton_qty)
							from fg_loading_plan_pl a (nolock)
							inner join fg_carton b (nolock) on a.loading_plan_id = b.loading_plan_id
							where need_recalculate = 1
							group by a.loading_plan_id, a.id
					) A
					INNER JOIN fg_loading_plan_pl b on a.id = b.id
			END
	ELSE
			BEGIN
					update fg_loading_plan_pl set loading_plan_qty = isnull(a.loading_plan_qty,0), need_recalculate = 0
					from (
							select a.id,  loading_plan_qty = sum(b.carton_qty)
							from fg_loading_plan_pl a (nolock)
							inner join fg_carton b (nolock) on a.loading_plan_id = b.loading_plan_id
							inner join fg_loading_plan f (nolock) on a.loading_plan_id = f.id
							where f.id in (@loadingPlanId)
							group by a.loading_plan_id, a.id
					) A
					INNER JOIN fg_loading_plan_pl b on a.id = b.id
			END

		select code = 'success', description = 'success'
	END TRY
	BEGIN CATCH
		select code = 'error', description = 'error'
	END CATCH
go


  
CREATE PROCEDURE [dbo].[prdGenerateLayingPTSP]    				 
----exec prdGenerateLayingPTSPTest '7524978001','2','slacsamana'    
   @MONo	varchar(50),     
   @Lay		varchar(50),                                     
   @User	varchar(15)     
As    
Begin    
 Set Nocount on;    
    
	Declare @MfgLoc	varchar(5)
	SELECT @MfgLoc = Mfg_Loc_Short_Cd from m_Mfg_Locs Where id = (Select Mfg_Loc From MO_Hdr Where MONo = @MONo)

	IF EXISTS(SELECT 'X' FROM Control_File WHERE CTRLCUTQTY = 1)
	BEGIN
			DECLARE @EXCESS BIT = 0,@REPLACEMENT BIT = 0
			SELECT 
				@EXCESS = Excess,
				@REPLACEMENT = Replacement
			FROM Laying_Hdr 
			WHERE MONO = @MONo AND LayNo = @Lay

			IF EXISTS(SELECT 'X' FROM dbo.prdCheckCutqty_UDF(@MONo,@Lay,'0',@EXCESS,@REPLACEMENT,1) WHERE ERROR = 1)
			BEGIN
				SELECT MSG as description,'error' as code FROM dbo.prdCheckCutqty_UDF(@MONo,@Lay,'0',@EXCESS,@REPLACEMENT,1) WHERE ERROR = 1
				RETURN
			END
	END

					  Declare @LastBundle int     
					  Declare @PTNo Varchar(13)
					  If Not Exists (Select 'x' From Laying_Hdr Where MONo = @MONo And LayNo = @Lay And Status = 'G')
					  Begin
							If Not Exists (Select Bundle_No_To From Laying_Hdr Where MONo = @MONo)                      
							Begin                      
								Set @LastBundle = 0                      
							End                      
							Else                      
							Begin                      
					
								Select @LastBundle = max(isnull(Bundle_No_To,0)) From Laying_Hdr Where MONo = @MONo
							     
							End     
					  End
					  Else
					  Begin
						IF EXISTS(SELECT TOP 1 'X' FROM OB WHERE WBT = 1 AND MONO = @MONO)
						BEGIN
							Select @LastBundle = Bundle_No_From From Laying_Hdr Where MONo = @MONo And LayNo = @Lay      
							Set @LastBundle = @LastBundle - 1
						END
						ELSE
						BEGIN
							Select @LastBundle = Bundle_No_From From Laying_Hdr Where MONo = @MONo And LayNo = @Lay      
						END
						          
					  End
					  
						   Declare @SizeWONo  char(20)                
						   Declare @SizeLay  varchar(max)             
						   Declare @SizeDesc  nvarchar(max)                
						   Declare @ColorDesc  nvarchar(max)     
						   Declare @BundleQty  int                           
						   Declare @Seq  int       
						   Declare @LayQty   int          
						   Declare @SeqPly	int      
						   Declare @CounterSize int       
						   Declare @mSizeDesc  nvarchar(max)                
						   Declare @mColorDesc  nvarchar(max)  
						   Declare @lColorDesc  nvarchar(max) 
						    
						   Set @mSizeDesc = ''
						   Set @mColorDesc = ''
						   Set @CounterSize = 1     
						   Set @Seq = 0 

						   Declare BinInfoSizes Cursor For  

								SELECT 
								Size,Qty
								FROM 
								Laying_Sizes
								WHERE MONo = @MONo
								AND LayNo = @Lay
								ORDER BY Seq
						         		           
							Open BinInfoSizes                      
							Fetch Next From BinInfoSizes Into @SizeDesc,@BundleQty
							While @@FETCH_STATUS = 0                
							Begin     
	
								While @CounterSize <= @BundleQty
								Begin


									DECLARE BinInfoPly Cursor For

										SELECT 
										Seq,Color
										FROM Laying_Ply_Batch
										WHERE MONo = @MONo
										AND LayNo = @Lay
										ORDER BY Seq

									Open BinInfoPly                      
									Fetch Next From BinInfoPly Into @SeqPly,@ColorDesc
									While @@FETCH_STATUS = 0                
									Begin     
										
										Set @LastBundle = @LastBundle + 1
										Set @Seq = @Seq + 1
										
										DECLARE @Return TABLE( [No] VARCHAR(18) )
										INSERT @Return([No]) EXEC GetNoRangeNo 'PT', @User
										SELECT @PTNo = [No] FROM @Return

										IF EXISTS (Select 'x' From MO_Det Where MONo = @MONo And Color = @ColorDesc And Size = @SizeDesc)
										BEGIN
											Insert Into Laying_PT(MONo,LayNo,PTNo,Bundle_No,Color,Size,Qty,Created_By,time_Created,Seq--,Dest
											,Seq_Ply_Batch)    
											Select                 
												a.MONo, 
												a.LayNo,                     
												@MfgLoc + @PTNo,
												@LastBundle,
												b.Color, 
												a.Size,                         
												b.Qty,                
												@User as CreatedBy ,
												GETDATE() as CreatedDt,
												@Seq,
												--Destination,
												@SeqPly
											From Laying_Sizes a                      
											Inner Join Laying_Ply_Batch b on a.MONo = b.MONo And a.LayNo = b.LayNo                      
											Where a.MONo = @MONo 
												And a.LayNo = @Lay
												And a.Size = @SizeDesc 
												And b.Color = @ColorDesc
												And b.Seq = @SeqPly    
												       print 'test'      
										END
										ELSE
										BEGIN
											If @SizeDesc Like '%' + @mSizeDesc + '%' 
											Begin
												Set @mSizeDesc = @mSizeDesc + @SizeDesc + ' , '
											End
											If @ColorDesc Like '%' + @mColorDesc + '%'
											Begin
												Set @mColorDesc = @mColorDesc + @lColorDesc + ' , '
											End
										END
		
									Fetch Next From BinInfoPly Into @SeqPly,@ColorDesc
									End
									Close BinInfoPly                      
									Deallocate BinInfoPly 
										Set @CounterSize = @CounterSize + 1  

									End
									Set @CounterSize = 1
	
								Fetch Next From BinInfoSizes Into @SizeDesc,@BundleQty
       
								End                
								Close BinInfoSizes                      
								Deallocate BinInfoSizes 

					   Declare @TktCount as int                      
					   Select @TktCount = Isnull(Count('X'),0) From Laying_PT Where MONo = @MONo And LayNo = @Lay
						If (@TktCount > 0)         
						Begin                      
    
							Declare @minBundle as int                      
							Declare @maxBundle as int                      
							
							Set @maxBundle = 0

							Select 
								@maxBundle = Count(PTNo) 
							From Laying_PT 
							Where MONo = @MONo    
								And LayNo = @Lay    
							If (@maxBundle <> 0)
							Begin
									--If (@mColorDesc = '')
									--Begin
									--	Select 'No bundle/s generated for size/s ' + SUBSTRING(@mSizeDesc, 0,LEN(@mSizeDesc) - 1) + ' and color/s ' + SUBSTRING(@mColorDesc, 0,LEN(@mColorDesc) - 1) + '.', 0 as Error
									--	Return
									--End

									Update Laying_Hdr                       
										Set [Status] = 'G', 
											Bundle_No_From = @LastBundle - @maxBundle + 1, 
											Bundle_No_To = @LastBundle, 
											time_Created = GETDATE(), 
											Created_By = @User  
									Where MONo = @MONo   
										And LayNo = @Lay    
										
									Update m_Mfg_Locs Set w_Ticket = 1 Where id = (Select Mfg_Loc From MO_Hdr Where MONo = @MONo) 
										
									--Insert on WIP scanning Initial Checkpoint
									If Exists (Select 'x' From MO_VAP_SVAP Where MONo = @MONo And VAP IN (Select VAP From VAP Where InitChkpt = 1) And Seq2 = 1)
									Begin
											Declare @LoadOn	bit
											Declare @VAP	varchar(50)
											Declare @SVAP	varchar(50)
											Declare @CutWS	varchar(50) --Added by CE 7/18/2016
											Declare @Shift	varchar(50) --ST 01/26/2017
											Declare @LayDt  datetime -- ST 08/23/2017
											Declare @CWS	varchar(50) -- ST 08/23/2017
											Declare @DateFrom datetime
											Declare @DateTo datetime
											Declare @WShift varchar(50)

											Select @LoadOn = Load_On, @VAP = VAP, @SVAP = SVAP From MO_VAP_SVAP Where MONo = @MONo And Active = 1 And Seq2 = 1 

											/* remarks by donel
											--Added by CE 7/18/2016
											Select @CutWS = plws.ProdLine
													FROM dbo.Laying_Hdr AS lh INNER JOIN
													dbo.ProdLinesWS AS plws ON lh.CutWorkSection = plws.WorkSection
													WHERE (lh.MONo = @MONo) AND (lh.LayNo = @Lay)
											
											--ST 01/26/2017
											Select @Shift = Case When DayShift = 1 Then 'D' Else 'N' End From WorkShifts
													Where WorkShift IN (
													Select WorkShift From WorkSectionsSched
													Where WorkSection IN
													(
													Select 
													CutWorkSection
													From 
													Laying_Hdr A 
													Where MONo = @MONo And LayNo = @Lay
													) And DateFrom <= Convert(varchar(10),GETDATE(),101)
													And DateTo >= Convert(varchar(10),GETDATE(),101)
													)
											*/
											--added by donel
											Select @CutWS = lh.Cut_Work_Section,@Shift = 'D' --plws.ProdLine
													FROM dbo.Laying_Hdr AS lh 
													--INNER JOIN dbo.ProdLinesWS AS plws ON lh.CutWorkSection = plws.WorkSection
													WHERE (lh.MONo = @MONo) AND (lh.LayNo = @Lay)
											
											If not exists(Select WS_Req from m_SVAP where VAP = @VAP and code = @SVAP and isnull(WS_Req,0) = 1)
											Begin
												Set @CutWS = Null
											end
											--Added by CE 7/18/2016


												--Added by ST 08/23/2017
											IF EXISTS(SELECT 'X' FROM Laying_Hdr WHERE MONo = @MONo  AND LayNo = @Lay)
											BEGIN
												SELECT @CWS = Cut_Work_Section 
												FROM Laying_Hdr WHERE 
												MONo = @MONo AND LayNo = @Lay
												/* remarks by donel
												SELECT 
													   --@DateFrom = DateFrom,
													   --@DateTo = DateTo,
													   @WShift = WorkShift 
												FROM WorkSectionsSched WHERE Worksection = @CWS
												AND  CONVERT(DATE,GETDATE()) BETWEEN CONVERT(DATE,DATEFROM) AND CONVERT(DATE,DATETO)
												*/
												set @WShift = 'D1'
												SET @LayDt = GETDATE()
												/* remarks by donel
												SELECT 
												@DateFrom = TimeFr,
												@DateTo = TimeTo
												FROM 
												WorkShifts 
												WHERE WorkShift = @WShift

												IF EXISTS (SELECT DayShift FROM WORKSHIFTS WHERE WORKSHIFT = @WShift AND DayShift = 1)
												BEGIN
													SET @LayDt = GETDATE()
												END
												ELSE
												BEGIN

													IF(FORMAT(@DateFrom,'HH:mm') > FORMAT(GETDATE(),'HH:mm')) --And (FORMAT(@DateTo,'HH:mm') < FORMAT(GETDATE(),'HH:mm'))
													BEGIN
														SET @LayDt = DATEADD(DD,-1,GETDATE())
													END
													ELSE
													BEGIN
														SET @LayDt = GETDATE()
													END
													
												END
												*/

											END

											IF(@LayDt IS NULL)
											BEGIN
												SET @LayDt = GETDATE()
											END

											Insert Into WIP_Scan(MONo,LayNo,PTNo,Load_Type,Seq,VAP,SVAP,Qty,Created_By,time_Created,Work_Section,time_Updated,Scan_Dt,Authorized_By,[Shift])
											Select  
												MONo, 
												LayNo, 
												PTNo, 
												Case When @LoadOn = 1 then 1 Else 2 End as LoadType,
												1 as Seq, 
												@VAP, 
												@SVAP, 
												Qty, 
												@User, 
												GETDATE(),
												@CutWS, --Added by CE 7/18/2016
												NULL,
												@LayDt, --ST 08/23/2017
												NULL,
												@Shift --ST 01/26/2017
											From Laying_PT
											Where MONo = @MONo
												And LayNo = @Lay

													
											Insert Into WIP_Scan_Part(Rec_Id,MONo,LayNo,PTNo,Load_Type,Seq,VAP,SVAP,Part_Cd,Qty,Created_By,time_Created,Work_Section,time_Updated,Scan_Dt,Authorized_By,Day_Night_Shft)
											Select  
												NEWID(),
												Laying_PT.MONo, 
												LayNo, 
												PTNo, 
												Case When @LoadOn = 1 then 1 Else 2 End as LoadType,
												1 as Seq, 
												@VAP, 
												@SVAP, 
												Part_Cd,
												Qty, 
												@User, 
												GETDATE(),
												@CutWS, --Added by CE 7/18/2016
												NULL,
												@LayDt, --ST 08/23/2017
												NULL,
												@Shift --ST 01/26/2017
											From Laying_PT
											INNER JOIN MO_SVAP_PART ON Laying_PT.MONo = MO_SVAP_PART.MONo
											Where Laying_PT.MONo = @MONo AND VAP = 'BIN-INIT'
												And LayNo = @Lay
									End 

									If (@mSizeDesc <> '' And @mColorDesc <> '')
									Begin
										--print '0'
										Select 'No bundle/s generated for size/s ' + SUBSTRING(@mSizeDesc, 0,LEN(@mSizeDesc) - 1) + ' and color/s ' + SUBSTRING(@mColorDesc, 0,LEN(@mColorDesc) - 1) + '. Bundle number/s ' + CONVERT(varchar(5),(@LastBundle - @maxBundle + 1)) + ' to ' + CONVERT(varchar(5),(@LastBundle)) + ' generated to manufacturing order number ' + @MONo + '.' as description, 'error'  as code
										Return       
									End
									Else
									Begin
										--print '1'
										Select 'Bundle number/s ' + CONVERT(varchar(5),(@LastBundle - @maxBundle + 1)) + ' to ' + CONVERT(varchar(5),(@LastBundle)) + ' generated to manufacturing order number ' + @MONo + '.' as description, 'error' as code
										Return  
									End
							End
							Else
						    Begin
									--print '2'
									Select  'No bundle/s generated for manufacturing order number ' + @MONo + '.' as description, 'error' as code
									--Select 'No bundle/s generated to size/s ' + SUBSTRING(@mSizeDesc, 0,LEN(@mSizeDesc) - 1)  + ' and color/s ' + SUBSTRING(@mColorDesc, 0,LEN(@mColorDesc) - 1) + '.', 0 as Error
									Return 
							End

							--If @@ERROR<> 0                  
							--Begin                  
							--	ROLLBACK TRAN                  
							--	RETURN                  
							--End                        
						End 
						Else
						Begin
								--print '3'
								Select 'No bundle/s generated for size/s ' + SUBSTRING(@mSizeDesc, 0,LEN(@mSizeDesc) - 1) + ' and color/s ' + SUBSTRING(@mColorDesc, 0,LEN(@mColorDesc) - 1) + '.'as description, 'error' as code
								Return
						End   
						
						select 'Ticket Successfully Generated' as description, 'ok' as code 
End


go



-- =============================================
-- Author:		CAE
-- Create date: 03252015
-- Description:	Sync from Sync.. Tables 
--EXECUTE [dbo].[ordSyncIMAPPS] 'conrad'
--Select * from IODet
-- =============================================
CREATE PROCEDURE [dbo].[stg_ordSyncIMAPPS]
	-- Add the parameters for the stored procedure here
	@UserId		NVARCHAR(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	BEGIN TRY
	
	--BEGIN TRANSACTION

	DECLARE @LastRunTime AS Datetime
	DECLARE @CurrRunTime AS Datetime
	DECLARE @RecId AS varchar(100)

	Set @CurrRunTime = getdate()
	Set @RecId = NEWID()

	INSERT INTO [dbo].[stg_SyncLog]([Recid],[RunTime],[CreatedBy],[Remarks])
     VALUES(@RecId, @CurrRunTime, @UserId, 'iMAPPS - Initialize.')

	

	BEGIN		

		--create Customer Group
		INSERT INTO [dbo].[m_Customer_Group_Ext]
           ([Cus_Grp_Ext],[Source],[Desc1],[Created_By],[Time_Created])
		SELECT distinct scg.CustGrp, scg.SrcERP, scg.Description, @UserId, getdate()
			FROM dbo.stg_SyncCustGrp AS scg 
			LEFT OUTER JOIN dbo.m_Customer_Group_Ext AS cge ON scg.CustGrp = cge.Cus_Grp_Ext AND scg.SrcERP = cge.Source
			WHERE (cge.Cus_Grp_Ext IS NULL)

		
		
		--create Customer
		INSERT INTO [dbo].[m_Customers_Ext]
           ([Customer_Ext],[Desc1],[Source],[Created_By],[Time_Created])
		SELECT distinct sc.CustomerCd, sc.Name, sc.SrcERP, @UserId, getdate()
			FROM dbo.stg_SyncCustomer AS sc 
			LEFT OUTER JOIN dbo.m_Customers_Ext AS ce ON sc.CustomerCd = ce.Customer_Ext AND sc.SrcERP = ce.Source
			WHERE (ce.Customer_Ext IS NULL)

		--PRINT 'StyleHdr..'	
		INSERT INTO [dbo].[Style_Hdr]
           ([Style_No],[Desc1],[Desc2]/*,ProdTyp,ProdTypDesc*/)
		--SELECT DISTINCT sIO.StyleNo, sIO.CustStyleDesc As Desc1,
		--	sIO.CustStyleDesc As Desc2
		SELECT DISTINCT sIO.Style_No, (SELECT DISTINCT RTRIM(Cust_Style) + ',' FROM IO_Sync A WHERE A.Style_No = sIO.Style_No FOR XML PATH('')) Desc1,
			(SELECT DISTINCT RTRIM(Cust_Style) + ',' FROM IO_Sync A WHERE A.Style_No = sIO.Style_No FOR XML PATH('')) Desc2
			--ProdType, ProdTypeDesc 
		FROM IO_Sync AS sIO 
		LEFT OUTER JOIN dbo.Style_Hdr AS sh ON sIO.Style_No = sh.Style_No
			WHERE (sh.Style_No IS NULL) and ISNULL(sIO.Cust_Style_Desc,'') <> ''
		ORDER BY Style_No



		--PRINT 'Style Image..'
		INSERT INTO [dbo].[Style_Image]
           ([Style_No])
		SELECT DISTINCT sIO.Style_No
		FROM IO_Sync AS sIO 
		LEFT OUTER JOIN dbo.Style_Image AS sh ON sIO.Style_No = sh.Style_No
			WHERE (sh.Style_No IS NULL)
		


		Declare @Start as varchar(1)

		--create IODetail
		/*
		0. Update all existing IO Hdr and MO Hdr
		1. Create all new IO
		2. Create all new IO Det
		3. Update all IO Det and MO Det except for MO Qty that has Planned
		4. Update all IO SMV
		5. IO Det Update trigger will update MO Det
		*/
		--0. Update IO Hdr
		
		--PRINT 'UPDATE IO Hdr'
		Update dbo.stg_SyncLog set Remarks = 'iMAPPS - Update IO Header.', TimeFinish = getdate() Where RecId = @RecId

		UPDATE IO_Hdr Set Plan_SMV = (CASE WHEN isnull(sIOh.Merch_SMV,0) = 0 THEN isnull(sIOh.Tc_SMV,0) ELSE sIOh.Merch_SMV END), Merch_SMV = sIOh.Merch_SMV, Tc_SMV = sIOh.Tc_SMV, Mfg_Loc_id = sIOh.Mfg_Loc_id, Prod_Type_id = sIOh.Prod_Type_id
			--,AplqTyp = sIOh.AplqTyp, EmbroTyp = sIOh.EmbroTyp, PrntTyp = sIOh.PrntTyp, HTTyp = sIOh.HTTyp, WashTyp = sIOh.WashTyp  --remarks by donel missing columns
			, Description = sIOh.IO_Desc
			,Style_No = sIOh.Style_No, Cust_Style_id = sIOh.Cust_Style_id, Order_Status_id = sIOh.Order_Status_id
			FROM dbo.IO_Hdr AS IOh 
			INNER JOIN dbo.ordSyncIOHdr_vw AS sIOh ON IOh.IONo = sIOh.IONo
			inner join m_Mfg_Locs AS ml ON sIOh.Mfg_Loc = ml.code

		--0. Update MO Hdr
		--PRINT 'UPDATE MO HDR'
		Update dbo.stg_SyncLog set Remarks = 'iMAPPS - Update MO Header.', TimeFinish = getdate() Where RecId = @RecId
		UPDATE MO_Hdr Set MerchSMV = sIOh.Merch_SMV, TcSMV = sIOh.Tc_SMV
			,Style_No = sIOh.Style_No
			--,PlanSMV = (CASE WHEN isnull(sIOh.MerchSMV,0) = 0 THEN isnull(sIOh.TcSMV,0) ELSE sIOh.MerchSMV END)
			FROM dbo.MO_Hdr AS MOh 
			INNER JOIN dbo.ordSyncIOHdr_vw AS sIOh ON MOh.IONo = sIOh.IONo
			--LEFT OUTER JOIN (Select distinct MONo from BOHdr Where MfgLoc in (Select MfgLoc from MfgLocs Where GVAP = 'SEW')) AS bo on MOh.MONo = bo.MONo
			--Where bo.MONo Is Null

		--1. Create all new IO
		BEGIN
			
			--PRINT 'INSERT IO HDR'					
			Update dbo.stg_SyncLog set Remarks = 'iMAPPS - Insert IO Header.', TimeFinish = getdate() Where RecId = @RecId
			INSERT INTO [dbo].[IO_Hdr]
				([sbu_id],[IONo]--,[RefNo] remarks by donel missing column
				,[Order_Type_id],[Season_id],[Plant_id],[Cus_Grp]
				,[Sales_Grp_id],[Order_Qty],[UOM]
				,[Cust_Style_id],[Cust_Desc],[Style_No],[Order_Status_id],[Prod_Type_id]--,[Prod_Type_Desc] remarks by donel missing column
				,[Plan_SMV],[Merch_SMV],[Tc_SMV],[PSD_Dt],[Cust_Del_Dt]--,[LPDDt],[CMPrice]  remarks by donel missing column
				,[Board_Color],[Mfg_Loc_id],[mfg_loc]--,[Deleted] remarks by donel missing column
				,[Created_By],[Time_Created],[Src_ERP]--,[AS400IONo] remarks by donel missing column
				--,[AplqTyp],[EmbroTyp],[PrntTyp],[WashTyp],[HTTyp] remarks by donel missing column
				,[Description],season)
			SELECT sIO.sbu_id,sIO.IONo--, sIO.IONo
			, sIO.Order_Type_id, sIO.Season_id, sIO.Plant_id, sIO.Cust_Grp
			, sIO.Sales_Grp_id, 0, sIO.UOM
				, sIO.cust_style_id, sIO.Style_No, sIO.Style_No, max(sIO.Order_Status_id), sIO.Prod_Type_id--, sIO.Prod_Type_Desc
				, Max((CASE WHEN isnull(sIO.Merch_SMV,0) = 0 THEN isnull(sIO.Tc_SMV,0) ELSE sIO.Merch_SMV END))
				, max(sIO.Merch_SMV), max(sIO.Tc_SMV), min(sIO.Delivery_Dt), min(sIO.[Cust_Del_Dt])--, max(sIO.LPDDt)
				--, 0
				/*, 'Color [A=255, R=' + cast((1.0 + floor(255 * RAND(convert(varbinary, newid())))) AS varchar(3)) +
								', G=' + cast((1.0 + floor(255 * RAND(convert(varbinary, newid())))) AS varchar(3)) +
								', B=' + cast((1.0 + floor(255 * RAND(convert(varbinary, newid())))) AS varchar(3)) + ']' As BC
				*/
				, (select top 1 board_color from m_prod_type where id = sIO.Prod_Type_id) as BC
				, sIO.Mfg_Loc_id,sIO.Mfg_Loc--, 0
				, @UserId, getdate(), sIO.Src_ERP--,sIO.AS400IONo
				--,min(sIO.[AplqTyp]),min(sIO.[EmbroTyp]),min(sIO.[PrntTyp]),min(sIO.[WashTyp]),min(sIO.[HTTyp])
				,sIO.IO_Desc, sIO.season
				FROM dbo.IO_Sync AS sIO 
				LEFT OUTER JOIN dbo.IO_Hdr AS IOh ON sIO.IONo = IOh.IONo
				Where (IOh.IONo IS NULL) 
				GROUP BY sIO.sbu_id,sIO.IONo, sIO.Order_Type_id, sIO.Season_id, SIO.season, sIO.Plant_id, sIO.Cust_Grp
				, sIO.Sales_Grp_id, sIO.UOM
				,sIO.cust_style_id
				, sIO.Style_No, sIO.Prod_Type_id, --sIO.ProdTypeDesc, /*sIO.MerchSMV, sIO.TcSMV, */ 
				sIO.Src_ERP, sIO.Mfg_Loc_id,sIO.Mfg_Loc--,sIO.AS400IONo
				,sIO.IO_Desc
				--,sIO.[AplqTyp],sIO.[EmbroTyp],sIO.[PrntTyp],sIO.[WashTyp],sIO.[HTTyp]
				HAVING sum(sIO.Req_Qty) > 0


			

		END
		--2. Create all new IO Det
		BEGIN
			--PRINT 'INSERT IO DET'
			Update dbo.stg_SyncLog set Remarks = 'iMAPPS - Insert IO Details.', TimeFinish = getdate() Where RecId = @RecId
			INSERT INTO [dbo].[IO_Det]
			   ([sbu_id],[io_id],[IONo]
				,[CPO_No],[CPO_Item],[CPO_Dt]
				,[Cust_Style],[Cust_Desc]
				,[Cust_Color],[Cust_Size]
			   ,[Ship_To_Cust],[Style_No]
			   ,[Color]--,[Color_Desc] 
			   ,[Size],[Dest],[Dest_id],[Qty],[Dlv_Dt],[Sold_To_Cust],[Bill_To_Cust]
			   ,[Ship_Mode]--,[Garm_Qty],[Act_Qty]
			   ,[Created_By],[Time_Created]--,[Src_ERP]
			   ,[CONo],[PSD_Dt],[LPD_Dt]
			   --,[Webbing]
			   ,[POD_Dt]
			   --,EmbroQty,PrntQty,PlanDt,WashTyp,EmbroTyp,PrntTyp,DyeTyp
			   ,Fty_Del_Dt,Fab_Pattern--,Color_TC_SMV
			   ,Shipped_Qty,CO_Status,SO_Remarks
			   ,RS_Dt,VSL_Dt,Ex_Fty_Dt,Sales_Ord_Type
			   ,IO_Ln)
			SELECT IOh.sbu_id,IOh.id, IOh.IONo
					, isnull(sIO.Cust_PONo,'TBA'), sIO.Cust_PO_Item, sIO.Cust_PO_Dt
					, sIO.Cust_Style, sIO.Cust_Style_Desc
					, sIO.Cust_Color, sIO.Cust_Size
					, sIO.Ship_To_Cust, sIO.Style_No
					, sIO.Color--, sIO.ColorDesc
					, sIO.Size,sIO.Dest, sIO.Dest_id, ISNULL(sIO.Req_Qty,0), sIO.Cust_Del_Dt, sIO.Sold_To_Cust, sIO.Bill_To_Cust
					, sIO.Ship_Mode--, sIO.NoOfPcs, 0
					,@UserId, getdate()--, sIO.SrcERP
					,sIO.CONo,sIO.Delivery_Dt, sIO.LPD_Dt
					--, sIO.Webbing
					, sIO.Delivery_Dt
					--,sIO.EmbroQty,sIO.PrntQty,sIO.PlanDt,sIO.WashTyp,sIO.EmbroTyp,sIO.PrntTyp,sIO.DyeTyp
					,sIO.Fty_Del_Dt,sIO.Fab_Pattern --,sIO.ColorTCSMV
					,isnull(sIO.Shipped_Qty,0),'Release',sIO.SO_Remarks
					,sIO.RS_Dt, sIO.VSL_Dt, sIO.Ex_Fty_Dt, sIO.Sales_Ord_Type
					, sIO.IO_Ln
					FROM dbo.IO_Sync AS sIO 
					INNER JOIN dbo.IO_Hdr AS IOh ON sIO.IONo = IOh.IONo 
					LEFT OUTER JOIN dbo.IO_Det AS IOd ON IOh.id = IOd.IO_id AND sIO.CONo = IOd.CONo AND sIO.Color = IOd.Color AND sIO.Size = IOd.Size
					WHERE (IOd.CONo IS NULL) and ISNULL(sIO.Req_Qty,0) > 0

		END
		--3. Update all IO Det
		BEGIN
			--PRINT 'UPDATE IO DET'
			Update dbo.stg_SyncLog set Remarks = 'iMAPPS - Update IO Details.', TimeFinish = getdate() Where RecId = @RecId
			UPDATE dbo.IO_Det Set CPO_Dt = sIO.Cust_PO_Dt
						, Cust_Style = sIO.Cust_Style
						, Cust_Desc = sIO.Cust_Style_Desc
						, Cust_Color = sIO.Cust_Color
						, Cust_Size = sIO.Cust_Size
						, Ship_To_Cust = sIO.Ship_To_Cust
						, Ship_To_Cust_id = sIO.Ship_To_Cust_id
						, Style_No = sIO.Style_No
						--, ColorDesc = sIO.ColorDesc
						, Dest_id = sIO.Dest_id
						, Qty = ISNULL(sIO.Req_Qty,0)
						, Dlv_Dt = sIO.Cust_Del_Dt
						, Sold_To_Cust = sIO.Sold_To_Cust
						, Bill_To_Cust = sIO.Bill_To_Cust
						, ship_mode = sIO.ship_mode
						, Ship_Mode_id = sIO.Ship_Mode_id
						--, GarmQty = sIO.NoOfPcs
						, PSD_Dt = sIO.Delivery_Dt
						, LPD_Dt = sIO.LPD_Dt
						, CPO_Item = sIO.Cust_PO_Item
						, CPO_No = isnull(sIO.Cust_PONo,'TBA')
						, Time_Updated = GetDate()
						, Updated_By = @UserId
						--, Webbing = sIO.Webbing
						--, PODDt = sIO.DeliveryDt
						--, EmbroQty = sIO.EmbroQty
						--, PrntQty = sIO.PrntQty
						--, PlanDt = sIO.PlanDt
						--, WashTyp = sIO.WashTyp
						--, EmbroTyp = sIO.EmbroTyp
						--, PrntTyp = sIO.PrntTyp
						--, DyeTyp = sIO.DyeTyp
						, Fty_Del_Dt = sIO.Fty_Del_Dt
						, Fab_Pattern = sIO.Fab_Pattern
						--, ColorTCSMV = sIO.ColorTCSMV 
						, Shipped_Qty = isnull(sIO.Shipped_Qty,0)
						, SO_Remarks = sIO.SO_Remarks
						, RS_Dt = sIO.RS_Dt
						, VSL_Dt = sIO.VSL_Dt
						, Ex_Fty_Dt = sIO.Ex_Fty_Dt
						, Sales_Ord_Type = sIO.Sales_Ord_Type
						, IO_Ln = sIO.IO_Ln
						, CO_Status = CASE WHEN (isnull(IOd.CO_Status,'') <> 'Complete' 
												and ISNULL(sIO.Req_Qty,0) <= ISNULL(sIO.Shipped_Qty,0)
												and ISNULL(sIO.Shipped_Qty,0) > 0) or (isnull(IOd.CO_Status,'') = 'Complete')
											THEN 'Complete' 
											ELSE (CASE WHEN ISNULL(sIO.Req_Qty,0) = 0 THEN 'Cancelled' ELSE 'Release' END)
											END
			FROM dbo.IO_Sync AS sIO 
			INNER JOIN dbo.IO_Hdr AS IOh ON sIO.IONo = IOh.IONo 
			INNER JOIN dbo.IO_Det AS IOd ON IOh.id = IOd.IO_id AND sIO.CONo = IOd.CONo AND sIO.Color = IOd.Color AND sIO.Size = IOd.Size

			--WHERE (sIO.CreatedDt > @LastRunTime)
		END

		--3. Update all MO Det except for MO Qty that has Planned
		/* remarks by donel
		BEGIN
	
			--PRINT 'UPDATE MO COLOR'
			Update dbo.SyncLog set Remarks = 'iMAPPS - Update MO Colors.', TimeFinish = getdate() Where RecId = @RecId
			UPDATE dbo.MOColor set ColorDesc = iod.ColorDesc
			FROM dbo.MOColor INNER JOIN
						(Select distinct IONo, Color, ColorDesc from dbo.SyncIO) AS iod ON dbo.MOColor.Color =iod.Color 
						INNER JOIN dbo.MOHdr ON dbo.MOColor.MONo = dbo.MOHdr.MONo AND iod.IONo = dbo.MOHdr.IONo

		END
		


		--4. Update All IO SMV
		BEGIN
			--PRINT 'INSERT IOSMV'
			INSERT INTO [dbo].[IOSMV]
					   ([IONo],[ItemNo],[SeqNo],[SMVDesc],[SMV],[UpdatedDt])
			SELECT s.IONo, s.ItemNo, s.SeqNo, s.SMVDesc, s.SMV, getdate()
				FROM dbo.SyncIOSMV AS s INNER JOIN
                         dbo.IOHdr AS r ON s.IONo = r.IONo LEFT OUTER JOIN
                         dbo.IOSMV AS t ON s.ItemNo = t.ItemNo AND s.IONo = t.IONo
				WHERE (t.IONo IS NULL)
			
			--PRINT 'UPDATE IOSMV'
			UPDATE dbo.IOSMV Set SMVDesc = s.SMVDesc, SMV = s.SMV
				FROM dbo.SyncIOSMV AS s INNER JOIN
                         dbo.IOHdr AS r ON s.IONo = r.IONo INNER JOIN
                         dbo.IOSMV AS t ON s.ItemNo = t.ItemNo AND s.IONo = t.IONo

		END
		
		--5. Update StyleNo
		BEGIN
			Update dbo.SyncLog set Remarks = 'iMAPPS - Update StyleNo.', TimeFinish = getdate() Where RecId = @RecId
			select distinct d.MONo, d.StyleNo into #MONo from MODet d inner join MOHdr h on d.MONo = h.MONo
			Where d.StyleNo <> h.StyleNo

			if (Select count(1) from #MoNo) > 0
			BEGIN
				Update MOHdr Set StyleNo = m.StyleNo
				from MOHdr h inner join #MONo m on h.MONo = m.MONo

				Update OB Set StyleNo = m.StyleNo
				from OB h inner join #MONo m on h.MONo = m.MONo

				Update OBGroupOperations Set Style = m.StyleNo
				from OBGroupOperations h inner join #MONo m on h.MONo = m.MONo

				Update OBSMVDet Set Style = m.StyleNo
				from OBSMVDet h inner join #MONo m on h.MONo = m.MONo
			END

			Drop Table #MONo
		END
		*/
	END

	--COMMIT TRANSACTION
	Update dbo.stg_SyncLog set Remarks = 'iMAPPS - Completed.', TimeFinish = getdate() Where RecId = @RecId
	
	END TRY
	
	BEGIN CATCH
		IF (@@TRANCOUNT > 0)
		--SELECT 1 AS ERROR_MSG
			--SELECT ERROR_MESSAGE() AS ERROR_MSG
			Update dbo.stg_SyncLog set Remarks = left('iMAPPS-' + ERROR_MESSAGE(),2000), TimeFinish = getdate() Where Recid = @RecId
			--ROLLBACK TRANSACTION	
	END CATCH
END


go

CREATE procedure delete_ob
  @mono varchar(20) = ''
as
BEGIN
  declare @moStatus varchar(20)
  select @moStatus = mo_status from mo_hdr where mono = @mono
  if (@moStatus = 'OB')
  BEGIN
    --delete from ob_upload where mono = @mono
    delete from ob where mono = @mono
    delete from OB_Group_Operations where mono = @mono
    delete from ob_group_worksections where mono = @mono
    update mo_hdr set mo_status = 'Created'  where mono = @mono
  END
end
go

CREATE PROC [dbo].[prdForLaysp]
(
	@USERID NVARCHAR(50),
	@PARAMMONO	VARCHAR(20) = ''
)
AS
--EXEC prdForLaysp
BEGIN

	EXEC prdAutoLayMODetsp @USERID,@PARAMMONO
	--select 'Ticket Successfully Generated for MONo : ' + @PARAMMONO as 'description','success' as code

END
go

CREATE function [dbo].[fn_is_pallet_available]
(
	@pallet nvarchar(20),
	@checkpoint nvarchar(10),
	@type nvarchar(3)

)
RETURNS @output TABLE(code VARCHAR(20), description VARCHAR(20))
AS
BEGIN
	declare @totalCarton int
	declare @isAvailable bit
	select @totalCarton =  count(1) from fg_carton (nolock) where pallet = @pallet  --and check_point =@checkpoint and type = @type

	if (@totalCarton > 0 )
		SET @isAvailable = 0
	else
		SET @isAvailable =  1

	INSERT INTO @output (code, description) values ('available', case when @isAvailable = 1 then 'true' else 'false' end )
	RETURN
END
go

CREATE PROC [dbo].[prdAutoLayMODetsp]
(
	@USERID NVARCHAR(50),
	@PARAMMONO	VARCHAR(20) = ''
)

AS


SET NOCOUNT ON

BEGIN TRY
	--BEGIN TRANSACTION
	declare @moid bigint
	select @moid = id from mo_hdr where mono = @PARAMMONO

	declare @status varchar(50) = '', @sbu_id int = 1, @order_qty int, @ply_qty int
	select top 1 @status = mo_status from mo_hdr where mono = @PARAMMONO
	if @status != 'LAYING'
		begin
			select 'MO : ' + @PARAMMONO + ' Not Allowed for Ticket Generation, current MO Status : ' + @status as 'description', 'error' as code
			return
		end

	if not exists(select top 1 mono from OB where mono = @PARAMMONO)
		begin
			select 'MO : ' + @PARAMMONO + ' Not Allowed for Ticket Generation, No Existing OB ' as 'description', 'error' as code
			return
		end

	if not exists(select top 1 mono from laying_ply_batch where mono = @PARAMMONO and active = 1)
		begin
			select 'MO : ' + @PARAMMONO + ' Not Allowed for Ticket Generation, No available PLY Batch ' as 'description', 'error' as code
			return
		end

	select @order_qty = sum(qty) from mo_det where mono = @PARAMMONO
	select @ply_qty = sum(b.qty)
	from laying_hdr a
	inner join laying_ply_batch b on b.mono = a.mono and b.layno = a.layno and b.active = 1
	where a.mono = @PARAMMONO and a.[status] != 'V' and a.active = 1 and (isnull(a.excess,0) = 0 or isnull(a.replacement,0) = 0)

	if @ply_qty > @order_qty
		begin
			select 'MO : ' + @PARAMMONO + ' Not Allowed for Ticket Generation, Exceeded Qty : ' + cast((@ply_qty - @order_qty) as varchar(15)) as description, 'error' as code
			return
		end

/*
	IF OBJECT_ID('tempdb.dbo.#Loop') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #Loop
	END

	IF OBJECT_ID('tempdb.dbo.#MCS') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #MCS
	END

	IF OBJECT_ID('tempdb.dbo.#AutoLay') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #AutoLay
	END

	--IF OBJECT_ID('tempdb.dbo.#PT') IS NOT NULL
	--BEGIN
	--	--PRINT 'exist'
	--	drop table #PT
	--END

	DECLARE @UpdatedDt date = convert(date,dateadd(day, -180, getdate()))
	DECLARE @PT varchar(50), @Qty numeric(18,5) = 0

	Select h.IONo, h.MONo, d.Color, d.Size, d.Qty, s.Std_Bndl_Qty, s.Default_WS into #MCS from MO_Hdr h with (nolock)
		OUTER APPLY
		(
			Select Color, Size, sum(Qty) as Qty, max(isnull(time_Updated,time_Created)) as time_Updated
				from MO_Det with (nolock) Where MONo = h.MONo group by Color, Size
		) d
		OUTER APPLY
		(
			Select Std_Bndl_Qty, Default_WS from m_Mfg_Locs Where id = h.Mfg_Loc
		) s
		Where
		h.MONo in (Select MONo from OB with (nolock))
		and h.MO_Status in ('LAYING')--('Released','For Release')
		--remarks by donel AND isnull(h.Prod_Month, getdate()) >= dateadd(day, -180, getdate())
		and (isnull(h.time_Updated,h.time_Created) >= @UpdatedDt or d.time_Updated >=@UpdatedDt)
		--remarks by donel and h.MONo not in (Select MONo from Laying_Hdr with (nolock) Where MONo <> LayNo and [Status] in ('G','N'))
		and h.MONo LIKE CASE WHEN LEN(@PARAMMONO) > 0 THEN '' + @PARAMMONO + '' ELSE '%' END
		--and not exists(Select p.MONo from LayingPT p with (nolock) inner join LayingHdr l with (nolock) on p.MONo = l.MONo and p.LayNo = l.LayNo
		--							Where p.MONo = h.MONo and p.LayNo = h.MONo and p.Color = d.Color and p.Size = d.Size and l.[Status] in ('G','N'))

	--Select * from #MCS

	Select mcs.*, Qty - isnull(cutQty,0) as BalQty, mcs.MONo as LayNo into #AutoLay from #MCS mcs
	outer apply
	(
		Select Sum(Qty) as CutQty
						from Laying_PT p with (nolock) inner join Laying_Hdr h on p.MONo = h.MONo and p.LayNo = h.LayNo
						Where p.MONo = mcs.MONo and p.LayNo = p.MONo and p.Color = mcs.Color and p.Size = mcs.Size
						--and h.Status in ('G','N')
	) c
	outer apply
	(
		Select Sum(Qty) as vCutQty
						from Laying_PT p with (nolock) inner join Laying_Hdr h on p.MONo = h.MONo and p.LayNo = h.LayNo
						Where p.MONo = mcs.MONo and p.LayNo = p.MONo and p.Color = mcs.Color and p.Size = mcs.Size
						and h.Status =  ('V')
	) v
	--Where Qty <> (isnull(cutQty,0) - isnull(vCutQty,0)) --stan 09/07/2021
	Where Qty > (isnull(cutQty,0) - isnull(vCutQty,0))
	order by MONo, Color

	--Select * from #AutoLay

	Select ROW_NUMBER() OVER (order by MONo, Color, Size) AS Row_Num, IONo, MONo, LayNo, Color, Size, Std_Bndl_Qty, Default_WS, ceiling(BalQty/Std_Bndl_Qty) as NoOfPlyBatch, BalQty - (floor(BalQty/Std_Bndl_Qty) * Std_Bndl_Qty) as lastBatch, BalQty into #Loop from #AutoLay l
	--where MONo like 'TS194853-3001'

	--Select * from #Loop

	--Zero Out LayingPT not in MODet
	Select ROW_NUMBER() OVER (order by PTNo) AS Row_Num, PTNo, 0 as Qty into #PT
	from Laying_PT p
	Where MONo = LayNo
	and not exists(Select 1 from MO_Det with (nolock) Where MONo = p.MONo and Color = p.Color and Size = p.Size)

		--Loop to Auto Create Laying
		DECLARE @PTRecCnt int = (Select count(1) from #PT)
		DECLARE @PTCurRow	int = 1

		WHILE @PTCurRow <= @PTRecCnt
		BEGIN

			Select @PT = PTNo FROM #PT Where Row_Num = @PTCurRow
			select 1
			Update Laying_PT Set Qty = 0, time_Updated = getdate(), Updated_By = 'system'
			from Laying_PT p
			Where PTNo = @PT

			--Call SP to Update PT Qty of Initial WIP Checkpoint
			EXEC prdUpdateTicketQtysp @PT,@Qty

			SET @PTCurRow = @PTCurRow + 1
			IF @PTCurRow > @PTRecCnt
				BREAK
			ELSE
				CONTINUE
		END

	--Loop to Auto Create Laying
	DECLARE @RecCnt int = (Select count(1) from #Loop)
	DECLARE @CurRow	int = 1

	WHILE @CurRow <= @RecCnt
	BEGIN
		print '1'
		--Do Insert Laying Tables Here
		Update Laying_Hdr Set [Status] = 'G'
		Where MONo+LayNo = (Select MONo+LayNo from #Loop Where Row_Num = @CurRow) and [Status] <> 'G'

		/* remarks by donel
		INSERT INTO [dbo].[Laying_Hdr]
           (sbu_id,[MONo],[LayNo]--,[LayDt]
		   ,[Status],[Bundle_No_From],[Bundle_No_To],[Cut_Work_Section]
           --,[BTScanned],[PTScanned],[Printed],[UnAssigned]
		   ,[Replacement]
           ,Active,[Created_By],[time_Created]--,[IONo]
		   ,[Non_Lay])
		SELECT @sbu_id,t.MONo, t.LayNo--, getdate()
		, 'G', 0,0,Default_WS--,0,0,0,0
		,0,1,@USERID,getdate()--,t.IONo
		,1
		FROM
		#Loop t
		Where t.Row_Num = @CurRow
		and t.MONo not in (Select MONo from Laying_Hdr with (nolock) where MONo = LayNo)
		*/
		if exists(Select 1 from #Loop t inner join Laying_PT p on t.MONo = p.MONo and t.LayNo = p.LayNo and t.Color = p.Color and t.Size = p.Size
								Where t.Row_Num = @CurRow)
		BEGIN
			Select @PT = p.PTNo, @Qty = Qty + t.BalQty
			from #Loop t
			inner join Laying_PT p on t.MONo = p.MONo and t.LayNo = p.LayNo and t.Color = p.Color and t.Size = p.Size
			Where t.Row_Num = @CurRow

			--print '2'
			Update Laying_PT Set Qty = Qty + t.BalQty, time_Updated = getdate(), Updated_By = @USERID
			from #Loop t
			inner join Laying_PT p on t.MONo = p.MONo and t.LayNo = p.LayNo and t.Color = p.Color and t.Size = p.Size
			Where t.Row_Num = @CurRow

			--Call SP to Update PT Qty of Initial WIP Checkpoint
			EXEC prdUpdateTicketQtysp @PT,@Qty

			if exists(Select TOP 1 'X' from Laying_PT p
			INNER JOIN Laying_Hdr h on p.MONo = h.MONo and p.LayNo = h.LayNo and h.Status = 'G'
			where PTNo = @PT)
			begin
				if not exists(Select top 1 'x' from Wip_Scan where PTNo = @PT and VAP = (Select code From m_VAP Where isnull(Initial_Check_Point,0) = 1))
				begin
					--CHECK IF ALREADY HAS LAY
					--RE-INSERT NEW PART IF EXIST IN WIPSCANPART
					DECLARE @LAY NVARCHAR(20)
					DECLARE @NOOFLAY INT
					DECLARE @COUNTER INT = 1

					DECLARE @LAYLIST TABLE
					(
						ROWNO INT,
						LAYNO NVARCHAR(20)
					)

					INSERT INTO @LAYLIST
					SELECT ROW_NUMBER() OVER (PARTITION BY MONO ORDER BY LAYNO) AS ROWNO, LayNo
					FROM Laying_Hdr WHERE MONo+LayNo = (SELECT MONo+LayNo FROM Laying_PT WHERE PTNo = @PT)
					AND Status = 'G'

					SELECT @NOOFLAY = COUNT(1) FROM @LAYLIST

					WHILE @COUNTER <= @NOOFLAY
					BEGIN

					SELECT @LAY = LAYNO FROM @LAYLIST WHERE ROWNO = @COUNTER

					Insert Into WIP_Scan_Part(Rec_Id,MONo,LayNo,PTNo,Load_Type,Seq,VAP,SVAP,Part_Cd,Qty,Created_By,time_Created,Work_Section,time_Updated,Scan_Dt,Authorized_By,Day_Night_Shft)
					Select
						NEWID(),
						Laying_PT.MONo,
						Laying_PT.LayNo,
						PTNo,
						1 as LoadType,
						1 as Seq,
						'BIN-INIT',
						'BIN-INIT',
						Part_Cd,
						Qty,
						Laying_PT.Created_By,
						GETDATE(),
						Laying_Hdr.Cut_Work_Section,
						NULL,
						Laying_PT.time_Created,
						NULL,'D'
						/*(Select  Case When DayShift = 1 Then 'D' Else 'N' End From WorkShifts
							Where WorkShift IN (
						Select WorkShift From WorkSectionsSched
							Where WorkSection IN
							(
							Select
							CutWorkSection
							From
							Laying_Hdr A
							Where MONo = Laying_PT.MONo And LayNo = Laying_PT.LayNo
							) And DateFrom <= Convert(varchar(10),Laying_PT.CreatedDt,101)
							And DateTo >= Convert(varchar(10),Laying_PT.CreatedDt,101)
							))*/
					From Laying_PT
					INNER JOIN MO_SVAP_PART ON Laying_PT.MONo = MO_SVAP_PART.MONo
					INNER JOIN Laying_Hdr ON Laying_PT.MONo = Laying_Hdr.MONo AND Laying_PT.LayNo = Laying_Hdr.LayNo
					Where Laying_PT.MONo = (SELECT MONo FROM Laying_PT WHERE PTNo = @PT) AND VAP = 'BIN-INIT'
					AND Laying_PT.LayNo = @Lay AND PTNo+Part_Cd NOT IN (SELECT PTNo+Part_Cd FROM WIP_Scan_Part WHERE MONo = (SELECT MONo FROM Laying_PT WHERE PTNo = @PT) AND LayNo = @LAY)
					AND Laying_PT.PTNo = @PT

					Insert Into WIP_Scan(MONo,LayNo,PTNo,Load_Type,Seq,VAP,SVAP,Qty,Created_By,time_Created,Work_Section,time_Updated,Scan_Dt,[Shift])
					Select
						Laying_PT.MONo,
						Laying_PT.LayNo,
						PTNo,
						1 as LoadType,
						1 as Seq,
						'BIN-INIT',
						'BIN-INIT',
						Qty,
						Laying_Hdr.Created_By,
						Laying_PT.time_Created,
						Laying_Hdr.Cut_Work_section,
						NULL,
						Laying_PT.time_Created,'D'
						/*(SELECT TOP 1 DayNightShft FROM WIPScan WHERE MONo = (SELECT MONo FROM Laying_PT WHERE PTNo = @PT) AND LayNo = Laying_PT.LayNo)*/
					From Laying_PT
					INNER JOIN Laying_Hdr ON Laying_PT.MONo = Laying_Hdr.MONo AND Laying_PT.LayNo = Laying_Hdr.LayNo
					Where Laying_PT.MONo = (SELECT MONo FROM Laying_PT WHERE PTNo = @PT) --AND VAP = 'BIN-INIT'
					AND Laying_PT.LayNo = @Lay
					AND Laying_PT.PTNo = @PT

					SET @COUNTER = @COUNTER + 1

					END
				end
			end

		END
		Else
		BEGIN
			print 'x'
			--INSERT INTO [dbo].[LayingPlyBatch]
			--	   ([MONo]
			--	   ,[LayNo]
			--	   ,[Seq]
			--	   ,[Color]
			--	   ,[Qty]
			--	   ,[Deleted]
			--	   ,[CreatedBy]
			--	   ,[CreatedDt])
			--SELECT t.MONo, t.LayNo, isnull(p.LastSeq,0)+1 as RowNo, t.Color, BalQty, 0, @USERID, getdate()
			--FROM
			--#Loop t
			--outer apply
			--(Select max(Seq) as LastSeq from LayingPlyBatch with (nolock) Where MONo = t.MONo and LayNo = MONo) p
			--Where t.Row_Num = @CurRow
			--and not exists(Select 1 from LayingPT with (nolock) where MONo = t.MONo and LayNo = MONo and Color = t.Color)

			DECLARE @MONo varchar(20), @Color varchar(20), @Size varchar(20), @PTNo varchar(50), @BalQty numeric(18,5)
			SELECT @MONo = t.MONo, @Color = t.Color, @Size = t.Size, @BalQty = t.BalQty FROM #Loop t Where t.Row_Num = @CurRow

			Declare @MfgLocShortCd	varchar(5)
			DECLARE @Return TABLE( [No] VARCHAR(18) )
			INSERT @Return([No]) EXEC GetNoRangeNo 'PT', @USERID
			SELECT @PTNo = [No] FROM @Return

			SELECT @MfgLocShortCd = Mfg_Loc_Short_Cd from m_Mfg_Locs Where id= (Select Mfg_Loc From MO_Hdr Where MONo = @MONo)

			SET @PTNo = @MfgLocShortCd + @PTNo

			Insert Into Laying_PT(sbu_id,MONo,LayNo,PTNo,Bundle_No,Color,Size,Qty,Created_By,time_Created,active)
					Select @sbu_id,@MONo, @MONo, @PTNo
							,isnull((Select max(Bundle_No) as BundleNo from Laying_PT with (nolock) Where MONo = @MONo /*and LayNo = @MONo*/),0)+1
							, @Color, @Size, @BalQty, @USERID, GETDATE(),1

			Exec prdCreateBndlPTsp @PTNo

		END

		--INSERT INTO [dbo].[LayingSizes]
		--		   ([MONo]
		--		   ,[LayNo]
		--		   ,[Size]
		--		   ,[Qty]
		--		   ,[Deleted]
		--		   ,[CreatedBy]
		--		   ,[CreatedDt]
		--		   ,[Seq])
		--SELECT top 1 t.MONo, t.LayNo, t.Size, 1, 0, @USERID, getdate(), 1
		--FROM
		--#Loop t
		--Where t.Row_Num = @CurRow
		--and not exists(Select MONo from LayingSizes with (nolock) where MONo = t.MONo and LayNo = t.LayNo and Size = t.Size)

		--BREAK

		SET @CurRow = @CurRow + 1
		IF @CurRow > @RecCnt
			BREAK
		ELSE
			CONTINUE
	END

	Update Laying_Hdr Set Bundle_No_From = t.BNFr, Bundle_No_To = t.BNTo
	from Laying_Hdr h
	outer apply
	(
		Select min(Bundle_No) as BNFr, max(Bundle_No) as BNTo from Laying_PT with (Nolock) Where MONo = h.MONo
	) t
	Where MONo in (Select MONo from #Loop)

	--SELECT t.Row_Num, t.MONo, t.LayNo, t.Color, n.RowNo, CASE WHEN n.RowNo <> t.NoOfPlyBatch THEN t.StdBndlQty ELSE t.lastBatch END as BndlQty
	--FROM
	--#Loop t
	--INNER JOIN
	--ConfigRowNo n
	--	ON n.RowNo <= t.NoOfPlyBatch

	--IF OBJECT_ID('tempdb.dbo.#PT') IS NOT NULL
	--BEGIN
	--	--PRINT 'exist'
	--	drop table PT
	--END

	IF OBJECT_ID('tempdb.dbo.#Loop') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #Loop
	END

	IF OBJECT_ID('tempdb.dbo.#MCS') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #MCS
	END

	IF OBJECT_ID('tempdb.dbo.#AutoLay') IS NOT NULL
	BEGIN
		--PRINT 'exist'
		drop table #AutoLay
	END
*/

--simplified by donel generate ticket based on ply batch
	declare @color varchar(50), @layno varchar(50), @qty int, @seq int, @ctr int
	declare @currentno bigint, @PTNo varchar(50), @size varchar(30)
	Declare @MfgLocShortCd	varchar(5)--, @sbu_id int = 1

	select @ctr = isnull(max(bundle_no),0) from laying_pt a
	where mono = @PARAMMONO


	SELECT @MfgLocShortCd = Mfg_Loc_Short_Cd from m_Mfg_Locs Where id= (Select Mfg_Loc From MO_Hdr Where MONo = @PARAMMONO)
	select @size = size  from laying_sizes where mono = @PARAMMONO

	DECLARE db_cursor CURSOR FOR
	SELECT b.color, b.layno, b.qty, b.seq
	from laying_hdr a
	inner join laying_ply_batch b on b.mono = a.mono and b.layno = a.layno and b.active = 1
	where a.mono = @PARAMMONO and a.[status] = 'N' and a.active = 1


	OPEN db_cursor
	FETCH NEXT FROM db_cursor INTO @color, @layno, @qty, @seq

	WHILE @@FETCH_STATUS = 0
	BEGIN
		  select @currentno = currentno + 1 from m_no_range where norange = 'PT' and active = 1
		  set @PTNo = cast(@currentno as varchar(50))
		  SET @PTNo = @MfgLocShortCd + @PTNo
		  update m_no_range set currentno = currentno + 1 where norange = 'PT' and active = 1
		  set @ctr = @ctr + 1
		  insert into laying_pt (active, created_by, sbu_id, time_created, bundle_no, color, layno, mo_id, mono, qty, size, ptno, seq_ply_batch)
		  select 1, @userid,@sbu_id, getdate(), @ctr,@color , @layno, @moid, @parammono, @qty, @size , @PTNo, @seq
		  --update laying_hdr set [status] = 'G' where mono = @PARAMMONO and layno = @layno and [status] = 'N'
		  FETCH NEXT FROM db_cursor INTO @color, @layno, @qty, @seq

	END

	CLOSE db_cursor
	DEALLOCATE db_cursor

	update laying_hdr set [status] = 'G' where mono = @PARAMMONO and [status] = 'N'

	update a set bundle_no_from =  isnull(b.min_bundle,0) , bundle_no_to = isnull(b.max_bundle,0)
	from laying_hdr a
	left outer join (select min(bundle_no) as min_bundle, max(bundle_no) as max_bundle, mono, layno from laying_pt group by mono, layno ) b on b.mono = a.mono and b.layno = a.layno
	where a.mono = @PARAMMONO and a.layno = b.layno

	update mo_hdr set mo_status = 'GENERATED' where mono = @PARAMMONO
	select 'Ticket Successfully Generated for MONo : ' + @PARAMMONO as 'description','success' as code

	--COMMIT TRANSACTION

--SET NOCOUNT OFF

END TRY
BEGIN CATCH
	SELECT 'ERROR' as code,ERROR_MESSAGE() AS 'Description'
	--ROLLBACK TRANSACTION
END CATCH
go

CREATE FUNCTION [dbo].[fnSplitString]
(
    @string VARCHAR(8000),
    @delimiter CHAR(1)
)
RETURNS @output TABLE(splitdata VARCHAR(2000))
BEGIN
    DECLARE @start INT, @end INT
    SELECT @start = 1, @end = CHARINDEX(@delimiter, @string)
    WHILE @start < LEN(@string) + 1 BEGIN
        IF @end = 0
            SET @end = LEN(@string) + 1

        INSERT INTO @output (splitdata)
        VALUES(SUBSTRING(@string, @start, @end - @start))
        SET @start = @end + 1
        SET @end = CHARINDEX(@delimiter, @string, @start)

    END
    RETURN
END
go

--exec usp_transfer_merge @fromId = 34101, @toId =  34100, @transferedBy ='admin'
CREATE  PROCEDURE usp_transfer_merge
--declare
		@fromId bigint = 34101,
		@toId bigint = 34100,
		@createdBy  varchar(20) ='admin',
		@transferQty int = 0
AS


	begin tran TRAN_CHANGE_LINE


		declare  @mono varchar(20),
						 @line varchar(20),
						 @planStart datetime,
						 @planFinish datetime,
						 @planQty int

		--GET THE TOTAL QTY TO UPDATE IN TO
		select @planQty = sum(Plan_Qty) from bo_hdr where id in (@fromId, @toId)

		--GET THE DESTINATION
		select @mono = mono, @planStart = Plan_Start ,@line = Line from bo_hdr where id in (@toId)

		--validate if the same mono and line 15244201003

		--DELETE the FROM ID
		DELETE BO_Hdr where id = @fromId

		--RECALCULATE THE FROM ID to UPDATE THE PLAN START
		SELECT top 1 @planFinish = plan_finish
		FROM AllocateDailyTarget(@mono, @line, @planQty, @planStart, 0)
		ORDER BY plan_start desc


		--UPDATE THE FROM ID TO GET THE OTHER VALUE FROM ID
		UPDATE BO_Hdr set Plan_Qty = @planQty, Plan_Finish = @planFinish, Updated_By = @createdBy, Time_Updated = getdate(), description = 'MERGE'
		WHERE id = @toId

		--ROLLBACK TRAN TRAN_CHANGE_LINE

	COMMIT TRAN TRAN_CHANGE_LINE

	Select code ='done', description = 'transferred'

RETURN
err:

ROLLBACK TRAN TRAN_CHANGE_LINE
go



CREATE PROC [dbo].[prdUpdateTicketQtysp]
(
	@PTNO	VARCHAR(13),
	@QTY	INT
) 

AS

BEGIN

	UPDATE Laying_PT SET QTY = @QTY WHERE PTNO = @PTNO
	
	--SELECT * 
	UPDATE B SET Qty = @QTY
	FROM m_VAP A
	INNER JOIN WIP_SCAN B ON A.code = B.VAP
	WHERE Initial_Check_Point = 1
	AND PTNO = @PTNO	

	UPDATE B SET Qty = @QTY
	FROM m_VAP A
	INNER JOIN WIP_SCAN_PART B ON A.code = B.VAP
	WHERE Initial_Check_Point = 1
	AND PTNO = @PTNO	


END

go

CREATE procedure usp_mo_list_4_split_merge
	@moDet VARCHAR(1000)
AS

        SELECT DISTINCT a.id, a.mono
        FROM mo_hdr a
            INNER JOIN (SELECT mh.iono, a.mono
                        FROM mo_det a
                                 INNER JOIN mo_hdr mh ON a.mo_id = mh.id
                        WHERE a.id IN (SELECT CAST(splitdata AS bigint) AS moDetId FROM fnSplitString(@moDet, ','))
            ) b ON a.iono = b.iono
        WHERE a.mono <> b.mono
go



CREATE PROC [dbo].[prdCreateBndlPTsp]
(
	@PTNO VARCHAR(13)
)
AS
--DECLARE @PTNO VARCHAR(13) = '401200025864'

DECLARE @MONO VARCHAR(20),
		@LAYNO VARCHAR(50),
		@CUTWS VARCHAR(50),
		@VAP VARCHAR(50)


SELECT 
@MONO = A.MONO,
@LAYNO = A.LAYNO,
@CUTWS = B.CUT_WORK_SECTION
FROM 
Laying_PT A
INNER JOIN Laying_Hdr B ON A.MONO = B.MONO AND A.LAYNO = B.LAYNO
WHERE 
PTNo = @PTNO


SELECT @VAP = code FROM m_VAP WHERE Initial_Check_Point = 1

INSERT INTO WIP_SCAN(MONO,LAYNO,PTNO,LOAD_TYPE,SEQ,VAP,SVAP,QTY,CREATED_BY,time_CREATED,WORK_SECTION,time_UPDATED,SCAN_DT,AUTHORIZED_BY,[Shift])
SELECT  
LAYING_PT.MONO, 
LAYNO, 
PTNO, 
1 AS LOADTYPE,
MO_VAP_SVAP.SEQ2,
MO_VAP_SVAP.VAP, 
SVAP, 
QTY, 
'system', 
GETDATE(),
@CUTWS,
NULL,
GETDATE(),
NULL,
'D'
FROM LAYING_PT
INNER JOIN MO_VAP_SVAP ON LAYING_PT.MONO = MO_VAP_SVAP.MONO AND MO_VAP_SVAP.ACTIVE = 1
WHERE LAYING_PT.MONO = @MONO AND VAP = @VAP
AND LAYING_PT.MONO = @MONO
AND LAYNO = @LAYNO
AND PTNo = @PTNO
AND PTNo NOT IN (SELECT PTNo FROM WIP_SCAN WHERE PTNo = @PTNO AND VAP = @VAP)


INSERT INTO WIP_SCAN_PART(REC_ID,MONO,LAYNO,PTNO,LOAD_TYPE,SEQ,VAP,SVAP,PART_CD,QTY,CREATED_BY,time_CREATED,WORK_SECTION,time_UPDATED,SCAN_DT,AUTHORIZED_BY,Day_Night_Shft)
SELECT  
	NEWID(),
	LAYING_PT.MONO, 
	LAYNO, 
	PTNO, 
	1 as LOADTYPE,
	(SELECT TOP 1 SEQ2 FROM MO_VAP_SVAP WHERE MONO = @MONO AND VAP = @VAP AND SVAP = MO_SVAP_PART.SVAP),
	MO_SVAP_PART.VAP, 
	MO_SVAP_PART.SVAP, 
	PART_CD,
	QTY, 
	'system', 
	GETDATE(),
	@CUTWS,
	NULL,
	GETDATE(),
	NULL,
	'D'
FROM LAYING_PT
INNER JOIN MO_SVAP_PART ON LAYING_PT.MONO = MO_SVAP_PART.MONO
WHERE LAYING_PT.MONO = @MONO AND VAP = @VAP
	AND LAYNO = @LAYNO
AND PTNo = @PTNO
AND Part_Cd NOT IN (SELECT Part_Cd FROM WIP_Scan_Part WHERE PTNo = @PTNO AND VAP = @VAP AND Part_Cd = MO_SVAP_Part.Part_Cd)


go



CREATE PROCEDURE [dbo].[plnUpdBOOutputV2]
(
	@USERID NVARCHAR(50),
	@MFGLOC VARCHAR(50)
)

AS

---- FOR TESTING
--DECLARE @USERID NVARCHAR(50) = 'raymart'
--DECLARE @MFGLOC VARCHAR(50) = 'TARLAC'

SET NOCOUNT ON;
	
BEGIN TRY

	INSERT INTO DBO.BO_TIME_STAMP(MFG_LOC, PROCESS, USER_ID, [TIME_STAMP]) 
	VALUES(@MFGLOC, 'Updating Daily Output', @USERID, GETDATE())

	CREATE TABLE #TMPOUTPUT
	(
		MONO VARCHAR(20),
		BONO VARCHAR(20),
		LINE VARCHAR(10),
		OUTPUT_DT DATETIME,
		OUTPUT_QTY NUMERIC(38, 0),
		PLAN_QTY NUMERIC(38, 0),
		ROWID INT
	)

	CREATE TABLE #BOHDR 
	(
		BONO VARCHAR(20),
		MONO VARCHAR(20),
		LINE VARCHAR(10),
		PLAN_START DATETIME,
		PLAN_QTY NUMERIC(38, 0),
		REMPLN_QTY NUMERIC(38, 0)
	)

	DECLARE @BONO VARCHAR(20),
			@BOMONO	VARCHAR(20),
			@BOLINE	VARCHAR(10),
			@PLANSTART DATETIME,
			@PLANQTY NUMERIC(38, 0),
			@REMPLNQTY NUMERIC(38, 0)
	DECLARE @MONO VARCHAR(20),
			@MOLINE	VARCHAR(10),
			@OUTPUTDT DATETIME,
			@OUTPUTQTY NUMERIC(38, 0)
	DECLARE @TOTOUTQTY NUMERIC(38, 0),
			@REMOUTQTY NUMERIC(38, 0),
			@SUMMOOUT INT,
			@SUMTOTOUT INT,
			@ROWID INT,
			@RECCNT INT,
			@RECCNT2 INT,
			@BOCNT INT

	SET @TOTOUTQTY = 0
	SET @REMOUTQTY = 0
	SET @ROWID = 0
	SET @SUMMOOUT = 0

--DECLARE @USERID NVARCHAR(50) = 'raymart'
--DECLARE @MFGLOC VARCHAR(50) = 'TARLAC'

	SELECT PDM.MONO, PDM.PROD_LINE, PDM.DATE_TRAN, PDM.[OUTPUT] 
	INTO #PLNDAILYMOBOMULTILNOUTVW
	FROM DBO.PLNDAILYMOBOMULTILNOUTVW PDM
	INNER JOIN DBO.m_PROD_LINES LN ON
		LN.PROD_LINE = PDM.PROD_LINE AND 
		LN.MFG_LOC = @MFGLOC AND 
		LN.active = 1


	SELECT PD.MONO, PD.PROD_LINE, PD.DATE_TRAN, PD.[OUTPUT], PD.BONO
	INTO #PLNDAILYMOBOOUTQTYVW
	FROM DBO.PLNDAILYMOBOOUTQTYVW PD
	INNER JOIN DBO.m_PROD_LINES LN ON
		LN.PROD_LINE = PD.PROD_LINE AND 
		LN.MFG_LOC = @MFGLOC AND 
		LN.active = 1


	SELECT BDO.MONO, BDO.LINE, BDO.[DATE], BDO.QTY
	INTO #BODAILYOUTPUT
	FROM DBO.BO_DAILY_OUTPUT BDO
	INNER JOIN DBO.m_PROD_LINES LN ON
		LN.PROD_LINE = BDO.LINE AND 
		LN.MFG_LOC = @MFGLOC AND 
		LN.active = 1


	SELECT 
		PROD_LINE, DATE_TRAN, 
		[WITHCAP] = DBO.PRDCHECKCAPACITYFN(PROD_LINE, DATE_TRAN)
	INTO #CHECKCAPACITY
	FROM
	(
		SELECT DISTINCT PROD_LINE, [DATE_TRAN] = (CONVERT(VARCHAR, DATE_TRAN, 101)) FROM #PLNDAILYMOBOMULTILNOUTVW
		UNION
		SELECT DISTINCT PROD_LINE, [DATE_TRAN] = (CONVERT(VARCHAR, DATE_TRAN, 101)) FROM #PLNDAILYMOBOOUTQTYVW
	) MT


	SELECT DISTINCT
		MONO, PROD_LINE
	INTO #OUTDIFF
	FROM
	(
		SELECT MONO, PROD_LINE, PRD_QTY = [OUTPUT], [PLN_QTY] = 0, DATE_TRAN FROM #PLNDAILYMOBOMULTILNOUTVW PDM
			WHERE EXISTS(SELECT 1 FROM #CHECKCAPACITY CAP WHERE CAP.PROD_LINE = PDM.PROD_LINE AND 
			CAP.DATE_TRAN = CONVERT(VARCHAR, PDM.DATE_TRAN, 101) )--AND WITHCAP = 'T')
		UNION ALL
		SELECT MONO, PROD_LINE, PRD_QTY = [OUTPUT], [PLN_QTY] = 0, DATE_TRAN FROM #PLNDAILYMOBOOUTQTYVW PDM
			WHERE EXISTS(SELECT 1 FROM #CHECKCAPACITY CAP WHERE CAP.PROD_LINE = PDM.PROD_LINE AND 
			CAP.DATE_TRAN = CONVERT(VARCHAR, PDM.DATE_TRAN, 101) ) -- AND WITHCAP = 'T')
		UNION ALL
		SELECT MONO, [PROD_LINE] = LINE, [PRD_QTY] = 0, [PLN_QTY] = QTY, [DATE_TRAN] = [DATE] FROM #BODAILYOUTPUT
	) MT
	GROUP BY MONO, PROD_LINE
	HAVING SUM(PRD_QTY) <> SUM(PLN_QTY)


	IF EXISTS(SELECT 1 FROM DBO.BO_HDR_COMPARE WHERE MFG_LOC = @MFGLOC)
	BEGIN

		INSERT INTO #OUTDIFF (MONO, PROD_LINE)
		SELECT DISTINCT
			MONO, LINE
		FROM
		(
			SELECT LINE, MONO, BONO, [NEW_QTY] = PLAN_QTY, [OLD_QTY] = 0 FROM DBO.BO_HDR WHERE MFG_LOC = @MFGLOC
			UNION ALL
			SELECT LINE, MONO, BONO, [NEW_QTY] = 0, [OLD_QTY] = PLAN_QTY FROM DBO.BO_HDR_COMPARE WHERE MFG_LOC = @MFGLOC
		) MT
		WHERE NOT EXISTS(SELECT 1 FROM #OUTDIFF OD WHERE OD.MONO = MT.MONO AND OD.PROD_LINE = MT.LINE)
		GROUP BY LINE, MONO, BONO
		HAVING SUM(NEW_QTY) <> SUM(OLD_QTY)

	END


	DELETE FROM DBO.BO_HDR_COMPARE WHERE MFG_LOC = @MFGLOC
	INSERT INTO DBO.BO_HDR_COMPARE(MFG_LOC, LINE, MONO, BONO, PLAN_QTY)
	SELECT
		MFG_LOC, LINE, MONO, BONO, PLAN_QTY
	FROM DBO.BO_HDR
	WHERE MFG_LOC = @MFGLOC


	DECLARE MOCUR CURSOR LOCAL FOR 
 	SELECT MONO, PROD_LINE, DATE_TRAN, [OUTPUT] FROM #PLNDAILYMOBOMULTILNOUTVW PDM
	WHERE EXISTS(SELECT 1 FROM #OUTDIFF OD WHERE OD.MONO = PDM.MONO AND OD.PROD_LINE = PDM.PROD_LINE) AND
		  EXISTS(SELECT 1 FROM #CHECKCAPACITY CAP WHERE CAP.PROD_LINE = PDM.PROD_LINE AND 
			CAP.DATE_TRAN = CONVERT(VARCHAR, PDM.DATE_TRAN, 101) )--AND WITHCAP = 'T')
		  --DBO.PRDCHECKCAPACITYFN(PRODLINE, DATETRAN) = 'T'
	ORDER BY MONO, PROD_LINE, DATE_TRAN
	
	OPEN MOCUR
	FETCH NEXT FROM MOCUR INTO @MONO, @MOLINE, @OUTPUTDT, @OUTPUTQTY
  		
	WHILE @@FETCH_STATUS = 0
	BEGIN	
		
		SET @REMOUTQTY = 0 
		IF NOT EXISTS (SELECT 'X' FROM #BOHDR WHERE MONO = @MONO AND LINE = @MOLINE)
		BEGIN 

			INSERT INTO #BOHDR 
			SELECT 
				BONO, MONO, LINE, PLAN_START, PLAN_QTY, PLAN_QTY 
			FROM DBO.BO_HDR 
			WHERE MONO = @MONO AND LINE = @MOLINE 
			ORDER BY BONO, PLAN_START 

		END
	
		IF @REMOUTQTY > 0
			SET @REMOUTQTY = @REMOUTQTY + @OUTPUTQTY
		ELSE
			SET @REMOUTQTY = @OUTPUTQTY

		SELECT @RECCNT = COUNT(1) FROM #BOHDR WHERE MONO = @MONO AND LINE = @MOLINE AND REMPLN_QTY > 0

		IF @RECCNT = 0 AND (SELECT COUNT(1) FROM #BOHDR WHERE MONO = @MONO AND LINE = @MOLINE) > 0
		BEGIN
			SET @ROWID = @ROWID + 1
			INSERT INTO #TMPOUTPUT VALUES(@MONO, @BONO, @BOLINE, @OUTPUTDT, @OUTPUTQTY, @PLANQTY, @ROWID)
		END

		SELECT @BOCNT = COUNT(1) FROM #BOHDR WHERE MONO = @MONO AND LINE = @MOLINE AND REMPLN_QTY > 0
		SET @RECCNT2 = 0

		DECLARE BOCUR CURSOR LOCAL FOR 
		SELECT BONO, MONO, LINE, PLAN_START, PLAN_QTY, REMPLN_QTY FROM #BOHDR 
		WHERE MONO = @MONO AND LINE = @MOLINE AND REMPLN_QTY > 0 ORDER BY PLAN_START
	
		OPEN BOCUR
		FETCH NEXT FROM BOCUR INTO @BONO, @BOMONO, @BOLINE, @PLANSTART, @PLANQTY, @REMPLNQTY

		WHILE @@FETCH_STATUS = 0
		BEGIN 				
			SET @RECCNT2 = @RECCNT2 + 1

			SET @ROWID = @ROWID + 1
			IF @REMOUTQTY <= 0
				GOTO NEXTLINE
			
			IF @REMOUTQTY >= @REMPLNQTY
			BEGIN
				SET @TOTOUTQTY = @REMPLNQTY
				UPDATE #BOHDR SET REMPLN_QTY = 0 WHERE BONO = @BONO AND MONO = @MONO AND LINE = @BOLINE
			END
			ELSE IF @REMOUTQTY < @REMPLNQTY
			BEGIN
				SET @TOTOUTQTY = @REMOUTQTY
				UPDATE #BOHDR SET REMPLN_QTY = @REMPLNQTY - @TOTOUTQTY WHERE BONO = @BONO AND MONO = @MONO AND LINE = @BOLINE
			END		

			IF @RECCNT = 1 OR @RECCNT2 = @BOCNT
			BEGIN 
				SET @TOTOUTQTY = @REMOUTQTY
			END


			SET @REMOUTQTY = @REMOUTQTY - @TOTOUTQTY

			IF @TOTOUTQTY > 0
				INSERT INTO #TMPOUTPUT VALUES(@MONO, @BONO, @BOLINE, DATEADD(SECOND,@ROWID,@OUTPUTDT), @TOTOUTQTY, @PLANQTY, @ROWID)
select 1, @mono, @TOTOUTQTY
			NEXTLINE:
			FETCH NEXT FROM BOCUR INTO @BONO, @BOMONO, @BOLINE, @PLANSTART, @PLANQTY, @REMPLNQTY
		END
	 
		CLOSE BOCUR
		DEALLOCATE BOCUR
	
 	FETCH NEXT FROM MOCUR INTO @MONO, @MOLINE, @OUTPUTDT, @OUTPUTQTY
	END		
 	
	CLOSE MOCUR
	DEALLOCATE MOCUR


	SELECT O.* INTO #BOOUT FROM 
	(SELECT OUTPUT_DT AS DATE_TRAN, MONO, BONO, LINE AS PROD_LINE, OUTPUT_QTY AS [OUTPUT] FROM #TMPOUTPUT
	UNION ALL
	SELECT DATE_TRAN, MONO, BONO, PROD_LINE, [OUTPUT] FROM #PLNDAILYMOBOOUTQTYVW PD
	WHERE EXISTS(SELECT 1 FROM #OUTDIFF OD WHERE OD.MONO = PD.MONO AND OD.PROD_LINE = PD.PROD_LINE) AND
		  EXISTS(SELECT 1 FROM #CHECKCAPACITY CAP WHERE CAP.PROD_LINE = PD.PROD_LINE AND 
			CAP.DATE_TRAN = CONVERT(VARCHAR, PD.DATE_TRAN, 101) AND WITHCAP = 'T')
		  --DBO.PRDCHECKCAPACITYFN(PRODLINE, DATETRAN) = 'T'
	) AS O

	select o.* from (SELECT OUTPUT_DT AS DATE_TRAN, MONO, BONO, LINE AS PROD_LINE, OUTPUT_QTY AS [OUTPUT] FROM #TMPOUTPUT
	UNION ALL
	SELECT DATE_TRAN, MONO, BONO, PROD_LINE, [OUTPUT] FROM #PLNDAILYMOBOOUTQTYVW PD
	WHERE EXISTS(SELECT 1 FROM #OUTDIFF OD WHERE OD.MONO = PD.MONO AND OD.PROD_LINE = PD.PROD_LINE) AND
		  EXISTS(SELECT 1 FROM #CHECKCAPACITY CAP WHERE CAP.PROD_LINE = PD.PROD_LINE AND 
			CAP.DATE_TRAN = CONVERT(VARCHAR, PD.DATE_TRAN, 101) AND WITHCAP = 'T')
		  --DBO.PRDCHECKCAPACITYFN(PRODLINE, DATETRAN) = 'T'
	) AS O


	DELETE BDO
	FROM DBO.BO_DAILY_OUTPUT BDO
	WHERE EXISTS(SELECT 1 FROM #OUTDIFF OD WHERE OD.MONO = BDO.MONO AND OD.PROD_LINE = BDO.LINE)


	INSERT INTO DBO.BO_DAILY_OUTPUT
		([MONO],[BONO],[LINE],[DATE],[QTY],[TARGET_QTY],[CREATED_BY],[TIME_CREATED])
	SELECT MO.MONO, MO.BONO, MO.PROD_LINE, MO.DATE_TRAN, MO.OUTPUT, 0, @USERID, GETDATE()
	FROM #BOOUT AS MO 

	SELECT MO.MONO, MO.BONO, MO.PROD_LINE, MO.DATE_TRAN, MO.OUTPUT, 0, @USERID, GETDATE()
	FROM #BOOUT AS MO 

	DROP TABLE #BOOUT
	DROP TABLE #TMPOUTPUT
	DROP TABLE #BOHDR
	DROP TABLE #PLNDAILYMOBOMULTILNOUTVW
	DROP TABLE #PLNDAILYMOBOOUTQTYVW
	DROP TABLE #BODAILYOUTPUT
	DROP TABLE #OUTDIFF
	DROP TABLE #CHECKCAPACITY

	SELECT 0 AS ERROR_FLAG, 'UPDATE COMPLETE' AS ERROR_MSG

END TRY	
BEGIN CATCH
	SELECT 1 AS ERROR_FLAG, ERROR_MESSAGE() AS ERROR_MSG
END CATCH

go

CREATE procedure usp_fg_update_pallet_info
	@palletCode varchar(20) = '',
	@sbuId integer = 0
as

	declare @totalCarton int = 0
	select @totalCarton = count(1) from fg_carton (nolock) where pallet = @palletCode

	update fg_pallet set carton_count = @totalCarton, rack_id = case when @totalCarton = 0 then null  else rack_id end,
		warehouse_id = case when @totalCarton = 0 then null  else warehouse_id end,
		is_closed = case when @totalCarton = 0 then 0  else 1 end
	where code = @palletCode

	select code = 'done', description = @totalCarton
go


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- =============================================
-- Author:		MCA
-- Create date: 05/12/2015
-- Description:	Create entries for MOGVAP
-- =============================================
create PROCEDURE [dbo].[stg_ordCreateMOGVAP]
	@MONo VARCHAR(20)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	CREATE TABLE #tmpMOGVAP(
		mo_id int
		,MONo VARCHAR(20)
		,GVAP_id int-- VARCHAR(20)
		,Duration NUMERIC(9,2)
		,Load_On bit
		,Load_Off bit
	)

	INSERT INTO #tmpMOGVAP(mo_id,MONo,GVAP_id,Duration,Load_On,Load_Off)
	SELECT mo_id,MONo,GVAP_id,Duration,Load_On,Load_Off FROM MO_GVAP WHERE MONo = @MONo
	--DELETE MOGVAP
	DELETE MO_GVAP WHERE MONo = @MONo

	--INSERT INTO MOGVAP, items from MOVAPSVAP not in MOGVAP
	INSERT INTO MO_GVAP(sbu_id,mo_id,MONo, GVAP_id,Seq,VAP_id1,SVAP_id1, VAP_id, SVAP_id
	--	--,SMV1,SMV2,SMV3
	,Duration,active,Created_By,time_Created,Load_On, Load_Off)
	select DISTINCT m.sbu_id,m.mo_id,m.MONo, m.GVAP_id
	, (SELECT TOP 1 Seq2 FROM MO_VAP_SVAP WHERE MONo = @MONo AND GVAP_id = m.GVAP_id AND ISNULL(Active,0) = 1) as Seq
	,(SELECT TOP 1 VAP_id FROM MO_VAP_SVAP WHERE MONo = @MONo AND GVAP_id = m.GVAP_id AND ISNULL(Load_On,0) = 1 AND ISNULL(Active,0) = 1 ORDER BY Seq2) AS VAP1
	,(SELECT TOP 1 SVAP_id FROM MO_VAP_SVAP WHERE MONo = @MONo AND GVAP_id = m.GVAP_id AND ISNULL(Load_On,0) = 1 AND ISNULL(Active,0) = 1 ORDER BY Seq2) AS SVAP1
	
	,isnull((SELECT TOP 1 VAP_id FROM MO_VAP_SVAP WHERE MONo = @MONo AND GVAP_id = m.GVAP_id AND ISNULL(Load_Off,0) = 1 AND ISNULL(Active,0) = 1 ORDER BY Seq2),1) AS VAP
	
	,isnull((SELECT TOP 1 SVAP_id FROM MO_VAP_SVAP WHERE MONo = @MONo AND GVAP_id = m.GVAP_id AND ISNULL(Load_Off,0) = 1 AND ISNULL(Active,0) = 1 ORDER BY Seq2),1) AS SVAP	
	--, 0 AS SMV1, 0 AS SMV2, 0 AS SMV3
	, g.Duration AS Duration, 1 AS Active
	,(SELECT TOP 1 Created_By FROM MO_VAP_SVAP WHERE MONo = @MONo AND GVAP_id = m.GVAP_id) AS CreatedBy
	, GETDATE() as CreatedDt	
	, g.Load_On
	, g.Load_Off
	FROM MO_VAP_SVAP m
	INNER JOIN m_SVAP s ON m.VAP_id = s.VAP_id AND m.SVAP_id = s.id
	INNER JOIN m_GVAP g ON s.GVAP_id = g.id
	--LEFT OUTER JOIN MOGVAP mg ON m.MONo = mg.MONo AND s.GVAP = mg.GVAP	
	WHERE --ISNULL(mg.Seq,0) = 0 AND 
	m.MONo = @MONo AND ISNULL(m.Active,0) = 1

	delete FROM MO_GVAP where MONo = @MONo AND vap_id = 1 and svap_id = 1

	UPDATE MO_GVAP 
		SET 
			Duration = CASE WHEN MO_GVAP.Duration <> #tmpMOGVAP.Duration THEN #tmpMOGVAP.Duration ELSE MO_GVAP.Duration END
			,Load_On = CASE WHEN MO_GVAP.Load_On <> #tmpMOGVAP.Load_On THEN #tmpMOGVAP.Load_On ELSE MO_GVAP.Load_On END
			,Load_Off = CASE WHEN MO_GVAP.Load_Off <> #tmpMOGVAP.Load_Off THEN #tmpMOGVAP.Load_Off ELSE MO_GVAP.Load_Off END
	FROM MO_GVAP 
	INNER JOIN #tmpMOGVAP
		ON MO_GVAP.MONo = #tmpMOGVAP.MONO
		AND MO_GVAP.GVAP_id = #tmpMOGVAP.GVAP_id

	------INSERT INTO MOGVAP, items from MOVAPSVAP not in MOGVAP
	--INSERT INTO MOGVAP(MONo, GVAP,Seq,SMV1,SMV2,SMV3,Duration,Deleted,CreatedBy,CreatedDt,VAP,SVAP)
 --   select MOVAPSVAP.MONo, GVAP.GVAP, MOVAPSVAP.Seq, 0 AS SMV1, 0 AS SMV2, 0 AS SMV3, GVAP.Duration AS Duration, 0 AS Deleted, MOVAPSVAP.CreatedBy, GETDATE() as CreatedDt, MOVAPSVAP.VAP,MOVAPSVAP.SVAP 
	--FROM MOVAPSVAP
	--INNER JOIN GVAP ON MOVAPSVAP.VAP = GVAP.VAP AND MOVAPSVAP.SVAP = GVAP.SVAP
	--LEFT OUTER JOIN MOGVAP ON MOVAPSVAP.MONo = MOGVAP.MONo AND GVAP.GVAP = MOGVAP.GVAP	
	--WHERE ISNULL(MOGVAP.Seq,0) = 0 AND MOVAPSVAP.MONo = @MONo

	--DELETE MOGVAP
	--FROM MOGVAP
	--INNER JOIN GVAP ON MOGVAP.GVAP = GVAP.GVAP
	--LEFT OUTER JOIN  MOVAPSVAP ON MOGVAP.MONo = MOVAPSVAP.MONo AND MOGVAP.Seq = MOVAPSVAP.Seq AND GVAP.VAP = MOVAPSVAP.VAP AND GVAP.SVAP = MOVAPSVAP.SVAP
	--WHERE ISNULL(MOVAPSVAP.Seq,0) = 0 AND MOGVAP.MONo = @MONo

	--Re sequence MOVAPSVAP remarks by Donel
	--EXEC iMAPPS.dbo.VAPSVAPReSequencesp 1, 0, @MONO, ''
END
go

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- exec prdGetBoSP @MfgLoc='TARLAC', @User='System', @line = 'L01'
-- =============================================
CREATE PROCEDURE [dbo].[prdGetBoSP] (@MfgLoc varchar(50) = '', @User nvarchar(50) = '', @datefrom date = '01/01/1900', @dateto date = '01/01/1900', @line varchar(max) = '', @mono varchar(20) = ''
, @building_code varchar(max) = '')
--,@startdisplay bigint = 1, @noOfRecords bigint = 100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	--GET daily Output
	exec usp_allocate_daily_output @transId= '', @selMono = '',  @mgfLoc = 'TARLAC', @isRecalculate= 0, @userId = 'System'
	/*
    DECLARE @MfgLoc varchar(50), @User nvarchar(50)
	SET @MfgLoc = 'TARLAC'
	SET @User = 'aj'
	*/
	--declare @datefrom date = getdate() - 30
	--check value @datefrom
	if @datefrom = '01/01/1900' or @datefrom is NULL or @datefrom = ''
		begin
			set @datefrom = getdate() - 30
		end
	if @dateto = '01/01/1900' or @dateto is NULL or @dateto = ''
		begin
			set @dateto = getdate() + 30
		end

	INSERT INTO BO_Time_stamp(Mfg_Loc,Process,User_Id,[Time_stamp])
	VALUES(@MfgLoc,'Loading BO',@User,getdate())

	DECLARE @LevelNo INT
	SELECT @LevelNo = Level_No FROM m_Mfg_Locs WHERE code = @MfgLoc

	IF OBJECT_ID('tempdb..#BOsmv') IS NOT NULL DROP TABLE #BOsmv

	SELECT Line, MONO, BONo, SMV, PlanSMV
	INTO #BOsmv
	FROM
	(
		SELECT
			B.Mfg_Loc
			,B.Line
			,B.MONO
			,B.BONo
			,ISNULL(B.SMV,0) as SMV
			,M.PlanSMV
		FROM
			BO_Hdr B
			INNER JOIN MO_Hdr M on B.MONo = M.MONo
		WHERE
			B.Mfg_Loc = @MfgLoc
			and B.Plan_Start >= DATEADD(dd, DATEDIFF(dd, 0, getdate()), 0)
			and B.Actual_Finish IS NULL
			and M.Active = 1
			and M.Plan_Completed = 0
			and M.MO_Status NOT IN ('Complete','Cancelled')
			----and B.MONo = '11520201001'
			----and B.MONo IN ('11575501002','11656101004')
		GROUP BY
			B.Mfg_Loc
			,B.Line
			,B.MONO
			,B.BONo
			,B.SMV
			,M.PlanSMV
	) A
	WHERE
		SMV <> PlanSMV
	ORDER BY
		Line
		,MONO
		,BONo
	--SELECT * FROM #BOsmv

	INSERT INTO Prod_Lines_CU(Mfg_Loc, Prod_Line, Trans_Dt)
	SELECT @MfgLoc, Line, getdate() FROM #BOsmv

	IF @LevelNo = 2 --Plant
	BEGIN
		SELECT
			b.id
			,B.MONo as MONo
			,B.BONo as BONo
			,B.Mfg_Loc as Mfg_Loc
			,B.Line as Line_Cd
			,B.CP_No as CP_No
			,B.Plan_Qty as Plan_Qty
			----,B.SMV as SMV
			----,(SELECT TOP 1 PlanSMV FROM #BOsmv WHERE MONo = B.MONo and BONo = B.BONo) as PlanSMV
			,ISNULL((SELECT TOP 1 PlanSMV FROM #BOsmv WHERE MONo = B.MONo and BONo = B.BONo),B.SMV) as SMV
			,B.Eff as Eff
			,B.EATM as EATM
			,B.Plan_Start as Plan_Start
			,B.Plan_Finish as Plan_Finish
			,B.Actual_Start as Actual_Start
			,B.Actual_Finish as Actual_Finish
			,B.Plant_Color as Plant_Color
			,B.Prd_Typ as Prd_Typ_Cd
			,B.Prd_Typ2 as Prd_Type2_Cd
			,B.Dif as Dif_Cd
			,ISNULL((SELECT sum(ISNULL(Qty,0)) FROM dbo.BO_Daily_Output WHERE sbu_id = 1 and MONo = B.MONo and BONo = B.BONo and Line = B.Line),0) as Total_Output_Qty
			,B.Prod_Month as Prod_Month
			,B.Completed as Completed
			,B.Created_By as Created_By
			,B.Time_Created as Time_Created
			,B.Updated_By as Updated_By
			,B.Time_Updated as Time_Updated
			,Board_Color = p.board_color
			,y.description as Building_Desc
			,y.code as Building_Code
			,B.MO_Cus_Del_Dt as cus_del_dt
			,x.locked_by
			,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH(NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Leather') as Mat_ETA
			,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH(NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Textile') as Mat_Tex_ETA
			,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH(NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Hardware') as Mat_Hrd_ETA
			,(SELECT TOP 1 Latest_ETA FROM MO_Mat_ETA WITH(NOLOCK) WHERE MONo = M.MONo and Mat_Typ = 'Zipper') as Mat_Zip_ETA
			,CASE WHEN ISNULL((SELECT TOP 1 DATEDIFF(dd,Plan_Start,Actual_Start) FROM MO_Events WITH(NOLOCK) WHERE MONo = M.MONo and Actual_Start IS NOT NULL ORDER BY Plan_Start DESC),0) > 0
				THEN (SELECT TOP 1 DATEADD(dd, DATEDIFF(dd,A.Plan_Start,A.Actual_Start) , B.Plan_Start)--B.Plan_Start + DATEDIFF(dd,A.Plan_Start,A.Actual_Start)
						FROM MO_Events A WITH(NOLOCK) inner join MO_Events B WITH(NOLOCK) on A.MONo = B.MONo WHERE A.MONo = M.MONo and A.Actual_Start IS NOT NULL and B.VAP = 'SEW' ORDER BY A.Plan_Start DESC) ELSE NULL END as CP_Date
			,PreDelay = 0
			,(SELECT TOP 1 dateadd(day, -2, convert(date, POD_Dt))  FROM MO_Det WITH(NOLOCK) WHERE MONo = M.MONo and Qty > 0) as LSF_Dt,
			CASE WHEN b.prod_month < plan_finish THEN 'true' else 'false' END  as is_late_plan_vs_prod_month,
			m.rev_ex_fty_dt,
			--CASE WHEN m.rev_ex_fty_dt < plan_finish THEN 'true' else 'false' END  as is_delayed_exfty_dt,
			(select case when plan_end > ex_fty_dt then 'true' else 'false' end  from mo_events where mono = M.mono and event_seq = '605') as is_delayed_exfty_dt,
			--is_material_delayed =  is_material_delayed
			is_material_delayed= ( select convert(bit, MAX( case when datediff(day, Plan_Start, isnull(Actual_Start,getdate())) > 0 then 1 else 0 end ) )
					from mo_events where MONo = M.mono and event_seq in (100,105,110) ) 

		FROM
			BO_Hdr B
			INNER JOIN MO_Hdr M on B.MONo = M.MONo --and B.MfgLoc = M.MfgLoc ----TO REMOVE BOs THAT DOES NOT EXIST IN MOHdr
			inner join m_line x on x.code = b.line
			inner join m_building y on y.id = x.building_id
			INNER JOIN m_prod_type p on p.code = m.prod_type
		WHERE
			B.Mfg_Loc = @MfgLoc
			----AND B.ActualFinish IS NULL --AND Completed <> 1  ----USE ActualFinish INSTEAD OF Completed TO KNOW Complete BOs
			AND B.MONo IS NOT NULL
			AND B.BONo IS NOT NULL
			AND B.Line IS NOT NULL
			AND M.Active = 1
			AND M.Plan_Completed = 0
			AND M.MO_Status NOT IN ('Complete','Cancelled')
			AND ISNULL(B.SMV,0)	> 0
			--AND ISNULL(M.Sub_Out,0) = 0
			----AND B.MONo IN ('11575501002','11656101004')
			--and (b.plan_start >= @datefrom or convert(varchar(10),b.plan_finish,101) = @datefrom)
			and (cast(b.plan_start as date) between @datefrom and @dateto or convert(varchar(10),b.plan_finish,101) = @datefrom)
			--and b.line = case when @line = '' then b.line else @line end
			--and substring(b.line,1,1) = 'L'
			and (b.line in (select * from fnsplitString(@line,','))  or  b.line = case when @line = '' then b.line else NULL end )
			and b.mono =  case when @mono = '' then b.mono else @mono end
			and (y.code in (select * from fnsplitString(@building_code,','))  or  y.code = case when @building_code = '' then y.code else NULL end )

		ORDER BY
			B.Line
			,B.Plan_Start
			,B.Plan_Finish
			,B.MONo
			,B.BONo

		--OFFSET @startdisplay ROWS FETCH NEXT @noOfRecords ROWS ONLY

	END

END
go

CREATE PROCEDURE [dbo].[prdRecalcBoDateSP]
(
	@MONO VARCHAR(20),
	@DATE DATETIME,
	@PLANSTART DATETIME OUTPUT,
	@PLANFINISH DATETIME OUTPUT
)

AS

/*DECLARE @NewBONo VARCHAR(20), @NewPlanQty INT, @NewPlanStart DATETIME, @NewPlanFinish DATETIME
exec prdRecalcBoDateSP @MONO = '13133001001', @DATE = '2023-02-03 00:47:00.433', @PLANSTART=@NewPlanStart output , @PLANFINISH= @NewPlanFinish output
select @NewPlanStart  as NewPlanStart,@NewPlanFinish as NewPlanFinish
*/
----FOR TESTING
/*DECLARE @MONO VARCHAR(20),
		@DATE DATETIME
SET @MONO = '13133001001'
SET	@DATE = '2023-02-03 00:47:00.433'*/

/*DECLARE
@PLANSTART DATETIME ,
@PLANFINISH DATETIME*/


SET NOCOUNT ON

BEGIN TRY
BEGIN TRANSACTION

		DECLARE @TOTAL_OUTMIN NUMERIC(18, 5)
		DECLARE @TOTAL_WRKMINS INT
		DECLARE @LINE VARCHAR(20)
		DECLARE @MFGLOC VARCHAR(20)
		DECLARE @BONO VARCHAR(20)

		SELECT TOP 1
			@LINE = LINE,
			@BONO = BONO
		FROM  DBO.BO_Daily_Output
		WHERE
			MONO = @MONO AND
			[Date] = @DATE

		SELECT
			@MFGLOC = mfg_loc
		FROM DBO.bo_hdr
		WHERE
			mono = @MONO AND
			BONO = @BONO AND
			LINE = @LINE

    --BO DAILY OUTPUT
		DECLARE @BODO TABLE
		(
			SEQ INT IDENTITY(1, 1),
			MONO VARCHAR(20),
			BONO VARCHAR(20),
			OUTMIN NUMERIC(18, 5),
			WRKMIN NUMERIC(18, 5),
			PLANSTART DATETIME,
			PLANFINISH DATETIME
		)

		INSERT INTO @BODO
			(MONO, BONO, OUTMIN)
		SELECT
			BD.MONO,
			BD.BONO,
			[OUTMIN] = (BD.QTY * BH.SMV)
		FROM DBO.BO_Daily_Output BD
		INNER JOIN DBO.BO_Hdr BH ON
			BH.MONO = BD.MONO AND
			BH.BONO = BD.BONO AND
			BH.LINE = BD.LINE
		WHERE
			CONVERT(VARCHAR, BD.[Date], 101) = CONVERT(VARCHAR, @DATE, 101) AND
			BD.LINE = @LINE
		ORDER BY
			--BH.PLANSTART
			BD.[Date]


		DECLARE @WRK_TIME TABLE
		(
			SEQ INT IDENTITY(1, 1),
			TIMEFROM TIME,
			TIMETO TIME
		)

		INSERT INTO @WRK_TIME
			(TIMEFROM, TIMETO)
		SELECT
			WMD.Time_From,
			WMD.Time_To
		FROM DBO.Prod_Lines_WM WM
		INNER JOIN DBO.Prod_Lines_WM_Det WMD ON
			WMD.Mfg_Loc = WM.Mfg_Loc AND
			WMD.Prod_Line = WM.Prod_Line AND
			WMD.Ex_Name = WM.Ex_Name
		WHERE
			CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN CAST((CONVERT(VARCHAR, WM.Date_From, 101)) AS DATETIME) AND
				CAST((CONVERT(VARCHAR, WM.Date_To, 101)) AS DATETIME) AND
			WM.Mfg_Loc = @MFGLOC AND
			WM.Prod_Line = @LINE AND
			(
				EXISTS(SELECT 1 FROM DBO.Prod_Lines_Ex EX WHERE EX.Mfg_Loc = @MFGLOC AND EX.Prod_Line = @LINE AND
					   (CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN CAST((CONVERT(VARCHAR, EX.Date_From, 101)) AS DATETIME) AND
					   CAST((CONVERT(VARCHAR, EX.DATE_TO, 101)) AS DATETIME)) AND EX.Active = 0 AND EX.MANPOWER > 0) OR
				(
					NOT EXISTS(SELECT 1 FROM DBO.Prod_Lines_Ex EX WHERE EX.MFG_LOC = @MFGLOC AND EX.PROD_LINE = @LINE AND
							   (CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN
							   CAST((CONVERT(VARCHAR, EX.DATE_FROM, 101)) AS DATETIME) AND
							   CAST((CONVERT(VARCHAR, EX.DATE_TO, 101)) AS DATETIME)) AND EX.Active = 1 AND EX.MANPOWER <= 0) AND
					(SELECT TOP 1 MP.MANPOWER FROM DBO.Prod_Lines_MP MP WHERE MP.MFG_LOC = @MFGLOC AND MP.PROD_LINE = @LINE AND
					 CAST((CONVERT(VARCHAR, MP.Effect_Dt, 101)) AS DATETIME) <= CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) AND
					 MP.Active = 1 ORDER BY CAST((CONVERT(VARCHAR, MP.Effect_Dt, 101)) AS DATETIME) DESC) > 0
				)
			)
		ORDER BY CONVERT(TIME, WMD.TIME_FROM)

/*select * from Prod_Lines_WM
select * from Calendar_Week_Day_Det
select * from Calendar_Week
select * from Calendar_Ex
select * from @BODO
select * from  @WRK_TIME*/
 /*
select *   FROM  DBO.BO_Daily_Output where MONo = '13133001001' and Date = ''
select *   FROM DBO.bo_hdr WHERE mono = '13133001001'
select @MONO as MONO, @DATE as Date , @BONO as bono, @LINE as line
*/


    -- IF NOT AVAILABLE IN THE SPECIAL WORKING DAY THEN GET THE DATA IN REGULAR WORKING DAY
		IF ((SELECT COUNT(1) FROM @WRK_TIME) = 0)
		BEGIN
			INSERT INTO @WRK_TIME
				(TIMEFROM, TIMETO)
			SELECT
				TIME_FROM,
				TIME_TO
			FROM DBO.Calendar_Week_Day_Det DET
			WHERE
				CALENDAR = @MFGLOC AND
				WEEK_NAME = (SELECT TOP 1 WEEK_NAME FROM DBO.Calendar_Week
							WHERE @DATE BETWEEN DATE_FROM AND DATE_TO) AND
				[Week_Day] = DATENAME(WEEKDAY, @DATE)
        AND NOT EXISTS (
            SELECT 1 FROM DBO.Calendar_Ex EX WHERE EX.CALENDAR = DET.CALENDAR AND
							CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN
							CAST((CONVERT(VARCHAR, EX.DATE_FROM, 101)) AS DATETIME) AND
							CAST((CONVERT(VARCHAR, EX.DATE_TO, 101)) AS DATETIME))
        AND
				(
					EXISTS(SELECT 1 FROM DBO.Prod_Lines_Ex EX WHERE EX.MFG_LOC = @MFGLOC AND EX.PROD_LINE = @LINE AND
						   (CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN CAST((CONVERT(VARCHAR, EX.DATE_FROM, 101)) AS DATETIME) AND
						   CAST((CONVERT(VARCHAR, EX.DATE_TO, 101)) AS DATETIME)) AND EX.Active = 1 AND EX.MANPOWER > 0)
          OR
					(
						NOT EXISTS(SELECT 1 FROM DBO.Prod_Lines_Ex EX WHERE EX.MFG_LOC = @MFGLOC AND EX.PROD_LINE = @LINE AND
								   (CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) BETWEEN
								   CAST((CONVERT(VARCHAR, EX.DATE_FROM, 101)) AS DATETIME) AND
								   CAST((CONVERT(VARCHAR, EX.DATE_TO, 101)) AS DATETIME)) AND EX.Active = 1 AND EX.MANPOWER <= 0) AND
						(SELECT TOP 1 MP.MANPOWER FROM DBO.Prod_Lines_MP MP WHERE MP.MFG_LOC = @MFGLOC AND MP.PROD_LINE = @LINE AND
						 CAST((CONVERT(VARCHAR, MP.EFFECT_DT, 101)) AS DATETIME) <= CAST((CONVERT(VARCHAR, @DATE, 101)) AS DATETIME) AND
						 MP.Active = 1 ORDER BY CAST((CONVERT(VARCHAR, MP.EFFECT_DT, 101)) AS DATETIME) DESC) > 0
					)
				)
			ORDER BY
				CONVERT(TIME, TIME_FROM)
		END


		SELECT @TOTAL_OUTMIN = SUM(OUTMIN) FROM @BODO

		SELECT
			@TOTAL_WRKMINS = SUM(DATEDIFF(MINUTE, TIMEFROM, TIMETO))
		FROM @WRK_TIME

		UPDATE @BODO
		SET WRKMIN = CASE WHEN CEILING((OUTMIN / @TOTAL_OUTMIN) * @TOTAL_WRKMINS) > 5
								THEN CEILING((OUTMIN / @TOTAL_OUTMIN) * @TOTAL_WRKMINS)
						  ELSE 5
					 END


		DECLARE @WRKMINS_DIFF INT
		SET @WRKMINS_DIFF = (SELECT SUM(WRKMIN) FROM @BODO) - @TOTAL_WRKMINS

		IF (@WRKMINS_DIFF > 0)
		BEGIN
			DECLARE @BODO_TEMP TABLE
			(
				SEQ INT,
				SEQ2 INT IDENTITY(1, 1),
				MONO VARCHAR(20),
				BONO VARCHAR(20),
				WRKMIN NUMERIC(18, 5)
			)

			INSERT INTO @BODO_TEMP
				(SEQ, MONO, BONO, WRKMIN)
			SELECT
				SEQ, MONO, BONO, WRKMIN
			FROM @BODO
			WHERE WRKMIN > 5
			ORDER BY WRKMIN DESC

			DECLARE @LOOP INT = 1
			DECLARE @CURRENT_WRKMIN INT



			WHILE(@LOOP <= (SELECT COUNT(1) FROM @BODO_TEMP))
			BEGIN
				SET @CURRENT_WRKMIN = (SELECT WRKMIN FROM @BODO_TEMP WHERE SEQ = @LOOP)

				IF((@CURRENT_WRKMIN - @WRKMINS_DIFF) >= 5)
				BEGIN
					UPDATE @BODO_TEMP
					SET WRKMIN = @CURRENT_WRKMIN - @WRKMINS_DIFF
					WHERE SEQ2 = @LOOP

					BREAK
				END
				ELSE
				BEGIN
					UPDATE @BODO_TEMP
					SET WRKMIN = 5
					WHERE SEQ2 = @LOOP

					SET @WRKMINS_DIFF = @WRKMINS_DIFF - (@CURRENT_WRKMIN - 5)
				END

				SET @LOOP = @LOOP + 1
			END
		END

      --select *, from @WRK_TIME



	/*	UPDATE ORG
		SET ORG.WRKMIN = TMP.WRKMIN
		FROM @BODO ORG
		INNER JOIN @BODO_TEMP TMP ON
			TMP.SEQ = ORG.SEQ
*/

		DECLARE @I INT = 1
		DECLARE @ITIME INT = 1
		DECLARE @TIMEFROM TIME
		DECLARE @TIMEFROM2 TIME
		DECLARE @TIMETO TIME
		DECLARE @STIME TIME
		DECLARE @FTIME TIME
		DECLARE @BALANCE NUMERIC(18, 5)


		SET @DATE = CONVERT(DATETIME, CONVERT(VARCHAR, @DATE, 101))


		WHILE(@I <= (SELECT COUNT(1) FROM @BODO))
		BEGIN

			SELECT
				@BALANCE = WRKMIN
			FROM @BODO
			WHERE SEQ = @I

			WHILE(@ITIME <= (SELECT COUNT(1) FROM @WRK_TIME))
			BEGIN

				SELECT
					@TIMEFROM = TIMEFROM,
					@TIMETO = TIMETO
				FROM @WRK_TIME
				WHERE SEQ = @ITIME

				IF(@STIME IS NULL)
				BEGIN
					SET @STIME = @TIMEFROM
				END

				SET @TIMEFROM2 = CASE WHEN @STIME >= @TIMEFROM THEN @STIME ELSE @TIMEFROM END

				IF(@TIMEFROM2 < @TIMETO)
				BEGIN
					IF(@ITIME = (SELECT COUNT(1) FROM @WRK_TIME) AND (DATEDIFF(MINUTE, @TIMEFROM2, @TIMETO) < @BALANCE))
					BEGIN
						SET @FTIME = DATEADD(MINUTE, DATEDIFF(MINUTE, @TIMEFROM2, @TIMETO), @TIMEFROM2)
						BREAK
					END
					ELSE IF((DATEDIFF(MINUTE, @TIMEFROM2, @TIMETO) >= @BALANCE))
					BEGIN
						SET @FTIME = DATEADD(MINUTE, @BALANCE, @TIMEFROM2)
						BREAK
					END
					ELSE
					BEGIN
						SET @BALANCE = @BALANCE - DATEDIFF(MINUTE, @TIMEFROM2, @TIMETO)
					END
				END
				SET @ITIME = @ITIME + 1

			END

			UPDATE @BODO
			SET PLANSTART = convert(datetime, convert(varchar(12),@DATE,101) +' ' + convert(varchar(8),@STIME)), -- @DATE + @STIME,
				PLANFINISH = convert(datetime, convert(varchar(12),@DATE,101) +' ' + convert(varchar(8),@FTIME)) --@DATE + @FTIME
			WHERE SEQ = @I

			IF((@I = (SELECT COUNT(1) FROM @BODO)) AND (@I <> 1))
			BEGIN
				UPDATE @BODO
				SET PLANFINISH = convert(datetime, convert(varchar(12),@DATE,101) + ' ' + convert(varchar(8), (SELECT MAX(TIMETO) FROM @WRK_TIME))) --DATEADD(MINUTE, 1, PLANFINISH)
				WHERE SEQ = @I
			END

			SET @STIME = @FTIME

			SET @I = @I + 1
			SET @ITIME = 1
		END

/*      select *, @WRKMINS_DIFF as WRKMINS_DIFF, @TOTAL_OUTMIN as TOTAL_OUTMIN, @DATE as DATE  from @BODO
      select @DATE, @STIME, convert(datetime, convert(varchar(12),@DATE,101) +' ' + convert(varchar(8),@STIME))
*/

		SELECT
			@PLANSTART = PLANSTART,
			@PLANFINISH = PLANFINISH
		FROM @BODO
		WHERE
			MONO = @MONO AND
			BONO = @BONO

--     SELECT @PLANSTART, @PLANFINISH

	COMMIT TRANSACTION
END TRY
BEGIN CATCH
	ROLLBACK TRANSACTION
END CATCH
go

--select newid()
--select sum(qty) from mo_det where mono = '13572801001'
/*
exec usp_save_planning @mfgLoc= 'TARLAC',  @mono= '15162301001', @lineNo = 'L05', @planStart = '2023-02-06 10:38:00',  @planQty= 203, @id = 0, @createdBy = 'Eduard', @sbuId = 1, @transId = '5A0ACFA7-816E-4B4F-8C68-0170917BB8B5'
select * from bo_hdr where Line = 'L01'
*/
CREATE PROCEDURE usp_save_planning_recalculate
--declare
    @mfgLoc varchar(10) = 'TARLAC',
    @mono varchar(11) ='',
    @bono integer = 0,
    @lineNo varchar(4) = '',
    @planStart datetime = null,
    @planQty integer = null ,
    @id BIGINT = 0,
    @createdBy varchar(20) ='',
    @sbuId int =  1,
    @isAutoAssignedPlanStart bit = 0,
    @isAutoPlanBalance bit = 0,
    @transId uniqueidentifier
AS
/*
set @mono  = '13133001001'
set @lineNo = 'L02'
SET @mfgLoc   = 'TARLAC'
SET @bono = 1
SET @planStart = '2023-02-03 07:30:00.000'
SET @planQty = 50
SET @sbuId  =  1
SET @id = 0
SET @isAutoAssignedPlanStart = 0
SET @isAutoPlanBalance = 0
SET @transId = '2E5BE0B8-A97B-4270-B5B3-B1F2C2180375'

-- */

declare @MAX_SCHEDULED_TIME_FINISH int = 15 --3PM. SET SOON
declare @planBalance INTEGER
declare @previosPlanBalance INTEGER
declare @dailyTarget INTEGER
declare @minutesTarget numeric(12,6) = 0
declare @actualPlanQty integer = 0
declare @TotalPlanQty integer = 0
declare @periodStart integer
declare @newPlanStart datetime
declare @planFinish datetime
declare @mfgLocId integer
declare @moId bigint


declare @efficiency numeric(4,2)
declare @manpower int
declare @workingMinutes int
declare @smv numeric(12,4)
declare @planStartMinutes integer = 0
declare @sheduleFinishBase datetime
declare @planStartBase datetime
declare @duration integer
-- declare @transId UNIQUEIDENTIFIER
-- declare @bono int
declare @timeCreated datetime = getdate()
declare @prodType varchar(20)
declare @prodMonth varchar(20)
declare @cusDelDt varchar(20)
declare @moQty int
declare @nextWorkingDate datetime
declare @moPlannedQty integer = 0
declare @moQtyPLanBalance int = 0

-- SET @mono = '13133001001'
-- SET @planQty = 500
-- SET @lineNo = 'L01'
-- SET @planStart = '2023-12-11 07:00:00.000'

declare @dateToCheck date = getdate()
declare @tempDate datetime = @dateToCheck
declare @DEFAULT_DATETIME datetime = dateadd(hour,7, @tempDate )

IF(@isAutoAssignedPlanStart = 1 OR @planStart is null )
BEGIN
  select @planStart = isnull(dateadd(minute, 1, max(Plan_Finish)), @DEFAULT_DATETIME ) from BO_Hdr where Line = @lineNo
END


SET @planBalance = isnull(@planQty,0)
SET @periodStart = 1
SET @newPlanStart = @planStart

-- IF EDITING and HAS ID PASSED. DELETE THE DATA
if(@id > 0)
BEGIN
    declare @lineToDelete varchar(4)
--     select @mono = mono, @bono=bono, @lineToDelete= Line from BO_Hdr where id = @id
    delete from BO_Daily_Target where MONo = @mono and BONo = @bono and Mfg_Loc = @mfgLoc and Line = @lineToDelete
    delete from BO_Hdr where id = @id
END

SELECT @mfgLocId  = id from m_mfg_locs where code = @mfgLoc
SELECT @moId = id, @prodType = prod_type, @prodMonth = prod_month, @cusDelDt = cus_del_dt from mo_hdr where mono = @mono
-- select @bono = BONo from bo_hdr_recalculate where MONo = @mono and BONo;
select @moQty = isnull(sum(qty),0) from mo_det where mono = @mono and qty > 0
select @moPlannedQty = isnull(sum(Plan_Qty),0) from bo_hdr_hist where MONo = @mono;

SET @moQtyPLanBalance = @moQty -  (@moPlannedQty + @planQty)

--SET THE NEW PLAN BALANCE FROM THE MO QTY LESS PLANNED
IF(@isAutoPlanBalance = 1 OR @planQty is null )
BEGIN
  SET @planBalance  = (@moQty-@moPlannedQty)
END

IF ( @moPlannedQty = @moQty )
BEGIN
  select code = 'error', description = 'this mono is already zero balance.'
  RETURN
END


-- VALIDATE. CHECK THE BALANCE
/*IF ( @moPlannedQty+@planBalance > @moQty )
BEGIN
  select code = 'error', description = 'please set your plan qty to ' + convert(varchar(12), @moQty-@moPlannedQty  )
  RETURN
END*/

/*if (EXISTS(select 1 from bo_hdr_hist where MONo = @mono and Line = @lineNo and @planStart between Plan_Start and Plan_Finish  ))
BEGIN
   SELECT 'error' as code, 'mono ' + @mono + ' with plan start ' + convert(varchar(20),@planStart) + ' and line '+ @lineNo + ' is already exists.' as description
    return
END*/

IF ( @planBalance = 0 )
BEGIN
  select code = 'error', description = 'no more balance to plan! total planned qty is ' + convert(varchar(12), @moPlannedQty)
  RETURN
END

IF(NOT EXISTS(select top 1 1 from  dbo.m_line_mp where line_code=@lineNo and eff_date<=@planStart order by eff_date desc))
BEGIN
  select code = 'error', description = 'Line manpower settings with effective date '
                                       + convert(varchar(20), @planStart) +' on line '+convert(varchar(20),@lineNo) +' not found. '
  RETURN
END

IF(NOT EXISTS(select * from m_line_lc where code =@prodType and line_code =@lineNo))
BEGIN
  select code = 'error', description = 'Learning curve settings with prod type '+convert(varchar(20),@prodType) +' and line '+convert(varchar(20),@lineNo) +' not found.'
  RETURN
END

BEGIN TRAN START_TRANS
--LOOP UNTIL NO BALANCE LEFT
while(@planBalance > 0)
-- while (@periodStart <= 3 )
BEGIN


    SET @sheduleFinishBase = dateadd(hour, @MAX_SCHEDULED_TIME_FINISH,'1900-01-01 00:00')
    SET @planStartBase = '1900-01-01 ' + format(@newPlanStart,'HH:mm')
    -- GET THE DURATION FROM PLAN START TO END OF SCHEDULE
    SET @duration = datediff(minute,@planStartBase, @sheduleFinishBase)

    SELECT
        @periodStart = period,
        @dailyTarget = manpower*working_minutes/smv*efficiency,
        @minutesTarget = (manpower*working_minutes/smv*efficiency)/working_minutes,
        @efficiency = efficiency,
        @manpower = manpower,
        @workingMinutes = working_minutes,
        @smv =smv,
        --@actualPlanQty = case when @planBalance >= @dailyTarget then @dailyTarget else @planBalance end,
        @planStartMinutes = (DATEPART(HOUR, @newPlanStart ) * 60) + DATEPART(MINUTE, @newPlanStart ),
        --1. PCS = TARGET QTY PER MINUTE TIMES REMAINING MINUTES OF THE DAY
        @actualPlanQty = ((manpower*working_minutes/smv*efficiency)/working_minutes) * @duration
    FROM (
         --1. Get the learning curve
        select code, period = period , efficiency,
            manpower = (select  top 1 manpower from ImappsV2.dbo.m_line_mp
                        where line_code =a.line
                        and eff_date<= @newPlanStart order by eff_date desc ),
            working_minutes = 480,
            smv = (select  plansmv from mo_hdr where mono = @mono )
        from view_mo_bo_learning_curve a
        where  line  = @lineNo  and mono = @mono and bono = @bono --and code = @prodType
        AND period = @periodStart

    ) A2

    if(@efficiency = 0)
    BEGIN
      select code = 'error', description = 'No setup efficiency on line ' + convert(varchar(20),@lineNo) +' with period ' + convert(varchar(20), @periodStart) +
      ' and prod type ' + @prodType
      goto err
      RETURN
    END

    --PCS = PLAN BALANCE
    --DURATION = now base on the REMAINING BALANCE
    IF(@planBalance <= @actualPlanQty)
    BEGIN
        SET @actualPlanQty = @planBalance
        SET @duration = @planBalance/@minutesTarget
    END

    SET @planBalance = @planBalance - @actualPlanQty
    SET @TotalPlanQty = @TotalPlanQty + @actualPlanQty

  -- TEMPORARY STORE THE PREVIOUS BALANCE
    SET @previosPlanBalance = @planBalance

    --IF PLAN BALANCE > 0. MEANS COMPLETE PLAN = TARGET. BUT WE NEED TO CONSIDER WHAT TIME IT STARTED TO PLAN.
    SET @planFinish =  dateadd(minute, @duration, @newPlanStart ) -- working_minutes = 540, 480 = 8 hours + 60 = 1 hours Break

  --CHECK VALUE HERE
     /*select @smv as smv,  @periodStart as periodStart, @planBalance as planBalance,@previosPlanBalance as previosPlanBalance, @TotalPlanQty TotalPlanQty,  @planQty planQty, @actualPlanQty as actualPlanQty,
            @duration as duration, @planStartBase planStartBase, @sheduleFinishBase sheduleFinishBase, @newPlanStart as newPlanStart,
            @nextWorkingDate nextWorkingDate, @planFinish as planFinish*/

    --INSERT THE DAILY TARGET HERE
    INSERT INTO bo_daily_target_hist(MONo, BONo, Line, Date, smv, seq, plan_start, plan_finish, Qty, original_daily_target,
                                Trans_Id, Trans_Dt, Mfg_Loc, sbu_id, Mfg_Loc_id, mo_id, Created_By, Time_Created )

    SELECT @mono, BONo = @bono, @lineNo, @newPlanStart, @smv, @periodStart, @newPlanStart, @planFinish, @actualPlanQty, @dailyTarget,
      @transId, Trans_Dt = getdate(), @mfgLoc, @sbuId, @mfgLocId, @moId, @createdBy, @timeCreated


    SET @nextWorkingDate  = dbo.getNextWorkingDate(@planFinish)

    -- GET NEXT DAY OR CONTINUE
    SET @newPlanStart = case when datepart(hour,@planFinish) >= @MAX_SCHEDULED_TIME_FINISH
      then @nextWorkingDate else  dateadd(minute, 1, @planFinish) end

    SET @periodStart = @periodStart + 1

END

--STEP 2: Summarize the data
DELETE FROM bo_hdr_hist where MONo = @mono and BONo = @bono
INSERT INTO bo_hdr_hist(sbu_id, MONo, MO_Qty, BONo, Mfg_Loc, Line, Plan_Qty, SMV, Plan_Start, Plan_Finish, Prd_Typ, MO_Cus_Del_Dt, Prod_Month, Created_By, Time_Created, Trans_Id, active, total_planned_qty)
SELECT @sbuId, MONo, @moQty, BONo, Mfg_Loc, Line, sum(Qty) as qty, smv, min(plan_start), max(plan_finish), @prodType, @cusDelDt, @prodMonth, @createdBy, @timeCreated, @transId, 1, sum(Qty)
FROM bo_daily_target_hist
WHERE MONo = @mono and BONo = @bono and Trans_Id = @transId
GROUP BY MONo, BONo, Mfg_Loc, Line,  smv

--STEP 3: INSERT THE MO+BO LEARNING CURVE
/*DELETE FROM BO_Learn_Curve where MONo = @mono and BONo = @bono and Line = @lineNo and sbu_id = @sbuId
insert into BO_Learn_Curve(MONo, BONo, Line, Learn_Curve, Period_01, Period_02, Period_03, Period_04, Period_05, Period_06, Period_07, Period_08, Period_09, Period_10,
                            Period_11, Period_12, Period_13, Period_14, Period_15, Period_16, Period_17, Period_18, Period_19, Period_20,
                            Period_21, Period_22, Period_23, Period_24, Period_25, Period_26, Period_27, Period_28, Period_29, Period_30,
                            Created_By, Time_Created, Updated_By, Trans_Id, Trans_Dt, Mfg_Loc, active, sbu_id)
select top 1 MONo = @mono, BONo = @bono, Line = @lineNo, Learn_Curve, Period_01, Period_02, Period_03, Period_04, Period_05, Period_06, Period_07, Period_08, Period_09, Period_10,
                            Period_11, Period_12, Period_13, Period_14, Period_15, Period_16, Period_17, Period_18, Period_19, Period_20,
                            Period_21, Period_22, Period_23, Period_24, Period_25, Period_26, Period_27, Period_28, Period_29, Period_30,
                            Created_By, Time_Created, Updated_By, @transId, @timeCreated, @mfgLoc, active, sbu_id
from m_line_lc
WHERE line_code = @lineNo and code = @prodType*/

SELECT 'success' as code, 'succesfull planned mono ' + @mono + ' bono ' + convert(varchar(12),@bono)  as description
-- SELECT *  from BO_Daily_Target where Line in ('L01','L02')

COMMIT TRAN START_TRANS
return

err:
ROLLBACK TRAN START_TRANS
go

CREATE procedure usp_mo_split_merge_dev
	@process VARCHAR(10),       -->  merge,split
	@moId bigint,
	@moDet VARCHAR(1000),
	@username varchar(30) = 'admin',
	@showId BIT = 1
AS
SET NOCOUNT ON
    DECLARE @mono varchar(30), @iono varchar(30)
    DECLARE @monoMX INT = 0, @ConoCount INT
    DECLARE @currentMOId BIGINT, @newMono varchar(30)


    PRINT 'GET MONO, IONO base on Det.ids'
    SELECT DISTINCT TOP 1 @iono = mh.iono, @mono = mh.mono, @currentMOId = a.mo_id
    from mo_det a
        INNER JOIN mo_hdr mh ON a.mo_id = mh.id
    WHERE  a.id in (
            SELECT CAST(splitdata as bigint) as moDetId
            FROM fnSplitString(@moDet,',')
            )
    AND mh.active = 1


        IF @moId IS NULL    --> NEW MONO
        BEGIN
            SELECT @monoMX = MAX( CAST( RIGHT(mono,3) as int) )
            FROM mo_hdr
            where iono = @iono -- AND active  = 1
            GROUP BY iono

            SET @newMono = SUBSTRING(@mono,1, LEN(@mono)-3 ) + RIGHT('000' + CAST(@monoMX+1 as varchar(100)),3)

            -- create new base on currennt selected det
            INSERT INTO mo_hdr(active, mono, created_by, sbu_id, time_created, time_updated, updated_by, sub_mat_lead,
                               base_plan, board_color, cancel_mo_dt, code, cono, cus_del_dt, date_rerouted,
                               description, eff, fty_loc, garm_part, iono, learn_curve, lpd_dt, main_mat_lead,
                               mat_prep_lead, merchsmv, mfg_loc, mo_status, parent_mono, plan_completed,
                               plansmv, plant, post_sew, pre_sew, prod_days, prod_min, prod_month, prod_type,
                               psd_dt, re_routed, ref_auto_create_mo, remarks, req_ex_fty_dt, req_main_mateta,
                               req_mateta, req_prod_start, req_sub_mateta, rerouted_by, rev_cus_del_dt, rev_ex_fty_dt,
                               source_mono, source_pono, split_no, style_no, tcsmv, transit_days)
            SELECT 1 as  active, @newMono, @username as created_by, sbu_id, getdate()  as time_created, time_updated, updated_by, sub_mat_lead,
                               base_plan, board_color, cancel_mo_dt, code, '' as cono, cus_del_dt, date_rerouted,
                               description, eff, fty_loc, garm_part, iono, learn_curve, lpd_dt, main_mat_lead,
                               mat_prep_lead, merchsmv, mfg_loc, mo_status, parent_mono, plan_completed,
                               plansmv, plant, post_sew, pre_sew, prod_days, prod_min, prod_month, prod_type,
                               psd_dt, re_routed, ref_auto_create_mo, '' as remarks, req_ex_fty_dt, req_main_mateta,
                               req_mateta, req_prod_start, req_sub_mateta, rerouted_by, rev_cus_del_dt, rev_ex_fty_dt,
                               source_mono, source_pono, split_no, style_no, tcsmv, transit_days
            FROM mo_hdr
            WHERE id = @currentMOId

            SET @moId = @@identity

        END ELSE    --> Selected MO
        BEGIN
            SET @newMono =  @mono
        END

        Update a SET
            mono = @newMono, mo_id = @moId
        from mo_det a
            INNER JOIN mo_hdr mh ON a.mo_id = mh.id
        WHERE mh.iono = @iono --> making sure its on the same IOno
              AND a.id in (
                SELECT CAST(splitdata as bigint) as moDetId
                FROM fnSplitString(@moDet,',')
                )

        UPDATE a SET cono = CASE WHEN c.dCtr = 1 THEN b.cono WHEN c.dCtr > 1 THEN '' ELSE '' END,
            active = CASE WHEN c.dCtr >= 1 THEN 1 ELSE 0 END
        /*SELECT a.id, a.mono, a.active, a.cono,
            CASE WHEN c.dCtr = 1 THEN b.cono WHEN c.dCtr > 1 THEN '' ELSE '' END as cono,
            CASE WHEN c.dCtr >= 1 THEN 1 ELSE 0 END as active,
            '-->', b.cono, c.**/
        FROM mo_hdr a
            LEFT JOIN mo_det b ON a.id = b.mo_id
            LEFT JOIN (
                SELECT a.id, SUM(CASE WHEN b.id IS NOT NULL THEN 1 ELSE 0 END ) as dCtr
                FROM mo_hdr a
                    LEFT JOIN mo_det b ON a.id = b.mo_id
                WHERE a.iono = @iono
                GROUP BY a.id
            ) c ON c.id = a.id
        WHERE a.iono = @iono

        /*SELECT @ConoCount = COUNT(1)
        FROM mo_det
        WHERE mo_id = @moId

        IF @ConoCount = 1
        BEGIN
            UPDATE a SET cono = b.cono, active = 1
            FROM mo_hdr a
                INNER JOIN mo_det b ON a.id = b.mo_id
            WHERE a.id = @moId
        END ELSE IF @ConoCount > 1
        BEGIN
            UPDATE mo_hdr SET cono = '', active = 1,  updated_by = @username, time_updated = getdate()
            WHERE id = @moId
        END
        BEGIN
            UPDATE a
                SET cono = b.cono, active = 1
            FROM mo_hdr a
                INNER JOIN mo_det b ON a.id = b.mo_id
            WHERE a.id = @moId
        END*/


    if @showId = 1
        SELECT @moId as id
go

